// Code generated by protoc-gen-go. DO NOT EDIT.
// source: ortools/linear_solver/linear_solver.proto

package gen

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
	gen "ortools/go/util/gen"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Status returned by the solver. They follow a hierarchical nomenclature, to
// allow us to add more enum values in the future. Clients should use
// InCategory() to match these enums, with the following C++ pseudo-code:
//
// bool InCategory(MPSolverResponseStatus status, MPSolverResponseStatus cat) {
//   if (cat == MPSOLVER_OPTIMAL) return status == MPSOLVER_OPTIMAL;
//   while (status > cat) status >>= 4;
//   return status == cat;
// }
type MPSolverResponseStatus int32

const (
	// The solver found the proven optimal solution. This is what should be
	// returned in most cases.
	//
	// WARNING: for historical reason, the value is zero, which means that this
	// value can't have any subcategories.
	MPSolverResponseStatus_MPSOLVER_OPTIMAL MPSolverResponseStatus = 0
	// The solver had enough time to find some solution that satisfies all
	// constraints, but it did not prove optimality (which means it may or may
	// not have reached the optimal).
	//
	// This can happen for large LP models (Linear Programming), and is a frequent
	// response for time-limited MIPs (Mixed Integer Programming). In the MIP
	// case, the difference between the solution 'objective_value' and
	// 'best_objective_bound' fields of the MPSolutionResponse will give an
	// indication of how far this solution is from the optimal one.
	MPSolverResponseStatus_MPSOLVER_FEASIBLE MPSolverResponseStatus = 1
	// The model does not have any solution, according to the solver (which
	// "proved" it, with the caveat that numerical proofs aren't actual proofs),
	// or based on trivial considerations (eg. a variable whose lower bound is
	// strictly greater than its upper bound).
	MPSolverResponseStatus_MPSOLVER_INFEASIBLE MPSolverResponseStatus = 2
	// There exist solutions that make the magnitude of the objective value
	// as large as wanted (i.e. -infinity (resp. +infinity) for a minimization
	// (resp. maximization) problem.
	MPSolverResponseStatus_MPSOLVER_UNBOUNDED MPSolverResponseStatus = 3
	// An error (most probably numerical) occurred.
	// One likely cause for such errors is a large numerical range among variable
	// coefficients (eg. 1e-16, 1e20), in which case one should try to shrink it.
	MPSolverResponseStatus_MPSOLVER_ABNORMAL MPSolverResponseStatus = 4
	// The solver did not have a chance to diagnose the model in one of the
	// categories above.
	MPSolverResponseStatus_MPSOLVER_NOT_SOLVED MPSolverResponseStatus = 6
	// Like "NOT_SOLVED", but typically used by model validation functions
	// returning a "model status", to enhance readability of the client code.
	MPSolverResponseStatus_MPSOLVER_MODEL_IS_VALID MPSolverResponseStatus = 97
	// Special value: the solver status could not be properly translated and is
	// unknown.
	MPSolverResponseStatus_MPSOLVER_UNKNOWN_STATUS MPSolverResponseStatus = 99
	// Model errors. These are always deterministic and repeatable.
	// They should be accompanied with a string description of the error.
	MPSolverResponseStatus_MPSOLVER_MODEL_INVALID MPSolverResponseStatus = 5
	// Something is wrong with the fields "solution_hint_var_index" and/or
	// "solution_hint_var_value".
	MPSolverResponseStatus_MPSOLVER_MODEL_INVALID_SOLUTION_HINT MPSolverResponseStatus = 84
	// Something is wrong with the solver_specific_parameters request field.
	MPSolverResponseStatus_MPSOLVER_MODEL_INVALID_SOLVER_PARAMETERS MPSolverResponseStatus = 85
	// Implementation error: the requested solver implementation is not
	// available (see MPModelRequest.solver_type).
	// The linear solver binary was probably not linked with the required library,
	// eg //ortools/linear_solver:linear_solver_scip for SCIP.
	MPSolverResponseStatus_MPSOLVER_SOLVER_TYPE_UNAVAILABLE MPSolverResponseStatus = 7
)

var MPSolverResponseStatus_name = map[int32]string{
	0:  "MPSOLVER_OPTIMAL",
	1:  "MPSOLVER_FEASIBLE",
	2:  "MPSOLVER_INFEASIBLE",
	3:  "MPSOLVER_UNBOUNDED",
	4:  "MPSOLVER_ABNORMAL",
	6:  "MPSOLVER_NOT_SOLVED",
	97: "MPSOLVER_MODEL_IS_VALID",
	99: "MPSOLVER_UNKNOWN_STATUS",
	5:  "MPSOLVER_MODEL_INVALID",
	84: "MPSOLVER_MODEL_INVALID_SOLUTION_HINT",
	85: "MPSOLVER_MODEL_INVALID_SOLVER_PARAMETERS",
	7:  "MPSOLVER_SOLVER_TYPE_UNAVAILABLE",
}

var MPSolverResponseStatus_value = map[string]int32{
	"MPSOLVER_OPTIMAL":                         0,
	"MPSOLVER_FEASIBLE":                        1,
	"MPSOLVER_INFEASIBLE":                      2,
	"MPSOLVER_UNBOUNDED":                       3,
	"MPSOLVER_ABNORMAL":                        4,
	"MPSOLVER_NOT_SOLVED":                      6,
	"MPSOLVER_MODEL_IS_VALID":                  97,
	"MPSOLVER_UNKNOWN_STATUS":                  99,
	"MPSOLVER_MODEL_INVALID":                   5,
	"MPSOLVER_MODEL_INVALID_SOLUTION_HINT":     84,
	"MPSOLVER_MODEL_INVALID_SOLVER_PARAMETERS": 85,
	"MPSOLVER_SOLVER_TYPE_UNAVAILABLE":         7,
}

func (x MPSolverResponseStatus) Enum() *MPSolverResponseStatus {
	p := new(MPSolverResponseStatus)
	*p = x
	return p
}

func (x MPSolverResponseStatus) String() string {
	return proto.EnumName(MPSolverResponseStatus_name, int32(x))
}

func (x *MPSolverResponseStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MPSolverResponseStatus_value, data, "MPSolverResponseStatus")
	if err != nil {
		return err
	}
	*x = MPSolverResponseStatus(value)
	return nil
}

func (MPSolverResponseStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dc74569f987c0a21, []int{0}
}

type MPSosConstraint_Type int32

const (
	// At most one variable in `var_index` must be non-zero.
	MPSosConstraint_SOS1_DEFAULT MPSosConstraint_Type = 0
	// At most two consecutive variables from `var_index` can be non-zero (i.e.
	// for some i, var_index[i] and var_index[i+1]). See
	// http://www.eudoxus.com/lp-training/5/5-6-special-ordered-sets-of-type-2
	MPSosConstraint_SOS2 MPSosConstraint_Type = 1
)

var MPSosConstraint_Type_name = map[int32]string{
	0: "SOS1_DEFAULT",
	1: "SOS2",
}

var MPSosConstraint_Type_value = map[string]int32{
	"SOS1_DEFAULT": 0,
	"SOS2":         1,
}

func (x MPSosConstraint_Type) Enum() *MPSosConstraint_Type {
	p := new(MPSosConstraint_Type)
	*p = x
	return p
}

func (x MPSosConstraint_Type) String() string {
	return proto.EnumName(MPSosConstraint_Type_name, int32(x))
}

func (x *MPSosConstraint_Type) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MPSosConstraint_Type_value, data, "MPSosConstraint_Type")
	if err != nil {
		return err
	}
	*x = MPSosConstraint_Type(value)
	return nil
}

func (MPSosConstraint_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dc74569f987c0a21, []int{4, 0}
}

type MPSolverCommonParameters_LPAlgorithmValues int32

const (
	MPSolverCommonParameters_LP_ALGO_UNSPECIFIED MPSolverCommonParameters_LPAlgorithmValues = 0
	MPSolverCommonParameters_LP_ALGO_DUAL        MPSolverCommonParameters_LPAlgorithmValues = 1
	MPSolverCommonParameters_LP_ALGO_PRIMAL      MPSolverCommonParameters_LPAlgorithmValues = 2
	MPSolverCommonParameters_LP_ALGO_BARRIER     MPSolverCommonParameters_LPAlgorithmValues = 3
)

var MPSolverCommonParameters_LPAlgorithmValues_name = map[int32]string{
	0: "LP_ALGO_UNSPECIFIED",
	1: "LP_ALGO_DUAL",
	2: "LP_ALGO_PRIMAL",
	3: "LP_ALGO_BARRIER",
}

var MPSolverCommonParameters_LPAlgorithmValues_value = map[string]int32{
	"LP_ALGO_UNSPECIFIED": 0,
	"LP_ALGO_DUAL":        1,
	"LP_ALGO_PRIMAL":      2,
	"LP_ALGO_BARRIER":     3,
}

func (x MPSolverCommonParameters_LPAlgorithmValues) Enum() *MPSolverCommonParameters_LPAlgorithmValues {
	p := new(MPSolverCommonParameters_LPAlgorithmValues)
	*p = x
	return p
}

func (x MPSolverCommonParameters_LPAlgorithmValues) String() string {
	return proto.EnumName(MPSolverCommonParameters_LPAlgorithmValues_name, int32(x))
}

func (x *MPSolverCommonParameters_LPAlgorithmValues) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MPSolverCommonParameters_LPAlgorithmValues_value, data, "MPSolverCommonParameters_LPAlgorithmValues")
	if err != nil {
		return err
	}
	*x = MPSolverCommonParameters_LPAlgorithmValues(value)
	return nil
}

func (MPSolverCommonParameters_LPAlgorithmValues) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dc74569f987c0a21, []int{13, 0}
}

// The solver type, which will select a specific implementation, and will also
// impact the interpretation of the model (i.e. are we solving the problem
// as a mixed integer program or are we relaxing it as a continuous linear
// program?).
// This must remain consistent with MPSolver::OptimizationProblemType.
type MPModelRequest_SolverType int32

const (
	MPModelRequest_GLOP_LINEAR_PROGRAMMING          MPModelRequest_SolverType = 2
	MPModelRequest_CLP_LINEAR_PROGRAMMING           MPModelRequest_SolverType = 0
	MPModelRequest_GLPK_LINEAR_PROGRAMMING          MPModelRequest_SolverType = 1
	MPModelRequest_GUROBI_LINEAR_PROGRAMMING        MPModelRequest_SolverType = 6
	MPModelRequest_XPRESS_LINEAR_PROGRAMMING        MPModelRequest_SolverType = 101
	MPModelRequest_CPLEX_LINEAR_PROGRAMMING         MPModelRequest_SolverType = 10
	MPModelRequest_SCIP_MIXED_INTEGER_PROGRAMMING   MPModelRequest_SolverType = 3
	MPModelRequest_GLPK_MIXED_INTEGER_PROGRAMMING   MPModelRequest_SolverType = 4
	MPModelRequest_CBC_MIXED_INTEGER_PROGRAMMING    MPModelRequest_SolverType = 5
	MPModelRequest_GUROBI_MIXED_INTEGER_PROGRAMMING MPModelRequest_SolverType = 7
	MPModelRequest_XPRESS_MIXED_INTEGER_PROGRAMMING MPModelRequest_SolverType = 102
	MPModelRequest_CPLEX_MIXED_INTEGER_PROGRAMMING  MPModelRequest_SolverType = 11
	MPModelRequest_BOP_INTEGER_PROGRAMMING          MPModelRequest_SolverType = 12
	// WARNING: This solver will currently interpret all variables as integer,
	// so any solution you get will be valid, but the optimal might be far away
	// for the real one (when you authorise non-integer value for continuous
	// variables).
	MPModelRequest_SAT_INTEGER_PROGRAMMING            MPModelRequest_SolverType = 14
	MPModelRequest_KNAPSACK_MIXED_INTEGER_PROGRAMMING MPModelRequest_SolverType = 13
)

var MPModelRequest_SolverType_name = map[int32]string{
	2:   "GLOP_LINEAR_PROGRAMMING",
	0:   "CLP_LINEAR_PROGRAMMING",
	1:   "GLPK_LINEAR_PROGRAMMING",
	6:   "GUROBI_LINEAR_PROGRAMMING",
	101: "XPRESS_LINEAR_PROGRAMMING",
	10:  "CPLEX_LINEAR_PROGRAMMING",
	3:   "SCIP_MIXED_INTEGER_PROGRAMMING",
	4:   "GLPK_MIXED_INTEGER_PROGRAMMING",
	5:   "CBC_MIXED_INTEGER_PROGRAMMING",
	7:   "GUROBI_MIXED_INTEGER_PROGRAMMING",
	102: "XPRESS_MIXED_INTEGER_PROGRAMMING",
	11:  "CPLEX_MIXED_INTEGER_PROGRAMMING",
	12:  "BOP_INTEGER_PROGRAMMING",
	14:  "SAT_INTEGER_PROGRAMMING",
	13:  "KNAPSACK_MIXED_INTEGER_PROGRAMMING",
}

var MPModelRequest_SolverType_value = map[string]int32{
	"GLOP_LINEAR_PROGRAMMING":            2,
	"CLP_LINEAR_PROGRAMMING":             0,
	"GLPK_LINEAR_PROGRAMMING":            1,
	"GUROBI_LINEAR_PROGRAMMING":          6,
	"XPRESS_LINEAR_PROGRAMMING":          101,
	"CPLEX_LINEAR_PROGRAMMING":           10,
	"SCIP_MIXED_INTEGER_PROGRAMMING":     3,
	"GLPK_MIXED_INTEGER_PROGRAMMING":     4,
	"CBC_MIXED_INTEGER_PROGRAMMING":      5,
	"GUROBI_MIXED_INTEGER_PROGRAMMING":   7,
	"XPRESS_MIXED_INTEGER_PROGRAMMING":   102,
	"CPLEX_MIXED_INTEGER_PROGRAMMING":    11,
	"BOP_INTEGER_PROGRAMMING":            12,
	"SAT_INTEGER_PROGRAMMING":            14,
	"KNAPSACK_MIXED_INTEGER_PROGRAMMING": 13,
}

func (x MPModelRequest_SolverType) Enum() *MPModelRequest_SolverType {
	p := new(MPModelRequest_SolverType)
	*p = x
	return p
}

func (x MPModelRequest_SolverType) String() string {
	return proto.EnumName(MPModelRequest_SolverType_name, int32(x))
}

func (x *MPModelRequest_SolverType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MPModelRequest_SolverType_value, data, "MPModelRequest_SolverType")
	if err != nil {
		return err
	}
	*x = MPModelRequest_SolverType(value)
	return nil
}

func (MPModelRequest_SolverType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dc74569f987c0a21, []int{15, 0}
}

// A variable is always constrained in the form:
//    lower_bound <= x <= upper_bound
// where lower_bound and upper_bound:
// - Can form a singleton: x = constant = lower_bound = upper_bound.
// - Can form a finite interval: lower_bound <= x <= upper_bound. (x is boxed.)
// - Can form a semi-infinite interval.
//     - lower_bound = -infinity: x <= upper_bound.
//     - upper_bound = +infinity: x >= lower_bound.
// - Can form the infinite interval: lower_bound = -infinity and
//   upper_bound = +infinity, x is free.
// MPVariableProto furthermore stores:
//  - The coefficient of the variable in the objective.
//  - Whether the variable is integer.
type MPVariableProto struct {
	// lower_bound must be <= upper_bound.
	LowerBound *float64 `protobuf:"fixed64,1,opt,name=lower_bound,json=lowerBound,def=-inf" json:"lower_bound,omitempty"`
	UpperBound *float64 `protobuf:"fixed64,2,opt,name=upper_bound,json=upperBound,def=inf" json:"upper_bound,omitempty"`
	// The coefficient of the variable in the objective. Must be finite.
	ObjectiveCoefficient *float64 `protobuf:"fixed64,3,opt,name=objective_coefficient,json=objectiveCoefficient,def=0" json:"objective_coefficient,omitempty"`
	// True if the variable is constrained to be integer.
	// Ignored if MPModelProto::solver_type is *LINEAR_PROGRAMMING*.
	IsInteger *bool `protobuf:"varint,4,opt,name=is_integer,json=isInteger,def=0" json:"is_integer,omitempty"`
	// The name of the variable.
	Name                 *string  `protobuf:"bytes,5,opt,name=name,def=" json:"name,omitempty"`
	BranchingPriority    *int32   `protobuf:"varint,6,opt,name=branching_priority,json=branchingPriority,def=0" json:"branching_priority,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MPVariableProto) Reset()         { *m = MPVariableProto{} }
func (m *MPVariableProto) String() string { return proto.CompactTextString(m) }
func (*MPVariableProto) ProtoMessage()    {}
func (*MPVariableProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc74569f987c0a21, []int{0}
}

func (m *MPVariableProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MPVariableProto.Unmarshal(m, b)
}
func (m *MPVariableProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MPVariableProto.Marshal(b, m, deterministic)
}
func (m *MPVariableProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MPVariableProto.Merge(m, src)
}
func (m *MPVariableProto) XXX_Size() int {
	return xxx_messageInfo_MPVariableProto.Size(m)
}
func (m *MPVariableProto) XXX_DiscardUnknown() {
	xxx_messageInfo_MPVariableProto.DiscardUnknown(m)
}

var xxx_messageInfo_MPVariableProto proto.InternalMessageInfo

var Default_MPVariableProto_LowerBound float64 = math.Inf(-1)
var Default_MPVariableProto_UpperBound float64 = math.Inf(1)

const Default_MPVariableProto_ObjectiveCoefficient float64 = 0
const Default_MPVariableProto_IsInteger bool = false
const Default_MPVariableProto_BranchingPriority int32 = 0

func (m *MPVariableProto) GetLowerBound() float64 {
	if m != nil && m.LowerBound != nil {
		return *m.LowerBound
	}
	return Default_MPVariableProto_LowerBound
}

func (m *MPVariableProto) GetUpperBound() float64 {
	if m != nil && m.UpperBound != nil {
		return *m.UpperBound
	}
	return Default_MPVariableProto_UpperBound
}

func (m *MPVariableProto) GetObjectiveCoefficient() float64 {
	if m != nil && m.ObjectiveCoefficient != nil {
		return *m.ObjectiveCoefficient
	}
	return Default_MPVariableProto_ObjectiveCoefficient
}

func (m *MPVariableProto) GetIsInteger() bool {
	if m != nil && m.IsInteger != nil {
		return *m.IsInteger
	}
	return Default_MPVariableProto_IsInteger
}

func (m *MPVariableProto) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *MPVariableProto) GetBranchingPriority() int32 {
	if m != nil && m.BranchingPriority != nil {
		return *m.BranchingPriority
	}
	return Default_MPVariableProto_BranchingPriority
}

// A linear constraint is always of the form:
// lower_bound <= sum of linear term elements <= upper_bound,
// where lower_bound and upper_bound:
// - Can form a singleton: lower_bound == upper_bound. The constraint is an
//   equation.
// - Can form a finite interval [lower_bound, upper_bound]. The constraint is
//   both lower- and upper-bounded, i.e. "boxed".
// - Can form a semi-infinite interval. lower_bound = -infinity: the constraint
//   is upper-bounded. upper_bound = +infinity: the constraint is lower-bounded.
// - Can form the infinite interval: lower_bound = -infinity and
//   upper_bound = +infinity. The constraint is free.
type MPConstraintProto struct {
	// var_index[i] is the variable index (w.r.t. to "variable" field of
	// MPModelProto) of the i-th linear term involved in this constraint, and
	// coefficient[i] is its coefficient. Only the terms with non-zero
	// coefficients need to appear. var_index may not contain duplicates.
	VarIndex    []int32   `protobuf:"varint,6,rep,packed,name=var_index,json=varIndex" json:"var_index,omitempty"`
	Coefficient []float64 `protobuf:"fixed64,7,rep,packed,name=coefficient" json:"coefficient,omitempty"`
	// lower_bound must be <= upper_bound.
	LowerBound *float64 `protobuf:"fixed64,2,opt,name=lower_bound,json=lowerBound,def=-inf" json:"lower_bound,omitempty"`
	UpperBound *float64 `protobuf:"fixed64,3,opt,name=upper_bound,json=upperBound,def=inf" json:"upper_bound,omitempty"`
	// The name of the constraint.
	Name *string `protobuf:"bytes,4,opt,name=name,def=" json:"name,omitempty"`
	// [Advanced usage: do not use this if you don't know what you're doing.]
	// A lazy constraint is handled differently by the core solving engine, but
	// it does not change the result. It may or may not impact the performance.
	// For more info see: http://tinyurl.com/lazy-constraints.
	IsLazy               *bool    `protobuf:"varint,5,opt,name=is_lazy,json=isLazy,def=0" json:"is_lazy,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MPConstraintProto) Reset()         { *m = MPConstraintProto{} }
func (m *MPConstraintProto) String() string { return proto.CompactTextString(m) }
func (*MPConstraintProto) ProtoMessage()    {}
func (*MPConstraintProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc74569f987c0a21, []int{1}
}

func (m *MPConstraintProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MPConstraintProto.Unmarshal(m, b)
}
func (m *MPConstraintProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MPConstraintProto.Marshal(b, m, deterministic)
}
func (m *MPConstraintProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MPConstraintProto.Merge(m, src)
}
func (m *MPConstraintProto) XXX_Size() int {
	return xxx_messageInfo_MPConstraintProto.Size(m)
}
func (m *MPConstraintProto) XXX_DiscardUnknown() {
	xxx_messageInfo_MPConstraintProto.DiscardUnknown(m)
}

var xxx_messageInfo_MPConstraintProto proto.InternalMessageInfo

var Default_MPConstraintProto_LowerBound float64 = math.Inf(-1)
var Default_MPConstraintProto_UpperBound float64 = math.Inf(1)

const Default_MPConstraintProto_IsLazy bool = false

func (m *MPConstraintProto) GetVarIndex() []int32 {
	if m != nil {
		return m.VarIndex
	}
	return nil
}

func (m *MPConstraintProto) GetCoefficient() []float64 {
	if m != nil {
		return m.Coefficient
	}
	return nil
}

func (m *MPConstraintProto) GetLowerBound() float64 {
	if m != nil && m.LowerBound != nil {
		return *m.LowerBound
	}
	return Default_MPConstraintProto_LowerBound
}

func (m *MPConstraintProto) GetUpperBound() float64 {
	if m != nil && m.UpperBound != nil {
		return *m.UpperBound
	}
	return Default_MPConstraintProto_UpperBound
}

func (m *MPConstraintProto) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *MPConstraintProto) GetIsLazy() bool {
	if m != nil && m.IsLazy != nil {
		return *m.IsLazy
	}
	return Default_MPConstraintProto_IsLazy
}

// General constraints. See each individual proto type for more information.
type MPGeneralConstraintProto struct {
	// The name of the constraint.
	Name *string `protobuf:"bytes,1,opt,name=name,def=" json:"name,omitempty"`
	// Types that are valid to be assigned to GeneralConstraint:
	//	*MPGeneralConstraintProto_IndicatorConstraint
	//	*MPGeneralConstraintProto_SosConstraint
	//	*MPGeneralConstraintProto_QuadraticConstraint
	//	*MPGeneralConstraintProto_AbsConstraint
	//	*MPGeneralConstraintProto_AndConstraint
	//	*MPGeneralConstraintProto_OrConstraint
	//	*MPGeneralConstraintProto_MinConstraint
	//	*MPGeneralConstraintProto_MaxConstraint
	GeneralConstraint    isMPGeneralConstraintProto_GeneralConstraint `protobuf_oneof:"general_constraint"`
	XXX_NoUnkeyedLiteral struct{}                                     `json:"-"`
	XXX_unrecognized     []byte                                       `json:"-"`
	XXX_sizecache        int32                                        `json:"-"`
}

func (m *MPGeneralConstraintProto) Reset()         { *m = MPGeneralConstraintProto{} }
func (m *MPGeneralConstraintProto) String() string { return proto.CompactTextString(m) }
func (*MPGeneralConstraintProto) ProtoMessage()    {}
func (*MPGeneralConstraintProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc74569f987c0a21, []int{2}
}

func (m *MPGeneralConstraintProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MPGeneralConstraintProto.Unmarshal(m, b)
}
func (m *MPGeneralConstraintProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MPGeneralConstraintProto.Marshal(b, m, deterministic)
}
func (m *MPGeneralConstraintProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MPGeneralConstraintProto.Merge(m, src)
}
func (m *MPGeneralConstraintProto) XXX_Size() int {
	return xxx_messageInfo_MPGeneralConstraintProto.Size(m)
}
func (m *MPGeneralConstraintProto) XXX_DiscardUnknown() {
	xxx_messageInfo_MPGeneralConstraintProto.DiscardUnknown(m)
}

var xxx_messageInfo_MPGeneralConstraintProto proto.InternalMessageInfo

func (m *MPGeneralConstraintProto) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

type isMPGeneralConstraintProto_GeneralConstraint interface {
	isMPGeneralConstraintProto_GeneralConstraint()
}

type MPGeneralConstraintProto_IndicatorConstraint struct {
	IndicatorConstraint *MPIndicatorConstraint `protobuf:"bytes,2,opt,name=indicator_constraint,json=indicatorConstraint,oneof"`
}

type MPGeneralConstraintProto_SosConstraint struct {
	SosConstraint *MPSosConstraint `protobuf:"bytes,3,opt,name=sos_constraint,json=sosConstraint,oneof"`
}

type MPGeneralConstraintProto_QuadraticConstraint struct {
	QuadraticConstraint *MPQuadraticConstraint `protobuf:"bytes,4,opt,name=quadratic_constraint,json=quadraticConstraint,oneof"`
}

type MPGeneralConstraintProto_AbsConstraint struct {
	AbsConstraint *MPAbsConstraint `protobuf:"bytes,5,opt,name=abs_constraint,json=absConstraint,oneof"`
}

type MPGeneralConstraintProto_AndConstraint struct {
	AndConstraint *MPArrayConstraint `protobuf:"bytes,6,opt,name=and_constraint,json=andConstraint,oneof"`
}

type MPGeneralConstraintProto_OrConstraint struct {
	OrConstraint *MPArrayConstraint `protobuf:"bytes,7,opt,name=or_constraint,json=orConstraint,oneof"`
}

type MPGeneralConstraintProto_MinConstraint struct {
	MinConstraint *MPArrayWithConstantConstraint `protobuf:"bytes,8,opt,name=min_constraint,json=minConstraint,oneof"`
}

type MPGeneralConstraintProto_MaxConstraint struct {
	MaxConstraint *MPArrayWithConstantConstraint `protobuf:"bytes,9,opt,name=max_constraint,json=maxConstraint,oneof"`
}

func (*MPGeneralConstraintProto_IndicatorConstraint) isMPGeneralConstraintProto_GeneralConstraint() {}

func (*MPGeneralConstraintProto_SosConstraint) isMPGeneralConstraintProto_GeneralConstraint() {}

func (*MPGeneralConstraintProto_QuadraticConstraint) isMPGeneralConstraintProto_GeneralConstraint() {}

func (*MPGeneralConstraintProto_AbsConstraint) isMPGeneralConstraintProto_GeneralConstraint() {}

func (*MPGeneralConstraintProto_AndConstraint) isMPGeneralConstraintProto_GeneralConstraint() {}

func (*MPGeneralConstraintProto_OrConstraint) isMPGeneralConstraintProto_GeneralConstraint() {}

func (*MPGeneralConstraintProto_MinConstraint) isMPGeneralConstraintProto_GeneralConstraint() {}

func (*MPGeneralConstraintProto_MaxConstraint) isMPGeneralConstraintProto_GeneralConstraint() {}

func (m *MPGeneralConstraintProto) GetGeneralConstraint() isMPGeneralConstraintProto_GeneralConstraint {
	if m != nil {
		return m.GeneralConstraint
	}
	return nil
}

func (m *MPGeneralConstraintProto) GetIndicatorConstraint() *MPIndicatorConstraint {
	if x, ok := m.GetGeneralConstraint().(*MPGeneralConstraintProto_IndicatorConstraint); ok {
		return x.IndicatorConstraint
	}
	return nil
}

func (m *MPGeneralConstraintProto) GetSosConstraint() *MPSosConstraint {
	if x, ok := m.GetGeneralConstraint().(*MPGeneralConstraintProto_SosConstraint); ok {
		return x.SosConstraint
	}
	return nil
}

func (m *MPGeneralConstraintProto) GetQuadraticConstraint() *MPQuadraticConstraint {
	if x, ok := m.GetGeneralConstraint().(*MPGeneralConstraintProto_QuadraticConstraint); ok {
		return x.QuadraticConstraint
	}
	return nil
}

func (m *MPGeneralConstraintProto) GetAbsConstraint() *MPAbsConstraint {
	if x, ok := m.GetGeneralConstraint().(*MPGeneralConstraintProto_AbsConstraint); ok {
		return x.AbsConstraint
	}
	return nil
}

func (m *MPGeneralConstraintProto) GetAndConstraint() *MPArrayConstraint {
	if x, ok := m.GetGeneralConstraint().(*MPGeneralConstraintProto_AndConstraint); ok {
		return x.AndConstraint
	}
	return nil
}

func (m *MPGeneralConstraintProto) GetOrConstraint() *MPArrayConstraint {
	if x, ok := m.GetGeneralConstraint().(*MPGeneralConstraintProto_OrConstraint); ok {
		return x.OrConstraint
	}
	return nil
}

func (m *MPGeneralConstraintProto) GetMinConstraint() *MPArrayWithConstantConstraint {
	if x, ok := m.GetGeneralConstraint().(*MPGeneralConstraintProto_MinConstraint); ok {
		return x.MinConstraint
	}
	return nil
}

func (m *MPGeneralConstraintProto) GetMaxConstraint() *MPArrayWithConstantConstraint {
	if x, ok := m.GetGeneralConstraint().(*MPGeneralConstraintProto_MaxConstraint); ok {
		return x.MaxConstraint
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MPGeneralConstraintProto) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MPGeneralConstraintProto_IndicatorConstraint)(nil),
		(*MPGeneralConstraintProto_SosConstraint)(nil),
		(*MPGeneralConstraintProto_QuadraticConstraint)(nil),
		(*MPGeneralConstraintProto_AbsConstraint)(nil),
		(*MPGeneralConstraintProto_AndConstraint)(nil),
		(*MPGeneralConstraintProto_OrConstraint)(nil),
		(*MPGeneralConstraintProto_MinConstraint)(nil),
		(*MPGeneralConstraintProto_MaxConstraint)(nil),
	}
}

// Indicator constraints encode the activation or deactivation of linear
// constraints given the value of one Boolean variable in the model. For
// example:
//     y = 0 => 2 * x1 + 3 * x2 >= 42
// The 2 * x1 + 3 * x2 >= 42 constraint is only active if the variable y is
// equal to 0.
// As of 2019/04, only SCIP, CP-SAT and Gurobi support this constraint type.
type MPIndicatorConstraint struct {
	// Variable index (w.r.t. the "variable" field of MPModelProto) of the Boolean
	// variable used as indicator.
	VarIndex *int32 `protobuf:"varint,1,opt,name=var_index,json=varIndex" json:"var_index,omitempty"`
	// Value the above variable should take. Must be 0 or 1.
	VarValue *int32 `protobuf:"varint,2,opt,name=var_value,json=varValue" json:"var_value,omitempty"`
	// The constraint activated by the indicator variable.
	Constraint           *MPConstraintProto `protobuf:"bytes,3,opt,name=constraint" json:"constraint,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *MPIndicatorConstraint) Reset()         { *m = MPIndicatorConstraint{} }
func (m *MPIndicatorConstraint) String() string { return proto.CompactTextString(m) }
func (*MPIndicatorConstraint) ProtoMessage()    {}
func (*MPIndicatorConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc74569f987c0a21, []int{3}
}

func (m *MPIndicatorConstraint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MPIndicatorConstraint.Unmarshal(m, b)
}
func (m *MPIndicatorConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MPIndicatorConstraint.Marshal(b, m, deterministic)
}
func (m *MPIndicatorConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MPIndicatorConstraint.Merge(m, src)
}
func (m *MPIndicatorConstraint) XXX_Size() int {
	return xxx_messageInfo_MPIndicatorConstraint.Size(m)
}
func (m *MPIndicatorConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_MPIndicatorConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_MPIndicatorConstraint proto.InternalMessageInfo

func (m *MPIndicatorConstraint) GetVarIndex() int32 {
	if m != nil && m.VarIndex != nil {
		return *m.VarIndex
	}
	return 0
}

func (m *MPIndicatorConstraint) GetVarValue() int32 {
	if m != nil && m.VarValue != nil {
		return *m.VarValue
	}
	return 0
}

func (m *MPIndicatorConstraint) GetConstraint() *MPConstraintProto {
	if m != nil {
		return m.Constraint
	}
	return nil
}

// Special Ordered Set (SOS) constraints of type 1 or 2.
// See https://en.wikipedia.org/wiki/Special_ordered_set
// As of 2019/04, only SCIP and Gurobi support this constraint type.
type MPSosConstraint struct {
	Type *MPSosConstraint_Type `protobuf:"varint,1,opt,name=type,enum=operations_research.MPSosConstraint_Type,def=0" json:"type,omitempty"`
	// Variable index (w.r.t. the "variable" field of MPModelProto) of the
	// variables in the SOS.
	VarIndex []int32 `protobuf:"varint,2,rep,name=var_index,json=varIndex" json:"var_index,omitempty"`
	// Optional: SOS weights. If non-empty, must be of the same size as
	// "var_index", and strictly increasing. If empty and required by the
	// underlying solver, the 1..n sequence will be given as weights.
	// SUBTLE: The weights can help the solver make branch-and-bound decisions
	// that fit the underlying optimization model: after each LP relaxation, it
	// will compute the "average weight" of the SOS variables, weighted by value
	// (this is confusing: here we're using the values as weights), and the binary
	// branch decision will be: is the non-zero variable above or below that?
	// (weights are strictly monotonous, so the "cutoff" average weight
	// corresponds to a "cutoff" index in the var_index sequence).
	Weight               []float64 `protobuf:"fixed64,3,rep,name=weight" json:"weight,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *MPSosConstraint) Reset()         { *m = MPSosConstraint{} }
func (m *MPSosConstraint) String() string { return proto.CompactTextString(m) }
func (*MPSosConstraint) ProtoMessage()    {}
func (*MPSosConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc74569f987c0a21, []int{4}
}

func (m *MPSosConstraint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MPSosConstraint.Unmarshal(m, b)
}
func (m *MPSosConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MPSosConstraint.Marshal(b, m, deterministic)
}
func (m *MPSosConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MPSosConstraint.Merge(m, src)
}
func (m *MPSosConstraint) XXX_Size() int {
	return xxx_messageInfo_MPSosConstraint.Size(m)
}
func (m *MPSosConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_MPSosConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_MPSosConstraint proto.InternalMessageInfo

const Default_MPSosConstraint_Type MPSosConstraint_Type = MPSosConstraint_SOS1_DEFAULT

func (m *MPSosConstraint) GetType() MPSosConstraint_Type {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return Default_MPSosConstraint_Type
}

func (m *MPSosConstraint) GetVarIndex() []int32 {
	if m != nil {
		return m.VarIndex
	}
	return nil
}

func (m *MPSosConstraint) GetWeight() []float64 {
	if m != nil {
		return m.Weight
	}
	return nil
}

// Quadratic constraints of the form lb <= sum a_i x_i + sum b_ij x_i x_j <= ub,
// where a, b, lb and ub are constants, and x are the model's variables.
// Quadratic matrices that are Positive Semi-Definite, Second-Order Cones or
// rotated Second-Order Cones are always accepted. Other forms may or may not be
// accepted depending on the underlying solver used.
// See https://scip.zib.de/doc/html/cons__quadratic_8h.php and
// https://www.gurobi.com/documentation/8.1/refman/constraints.html#subsubsection:QuadraticConstraints
type MPQuadraticConstraint struct {
	// Sparse representation of linear terms in the quadratic constraint, where
	// term i is var_index[i] * coefficient[i].
	// `var_index` are variable indices w.r.t the "variable" field in
	// MPModelProto, and should be unique.
	VarIndex    []int32   `protobuf:"varint,1,rep,name=var_index,json=varIndex" json:"var_index,omitempty"`
	Coefficient []float64 `protobuf:"fixed64,2,rep,name=coefficient" json:"coefficient,omitempty"`
	// Sparse representation of quadratic terms in the quadratic constraint, where
	// term i is qvar1_index[i] * qvar2_index[i] * qcoefficient[i].
	// `qvar1_index` and `qvar2_index` are variable indices w.r.t the "variable"
	// field in MPModelProto.
	// `qvar1_index`, `qvar2_index` and `coefficients` must have the same size.
	// If the same unordered pair (qvar1_index, qvar2_index) appears several
	// times, the sum of all of the associated coefficients will be applied.
	Qvar1Index   []int32   `protobuf:"varint,3,rep,name=qvar1_index,json=qvar1Index" json:"qvar1_index,omitempty"`
	Qvar2Index   []int32   `protobuf:"varint,4,rep,name=qvar2_index,json=qvar2Index" json:"qvar2_index,omitempty"`
	Qcoefficient []float64 `protobuf:"fixed64,5,rep,name=qcoefficient" json:"qcoefficient,omitempty"`
	// lower_bound must be <= upper_bound.
	LowerBound           *float64 `protobuf:"fixed64,6,opt,name=lower_bound,json=lowerBound,def=-inf" json:"lower_bound,omitempty"`
	UpperBound           *float64 `protobuf:"fixed64,7,opt,name=upper_bound,json=upperBound,def=inf" json:"upper_bound,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MPQuadraticConstraint) Reset()         { *m = MPQuadraticConstraint{} }
func (m *MPQuadraticConstraint) String() string { return proto.CompactTextString(m) }
func (*MPQuadraticConstraint) ProtoMessage()    {}
func (*MPQuadraticConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc74569f987c0a21, []int{5}
}

func (m *MPQuadraticConstraint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MPQuadraticConstraint.Unmarshal(m, b)
}
func (m *MPQuadraticConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MPQuadraticConstraint.Marshal(b, m, deterministic)
}
func (m *MPQuadraticConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MPQuadraticConstraint.Merge(m, src)
}
func (m *MPQuadraticConstraint) XXX_Size() int {
	return xxx_messageInfo_MPQuadraticConstraint.Size(m)
}
func (m *MPQuadraticConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_MPQuadraticConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_MPQuadraticConstraint proto.InternalMessageInfo

var Default_MPQuadraticConstraint_LowerBound float64 = math.Inf(-1)
var Default_MPQuadraticConstraint_UpperBound float64 = math.Inf(1)

func (m *MPQuadraticConstraint) GetVarIndex() []int32 {
	if m != nil {
		return m.VarIndex
	}
	return nil
}

func (m *MPQuadraticConstraint) GetCoefficient() []float64 {
	if m != nil {
		return m.Coefficient
	}
	return nil
}

func (m *MPQuadraticConstraint) GetQvar1Index() []int32 {
	if m != nil {
		return m.Qvar1Index
	}
	return nil
}

func (m *MPQuadraticConstraint) GetQvar2Index() []int32 {
	if m != nil {
		return m.Qvar2Index
	}
	return nil
}

func (m *MPQuadraticConstraint) GetQcoefficient() []float64 {
	if m != nil {
		return m.Qcoefficient
	}
	return nil
}

func (m *MPQuadraticConstraint) GetLowerBound() float64 {
	if m != nil && m.LowerBound != nil {
		return *m.LowerBound
	}
	return Default_MPQuadraticConstraint_LowerBound
}

func (m *MPQuadraticConstraint) GetUpperBound() float64 {
	if m != nil && m.UpperBound != nil {
		return *m.UpperBound
	}
	return Default_MPQuadraticConstraint_UpperBound
}

// Sets a variable's value to the absolute value of another variable.
type MPAbsConstraint struct {
	// Variable indices are relative to the "variable" field in MPModelProto.
	// resultant_var = abs(var)
	VarIndex             *int32   `protobuf:"varint,1,opt,name=var_index,json=varIndex" json:"var_index,omitempty"`
	ResultantVarIndex    *int32   `protobuf:"varint,2,opt,name=resultant_var_index,json=resultantVarIndex" json:"resultant_var_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MPAbsConstraint) Reset()         { *m = MPAbsConstraint{} }
func (m *MPAbsConstraint) String() string { return proto.CompactTextString(m) }
func (*MPAbsConstraint) ProtoMessage()    {}
func (*MPAbsConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc74569f987c0a21, []int{6}
}

func (m *MPAbsConstraint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MPAbsConstraint.Unmarshal(m, b)
}
func (m *MPAbsConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MPAbsConstraint.Marshal(b, m, deterministic)
}
func (m *MPAbsConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MPAbsConstraint.Merge(m, src)
}
func (m *MPAbsConstraint) XXX_Size() int {
	return xxx_messageInfo_MPAbsConstraint.Size(m)
}
func (m *MPAbsConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_MPAbsConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_MPAbsConstraint proto.InternalMessageInfo

func (m *MPAbsConstraint) GetVarIndex() int32 {
	if m != nil && m.VarIndex != nil {
		return *m.VarIndex
	}
	return 0
}

func (m *MPAbsConstraint) GetResultantVarIndex() int32 {
	if m != nil && m.ResultantVarIndex != nil {
		return *m.ResultantVarIndex
	}
	return 0
}

// Sets a variable's value equal to a function on a set of variables.
type MPArrayConstraint struct {
	// Variable indices are relative to the "variable" field in MPModelProto.
	VarIndex             []int32  `protobuf:"varint,1,rep,name=var_index,json=varIndex" json:"var_index,omitempty"`
	ResultantVarIndex    *int32   `protobuf:"varint,2,opt,name=resultant_var_index,json=resultantVarIndex" json:"resultant_var_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MPArrayConstraint) Reset()         { *m = MPArrayConstraint{} }
func (m *MPArrayConstraint) String() string { return proto.CompactTextString(m) }
func (*MPArrayConstraint) ProtoMessage()    {}
func (*MPArrayConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc74569f987c0a21, []int{7}
}

func (m *MPArrayConstraint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MPArrayConstraint.Unmarshal(m, b)
}
func (m *MPArrayConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MPArrayConstraint.Marshal(b, m, deterministic)
}
func (m *MPArrayConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MPArrayConstraint.Merge(m, src)
}
func (m *MPArrayConstraint) XXX_Size() int {
	return xxx_messageInfo_MPArrayConstraint.Size(m)
}
func (m *MPArrayConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_MPArrayConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_MPArrayConstraint proto.InternalMessageInfo

func (m *MPArrayConstraint) GetVarIndex() []int32 {
	if m != nil {
		return m.VarIndex
	}
	return nil
}

func (m *MPArrayConstraint) GetResultantVarIndex() int32 {
	if m != nil && m.ResultantVarIndex != nil {
		return *m.ResultantVarIndex
	}
	return 0
}

// Sets a variable's value equal to a function on a set of variables and,
// optionally, a constant.
type MPArrayWithConstantConstraint struct {
	// Variable indices are relative to the "variable" field in MPModelProto.
	// resultant_var = f(var_1, var_2, ..., constant)
	VarIndex             []int32  `protobuf:"varint,1,rep,name=var_index,json=varIndex" json:"var_index,omitempty"`
	Constant             *float64 `protobuf:"fixed64,2,opt,name=constant" json:"constant,omitempty"`
	ResultantVarIndex    *int32   `protobuf:"varint,3,opt,name=resultant_var_index,json=resultantVarIndex" json:"resultant_var_index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MPArrayWithConstantConstraint) Reset()         { *m = MPArrayWithConstantConstraint{} }
func (m *MPArrayWithConstantConstraint) String() string { return proto.CompactTextString(m) }
func (*MPArrayWithConstantConstraint) ProtoMessage()    {}
func (*MPArrayWithConstantConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc74569f987c0a21, []int{8}
}

func (m *MPArrayWithConstantConstraint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MPArrayWithConstantConstraint.Unmarshal(m, b)
}
func (m *MPArrayWithConstantConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MPArrayWithConstantConstraint.Marshal(b, m, deterministic)
}
func (m *MPArrayWithConstantConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MPArrayWithConstantConstraint.Merge(m, src)
}
func (m *MPArrayWithConstantConstraint) XXX_Size() int {
	return xxx_messageInfo_MPArrayWithConstantConstraint.Size(m)
}
func (m *MPArrayWithConstantConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_MPArrayWithConstantConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_MPArrayWithConstantConstraint proto.InternalMessageInfo

func (m *MPArrayWithConstantConstraint) GetVarIndex() []int32 {
	if m != nil {
		return m.VarIndex
	}
	return nil
}

func (m *MPArrayWithConstantConstraint) GetConstant() float64 {
	if m != nil && m.Constant != nil {
		return *m.Constant
	}
	return 0
}

func (m *MPArrayWithConstantConstraint) GetResultantVarIndex() int32 {
	if m != nil && m.ResultantVarIndex != nil {
		return *m.ResultantVarIndex
	}
	return 0
}

// Quadratic part of a model's objective. Added with other objectives (such as
// linear), this creates the model's objective function to be optimized.
// Note: the linear part of the objective currently needs to be specified in the
// MPVariableProto.objective_coefficient fields. If you'd rather have a
// dedicated linear array here, talk to or-core-team@
type MPQuadraticObjective struct {
	// Sparse representation of quadratic terms in the objective function, where
	// term i is qvar1_index[i] * qvar2_index[i] * coefficient[i].
	// `qvar1_index` and `qvar2_index` are variable indices w.r.t the "variable"
	// field in MPModelProto.
	// `qvar1_index`, `qvar2_index` and `coefficients` must have the same size.
	// If the same unordered pair (qvar1_index, qvar2_index) appears several
	// times, the sum of all of the associated coefficients will be applied.
	Qvar1Index           []int32   `protobuf:"varint,1,rep,name=qvar1_index,json=qvar1Index" json:"qvar1_index,omitempty"`
	Qvar2Index           []int32   `protobuf:"varint,2,rep,name=qvar2_index,json=qvar2Index" json:"qvar2_index,omitempty"`
	Coefficient          []float64 `protobuf:"fixed64,3,rep,name=coefficient" json:"coefficient,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *MPQuadraticObjective) Reset()         { *m = MPQuadraticObjective{} }
func (m *MPQuadraticObjective) String() string { return proto.CompactTextString(m) }
func (*MPQuadraticObjective) ProtoMessage()    {}
func (*MPQuadraticObjective) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc74569f987c0a21, []int{9}
}

func (m *MPQuadraticObjective) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MPQuadraticObjective.Unmarshal(m, b)
}
func (m *MPQuadraticObjective) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MPQuadraticObjective.Marshal(b, m, deterministic)
}
func (m *MPQuadraticObjective) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MPQuadraticObjective.Merge(m, src)
}
func (m *MPQuadraticObjective) XXX_Size() int {
	return xxx_messageInfo_MPQuadraticObjective.Size(m)
}
func (m *MPQuadraticObjective) XXX_DiscardUnknown() {
	xxx_messageInfo_MPQuadraticObjective.DiscardUnknown(m)
}

var xxx_messageInfo_MPQuadraticObjective proto.InternalMessageInfo

func (m *MPQuadraticObjective) GetQvar1Index() []int32 {
	if m != nil {
		return m.Qvar1Index
	}
	return nil
}

func (m *MPQuadraticObjective) GetQvar2Index() []int32 {
	if m != nil {
		return m.Qvar2Index
	}
	return nil
}

func (m *MPQuadraticObjective) GetCoefficient() []float64 {
	if m != nil {
		return m.Coefficient
	}
	return nil
}

// This message encodes a partial (or full) assignment of the variables of a
// MPModelProto problem. The indices in var_index should be unique and valid
// variable indices of the associated problem.
type PartialVariableAssignment struct {
	VarIndex             []int32   `protobuf:"varint,1,rep,packed,name=var_index,json=varIndex" json:"var_index,omitempty"`
	VarValue             []float64 `protobuf:"fixed64,2,rep,packed,name=var_value,json=varValue" json:"var_value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *PartialVariableAssignment) Reset()         { *m = PartialVariableAssignment{} }
func (m *PartialVariableAssignment) String() string { return proto.CompactTextString(m) }
func (*PartialVariableAssignment) ProtoMessage()    {}
func (*PartialVariableAssignment) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc74569f987c0a21, []int{10}
}

func (m *PartialVariableAssignment) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PartialVariableAssignment.Unmarshal(m, b)
}
func (m *PartialVariableAssignment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PartialVariableAssignment.Marshal(b, m, deterministic)
}
func (m *PartialVariableAssignment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartialVariableAssignment.Merge(m, src)
}
func (m *PartialVariableAssignment) XXX_Size() int {
	return xxx_messageInfo_PartialVariableAssignment.Size(m)
}
func (m *PartialVariableAssignment) XXX_DiscardUnknown() {
	xxx_messageInfo_PartialVariableAssignment.DiscardUnknown(m)
}

var xxx_messageInfo_PartialVariableAssignment proto.InternalMessageInfo

func (m *PartialVariableAssignment) GetVarIndex() []int32 {
	if m != nil {
		return m.VarIndex
	}
	return nil
}

func (m *PartialVariableAssignment) GetVarValue() []float64 {
	if m != nil {
		return m.VarValue
	}
	return nil
}

// MPModelProto contains all the information for a Linear Programming model.
type MPModelProto struct {
	// All the variables appearing in the model.
	Variable []*MPVariableProto `protobuf:"bytes,3,rep,name=variable" json:"variable,omitempty"`
	// All the constraints appearing in the model.
	Constraint []*MPConstraintProto `protobuf:"bytes,4,rep,name=constraint" json:"constraint,omitempty"`
	// All the general constraints appearing in the model. Note that not all
	// solvers support all types of general constraints.
	GeneralConstraint []*MPGeneralConstraintProto `protobuf:"bytes,7,rep,name=general_constraint,json=generalConstraint" json:"general_constraint,omitempty"`
	// True if the problem is a maximization problem. Minimize by default.
	Maximize *bool `protobuf:"varint,1,opt,name=maximize,def=0" json:"maximize,omitempty"`
	// Offset for the objective function. Must be finite.
	ObjectiveOffset *float64 `protobuf:"fixed64,2,opt,name=objective_offset,json=objectiveOffset,def=0" json:"objective_offset,omitempty"`
	// Optionally, a quadratic objective.
	// As of 2019/06, only SCIP and Gurobi support quadratic objectives.
	QuadraticObjective *MPQuadraticObjective `protobuf:"bytes,8,opt,name=quadratic_objective,json=quadraticObjective" json:"quadratic_objective,omitempty"`
	// Name of the model.
	Name *string `protobuf:"bytes,5,opt,name=name,def=" json:"name,omitempty"`
	// Solution hint.
	//
	// If a feasible or almost-feasible solution to the problem is already known,
	// it may be helpful to pass it to the solver so that it can be used. A solver
	// that supports this feature will try to use this information to create its
	// initial feasible solution.
	//
	// Note that it may not always be faster to give a hint like this to the
	// solver. There is also no guarantee that the solver will use this hint or
	// try to return a solution "close" to this assignment in case of multiple
	// optimal solutions.
	SolutionHint         *PartialVariableAssignment `protobuf:"bytes,6,opt,name=solution_hint,json=solutionHint" json:"solution_hint,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *MPModelProto) Reset()         { *m = MPModelProto{} }
func (m *MPModelProto) String() string { return proto.CompactTextString(m) }
func (*MPModelProto) ProtoMessage()    {}
func (*MPModelProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc74569f987c0a21, []int{11}
}

func (m *MPModelProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MPModelProto.Unmarshal(m, b)
}
func (m *MPModelProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MPModelProto.Marshal(b, m, deterministic)
}
func (m *MPModelProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MPModelProto.Merge(m, src)
}
func (m *MPModelProto) XXX_Size() int {
	return xxx_messageInfo_MPModelProto.Size(m)
}
func (m *MPModelProto) XXX_DiscardUnknown() {
	xxx_messageInfo_MPModelProto.DiscardUnknown(m)
}

var xxx_messageInfo_MPModelProto proto.InternalMessageInfo

const Default_MPModelProto_Maximize bool = false
const Default_MPModelProto_ObjectiveOffset float64 = 0

func (m *MPModelProto) GetVariable() []*MPVariableProto {
	if m != nil {
		return m.Variable
	}
	return nil
}

func (m *MPModelProto) GetConstraint() []*MPConstraintProto {
	if m != nil {
		return m.Constraint
	}
	return nil
}

func (m *MPModelProto) GetGeneralConstraint() []*MPGeneralConstraintProto {
	if m != nil {
		return m.GeneralConstraint
	}
	return nil
}

func (m *MPModelProto) GetMaximize() bool {
	if m != nil && m.Maximize != nil {
		return *m.Maximize
	}
	return Default_MPModelProto_Maximize
}

func (m *MPModelProto) GetObjectiveOffset() float64 {
	if m != nil && m.ObjectiveOffset != nil {
		return *m.ObjectiveOffset
	}
	return Default_MPModelProto_ObjectiveOffset
}

func (m *MPModelProto) GetQuadraticObjective() *MPQuadraticObjective {
	if m != nil {
		return m.QuadraticObjective
	}
	return nil
}

func (m *MPModelProto) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *MPModelProto) GetSolutionHint() *PartialVariableAssignment {
	if m != nil {
		return m.SolutionHint
	}
	return nil
}

// To support 'unspecified' double value in proto3, the simplest is to wrap
// any double value in a nested message (has_XXX works for message fields).
// We don't use google/protobuf/wrappers.proto because depending on it makes
// the following android integration test fail:
// http://sponge/c4bce1fd-41bd-4d0b-b4ca-fc04d4d64621
type OptionalDouble struct {
	Value                *float64 `protobuf:"fixed64,1,opt,name=value" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OptionalDouble) Reset()         { *m = OptionalDouble{} }
func (m *OptionalDouble) String() string { return proto.CompactTextString(m) }
func (*OptionalDouble) ProtoMessage()    {}
func (*OptionalDouble) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc74569f987c0a21, []int{12}
}

func (m *OptionalDouble) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OptionalDouble.Unmarshal(m, b)
}
func (m *OptionalDouble) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OptionalDouble.Marshal(b, m, deterministic)
}
func (m *OptionalDouble) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OptionalDouble.Merge(m, src)
}
func (m *OptionalDouble) XXX_Size() int {
	return xxx_messageInfo_OptionalDouble.Size(m)
}
func (m *OptionalDouble) XXX_DiscardUnknown() {
	xxx_messageInfo_OptionalDouble.DiscardUnknown(m)
}

var xxx_messageInfo_OptionalDouble proto.InternalMessageInfo

func (m *OptionalDouble) GetValue() float64 {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return 0
}

// MPSolverCommonParameters holds advanced usage parameters that apply to any of
// the solvers we support.
// All of the fields in this proto can have a value of unspecified. In this
// case each inner solver will use their own safe defaults.
// Some values won't be supported by some solvers. The behavior in that case is
// not defined yet.
type MPSolverCommonParameters struct {
	// The solver stops if the relative MIP gap reaches this value or below.
	// The relative MIP gap is an upper bound of the relative distance to the
	// optimum, and it is defined as:
	//
	//   abs(best_bound - incumbent) / abs(incumbent) [Gurobi]
	//   abs(best_bound - incumbent) / min(abs(best_bound), abs(incumbent)) [SCIP]
	//
	// where "incumbent" is the objective value of the best solution found so far
	// (i.e., lowest when minimizing, highest when maximizing), and "best_bound"
	// is the tightest bound of the objective determined so far (i.e., highest
	// when minimizing, and lowest when maximizing). The MIP Gap is sensitive to
	// objective offset. If the denominator is 0 the MIP Gap is INFINITY for SCIP
	// and Gurobi. Of note, "incumbent" and "best bound" are called "primal bound"
	// and "dual bound" in SCIP, respectively.
	// Ask or-core-team@ for other solvers.
	RelativeMipGap *OptionalDouble `protobuf:"bytes,1,opt,name=relative_mip_gap,json=relativeMipGap" json:"relative_mip_gap,omitempty"`
	// Tolerance for primal feasibility of basic solutions: this is the maximum
	// allowed error in constraint satisfiability.
	// For SCIP this includes integrality constraints. For Gurobi it does not, you
	// need to set the custom parameter IntFeasTol.
	PrimalTolerance *OptionalDouble `protobuf:"bytes,2,opt,name=primal_tolerance,json=primalTolerance" json:"primal_tolerance,omitempty"`
	// Tolerance for dual feasibility.
	// For SCIP and Gurobi this is the feasibility tolerance for reduced costs in
	// LP solution: reduced costs must all be smaller than this value in the
	// improving direction in order for a model to be declared optimal.
	// Not supported for other solvers.
	DualTolerance *OptionalDouble `protobuf:"bytes,3,opt,name=dual_tolerance,json=dualTolerance" json:"dual_tolerance,omitempty"`
	// Algorithm to solve linear programs.
	// Ask or-core-team@ if you want to know what this does exactly.
	LpAlgorithm *MPSolverCommonParameters_LPAlgorithmValues `protobuf:"varint,4,opt,name=lp_algorithm,json=lpAlgorithm,enum=operations_research.MPSolverCommonParameters_LPAlgorithmValues,def=0" json:"lp_algorithm,omitempty"`
	// Gurobi and SCIP enable presolve by default.
	// Ask or-core-team@ for other solvers.
	Presolve *gen.OptionalBoolean `protobuf:"varint,5,opt,name=presolve,enum=operations_research.OptionalBoolean,def=0" json:"presolve,omitempty"`
	// Enable automatic scaling of matrix coefficients and objective. Available
	// for Gurobi and GLOP.
	// Ask or-core-team@ if you want more details.
	Scaling              *gen.OptionalBoolean `protobuf:"varint,7,opt,name=scaling,enum=operations_research.OptionalBoolean,def=0" json:"scaling,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *MPSolverCommonParameters) Reset()         { *m = MPSolverCommonParameters{} }
func (m *MPSolverCommonParameters) String() string { return proto.CompactTextString(m) }
func (*MPSolverCommonParameters) ProtoMessage()    {}
func (*MPSolverCommonParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc74569f987c0a21, []int{13}
}

func (m *MPSolverCommonParameters) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MPSolverCommonParameters.Unmarshal(m, b)
}
func (m *MPSolverCommonParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MPSolverCommonParameters.Marshal(b, m, deterministic)
}
func (m *MPSolverCommonParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MPSolverCommonParameters.Merge(m, src)
}
func (m *MPSolverCommonParameters) XXX_Size() int {
	return xxx_messageInfo_MPSolverCommonParameters.Size(m)
}
func (m *MPSolverCommonParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_MPSolverCommonParameters.DiscardUnknown(m)
}

var xxx_messageInfo_MPSolverCommonParameters proto.InternalMessageInfo

const Default_MPSolverCommonParameters_LpAlgorithm MPSolverCommonParameters_LPAlgorithmValues = MPSolverCommonParameters_LP_ALGO_UNSPECIFIED
const Default_MPSolverCommonParameters_Presolve gen.OptionalBoolean = gen.OptionalBoolean_BOOL_UNSPECIFIED
const Default_MPSolverCommonParameters_Scaling gen.OptionalBoolean = gen.OptionalBoolean_BOOL_UNSPECIFIED

func (m *MPSolverCommonParameters) GetRelativeMipGap() *OptionalDouble {
	if m != nil {
		return m.RelativeMipGap
	}
	return nil
}

func (m *MPSolverCommonParameters) GetPrimalTolerance() *OptionalDouble {
	if m != nil {
		return m.PrimalTolerance
	}
	return nil
}

func (m *MPSolverCommonParameters) GetDualTolerance() *OptionalDouble {
	if m != nil {
		return m.DualTolerance
	}
	return nil
}

func (m *MPSolverCommonParameters) GetLpAlgorithm() MPSolverCommonParameters_LPAlgorithmValues {
	if m != nil && m.LpAlgorithm != nil {
		return *m.LpAlgorithm
	}
	return Default_MPSolverCommonParameters_LpAlgorithm
}

func (m *MPSolverCommonParameters) GetPresolve() gen.OptionalBoolean {
	if m != nil && m.Presolve != nil {
		return *m.Presolve
	}
	return Default_MPSolverCommonParameters_Presolve
}

func (m *MPSolverCommonParameters) GetScaling() gen.OptionalBoolean {
	if m != nil && m.Scaling != nil {
		return *m.Scaling
	}
	return Default_MPSolverCommonParameters_Scaling
}

// Encodes a full MPModelProto by way of referencing to a "baseline"
// MPModelProto stored in a file, and a "delta" to apply to this model.
type MPModelDeltaProto struct {
	BaselineModelFilePath *string `protobuf:"bytes,1,opt,name=baseline_model_file_path,json=baselineModelFilePath" json:"baseline_model_file_path,omitempty"`
	// The variable protos listed here will override (via MergeFrom()) the ones
	// in the baseline model: you only need to specify the fields that change.
	// To add a new variable, add it with a new variable index (variable indices
	// still need to span a dense integer interval).
	// You can't "delete" a variable but you can "neutralize" it by fixing its
	// value, setting its objective coefficient to zero, and by nullifying all
	// the terms involving it in the constraints.
	VariableOverrides map[int32]*MPVariableProto `protobuf:"bytes,2,rep,name=variable_overrides,json=variableOverrides" json:"variable_overrides,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Constraints can be changed (or added) in the same way as variables, see
	// above. It's mostly like applying MergeFrom(), except that:
	// - the "var_index" and "coefficient" fields will be overridden like a map:
	//   if a key pre-exists, we overwrite its value, otherwise we add it.
	// - if you set the lower bound to -inf and the upper bound to +inf, thus
	//   effectively neutralizing the constraint, the solver will implicitly
	//   remove all of the constraint's terms.
	ConstraintOverrides  map[int32]*MPConstraintProto `protobuf:"bytes,3,rep,name=constraint_overrides,json=constraintOverrides" json:"constraint_overrides,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *MPModelDeltaProto) Reset()         { *m = MPModelDeltaProto{} }
func (m *MPModelDeltaProto) String() string { return proto.CompactTextString(m) }
func (*MPModelDeltaProto) ProtoMessage()    {}
func (*MPModelDeltaProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc74569f987c0a21, []int{14}
}

func (m *MPModelDeltaProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MPModelDeltaProto.Unmarshal(m, b)
}
func (m *MPModelDeltaProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MPModelDeltaProto.Marshal(b, m, deterministic)
}
func (m *MPModelDeltaProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MPModelDeltaProto.Merge(m, src)
}
func (m *MPModelDeltaProto) XXX_Size() int {
	return xxx_messageInfo_MPModelDeltaProto.Size(m)
}
func (m *MPModelDeltaProto) XXX_DiscardUnknown() {
	xxx_messageInfo_MPModelDeltaProto.DiscardUnknown(m)
}

var xxx_messageInfo_MPModelDeltaProto proto.InternalMessageInfo

func (m *MPModelDeltaProto) GetBaselineModelFilePath() string {
	if m != nil && m.BaselineModelFilePath != nil {
		return *m.BaselineModelFilePath
	}
	return ""
}

func (m *MPModelDeltaProto) GetVariableOverrides() map[int32]*MPVariableProto {
	if m != nil {
		return m.VariableOverrides
	}
	return nil
}

func (m *MPModelDeltaProto) GetConstraintOverrides() map[int32]*MPConstraintProto {
	if m != nil {
		return m.ConstraintOverrides
	}
	return nil
}

// Next id: 9.
type MPModelRequest struct {
	// The model to be optimized by the server.
	Model      *MPModelProto              `protobuf:"bytes,1,opt,name=model" json:"model,omitempty"`
	SolverType *MPModelRequest_SolverType `protobuf:"varint,2,opt,name=solver_type,json=solverType,enum=operations_research.MPModelRequest_SolverType" json:"solver_type,omitempty"`
	// Maximum time to be spent by the solver to solve 'model'. If the server is
	// busy and the RPC's deadline_left is less than this, it will immediately
	// give up and return an error, without even trying to solve.
	//
	// The client can use this to have a guarantee on how much time the
	// solver will spend on the problem (unless it finds and proves
	// an optimal solution more quickly).
	//
	// If not specified, the time limit on the solver is the RPC's deadline_left.
	SolverTimeLimitSeconds *float64 `protobuf:"fixed64,3,opt,name=solver_time_limit_seconds,json=solverTimeLimitSeconds" json:"solver_time_limit_seconds,omitempty"`
	// If this is set, then EnableOutput() will be set on the internal MPSolver
	// that solves the model.
	// WARNING: if you set this on a request to prod servers, it will be rejected
	// and yield the RPC Application Error code MPSOLVER_SOLVER_TYPE_UNAVAILABLE.
	EnableInternalSolverOutput *bool `protobuf:"varint,4,opt,name=enable_internal_solver_output,json=enableInternalSolverOutput,def=0" json:"enable_internal_solver_output,omitempty"`
	// Advanced usage. Solver-specific parameters in the solver's own format,
	// different for each solver. For example, if you use SCIP and you want to
	// stop the solve earlier than the time limit if it reached a solution that is
	// at most 1% away from the optimal, you can set this to "limits/gap=0.01".
	//
	// Note however that there is no "security" mechanism in place so it is up to
	// the client to make sure that the given options don't make the solve
	// non thread safe or use up too much memory for instance.
	//
	// If the option format is not understood by the solver, the request will be
	// rejected and yield an RPC Application error with code
	// MPSOLVER_MODEL_INVALID_SOLVER_PARAMETERS.
	SolverSpecificParameters *string `protobuf:"bytes,5,opt,name=solver_specific_parameters,json=solverSpecificParameters" json:"solver_specific_parameters,omitempty"`
	// Advanced usage: model "delta". If used, "model" must be unset. See the
	// definition of MPModelDeltaProto.
	ModelDelta           *MPModelDeltaProto `protobuf:"bytes,8,opt,name=model_delta,json=modelDelta" json:"model_delta,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *MPModelRequest) Reset()         { *m = MPModelRequest{} }
func (m *MPModelRequest) String() string { return proto.CompactTextString(m) }
func (*MPModelRequest) ProtoMessage()    {}
func (*MPModelRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc74569f987c0a21, []int{15}
}

func (m *MPModelRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MPModelRequest.Unmarshal(m, b)
}
func (m *MPModelRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MPModelRequest.Marshal(b, m, deterministic)
}
func (m *MPModelRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MPModelRequest.Merge(m, src)
}
func (m *MPModelRequest) XXX_Size() int {
	return xxx_messageInfo_MPModelRequest.Size(m)
}
func (m *MPModelRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MPModelRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MPModelRequest proto.InternalMessageInfo

const Default_MPModelRequest_EnableInternalSolverOutput bool = false

func (m *MPModelRequest) GetModel() *MPModelProto {
	if m != nil {
		return m.Model
	}
	return nil
}

func (m *MPModelRequest) GetSolverType() MPModelRequest_SolverType {
	if m != nil && m.SolverType != nil {
		return *m.SolverType
	}
	return MPModelRequest_GLOP_LINEAR_PROGRAMMING
}

func (m *MPModelRequest) GetSolverTimeLimitSeconds() float64 {
	if m != nil && m.SolverTimeLimitSeconds != nil {
		return *m.SolverTimeLimitSeconds
	}
	return 0
}

func (m *MPModelRequest) GetEnableInternalSolverOutput() bool {
	if m != nil && m.EnableInternalSolverOutput != nil {
		return *m.EnableInternalSolverOutput
	}
	return Default_MPModelRequest_EnableInternalSolverOutput
}

func (m *MPModelRequest) GetSolverSpecificParameters() string {
	if m != nil && m.SolverSpecificParameters != nil {
		return *m.SolverSpecificParameters
	}
	return ""
}

func (m *MPModelRequest) GetModelDelta() *MPModelDeltaProto {
	if m != nil {
		return m.ModelDelta
	}
	return nil
}

type MPSolutionResponse struct {
	// Result of the optimization.
	Status *MPSolverResponseStatus `protobuf:"varint,1,opt,name=status,enum=operations_research.MPSolverResponseStatus,def=99" json:"status,omitempty"`
	// Human-readable string giving more details about the status. For example,
	// when the status is MPSOLVER_INVALID_MODE, this can hold a description of
	// why the model is invalid.
	// This isn't always filled: don't depend on its value or even its presence.
	StatusStr *string `protobuf:"bytes,7,opt,name=status_str,json=statusStr" json:"status_str,omitempty"`
	// Objective value corresponding to the "variable_value" below, taking into
	// account the source "objective_offset" and "objective_coefficient".
	// This is set iff 'status' is OPTIMAL or FEASIBLE.
	ObjectiveValue *float64 `protobuf:"fixed64,2,opt,name=objective_value,json=objectiveValue" json:"objective_value,omitempty"`
	// This field is only filled for MIP problems. For a minimization problem,
	// this is a lower bound on the optimal objective value. For a maximization
	// problem, it is an upper bound. It is only filled if the status is OPTIMAL
	// or FEASIBLE. In the former case, best_objective_bound should be equal to
	// objective_value (modulo numerical errors).
	BestObjectiveBound *float64 `protobuf:"fixed64,5,opt,name=best_objective_bound,json=bestObjectiveBound" json:"best_objective_bound,omitempty"`
	// Variable values in the same order as the MPModelProto::variable field.
	// This is a dense representation. These are set iff 'status' is OPTIMAL or
	// FEASIBLE.
	VariableValue []float64 `protobuf:"fixed64,3,rep,packed,name=variable_value,json=variableValue" json:"variable_value,omitempty"`
	// [Advanced usage.]
	// Values of the dual variables values in the same order as the
	// MPModelProto::constraint field. This is a dense representation.
	// These are not set if the problem was solved with a MIP solver (even if
	// it is actually a linear program).
	// These are set iff 'status' is OPTIMAL or FEASIBLE.
	DualValue []float64 `protobuf:"fixed64,4,rep,packed,name=dual_value,json=dualValue" json:"dual_value,omitempty"`
	// [Advanced usage.]
	// Values of the reduced cost of the variables in the same order as the
	// MPModelProto::variable. This is a dense representation.
	// These are not set if the problem was solved with a MIP solver (even if it
	// is actually a linear program).
	// These are set iff 'status' is OPTIMAL or FEASIBLE.
	ReducedCost          []float64 `protobuf:"fixed64,6,rep,packed,name=reduced_cost,json=reducedCost" json:"reduced_cost,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *MPSolutionResponse) Reset()         { *m = MPSolutionResponse{} }
func (m *MPSolutionResponse) String() string { return proto.CompactTextString(m) }
func (*MPSolutionResponse) ProtoMessage()    {}
func (*MPSolutionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dc74569f987c0a21, []int{16}
}

func (m *MPSolutionResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MPSolutionResponse.Unmarshal(m, b)
}
func (m *MPSolutionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MPSolutionResponse.Marshal(b, m, deterministic)
}
func (m *MPSolutionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MPSolutionResponse.Merge(m, src)
}
func (m *MPSolutionResponse) XXX_Size() int {
	return xxx_messageInfo_MPSolutionResponse.Size(m)
}
func (m *MPSolutionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MPSolutionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MPSolutionResponse proto.InternalMessageInfo

const Default_MPSolutionResponse_Status MPSolverResponseStatus = MPSolverResponseStatus_MPSOLVER_UNKNOWN_STATUS

func (m *MPSolutionResponse) GetStatus() MPSolverResponseStatus {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return Default_MPSolutionResponse_Status
}

func (m *MPSolutionResponse) GetStatusStr() string {
	if m != nil && m.StatusStr != nil {
		return *m.StatusStr
	}
	return ""
}

func (m *MPSolutionResponse) GetObjectiveValue() float64 {
	if m != nil && m.ObjectiveValue != nil {
		return *m.ObjectiveValue
	}
	return 0
}

func (m *MPSolutionResponse) GetBestObjectiveBound() float64 {
	if m != nil && m.BestObjectiveBound != nil {
		return *m.BestObjectiveBound
	}
	return 0
}

func (m *MPSolutionResponse) GetVariableValue() []float64 {
	if m != nil {
		return m.VariableValue
	}
	return nil
}

func (m *MPSolutionResponse) GetDualValue() []float64 {
	if m != nil {
		return m.DualValue
	}
	return nil
}

func (m *MPSolutionResponse) GetReducedCost() []float64 {
	if m != nil {
		return m.ReducedCost
	}
	return nil
}

func init() {
	proto.RegisterEnum("operations_research.MPSolverResponseStatus", MPSolverResponseStatus_name, MPSolverResponseStatus_value)
	proto.RegisterEnum("operations_research.MPSosConstraint_Type", MPSosConstraint_Type_name, MPSosConstraint_Type_value)
	proto.RegisterEnum("operations_research.MPSolverCommonParameters_LPAlgorithmValues", MPSolverCommonParameters_LPAlgorithmValues_name, MPSolverCommonParameters_LPAlgorithmValues_value)
	proto.RegisterEnum("operations_research.MPModelRequest_SolverType", MPModelRequest_SolverType_name, MPModelRequest_SolverType_value)
	proto.RegisterType((*MPVariableProto)(nil), "operations_research.MPVariableProto")
	proto.RegisterType((*MPConstraintProto)(nil), "operations_research.MPConstraintProto")
	proto.RegisterType((*MPGeneralConstraintProto)(nil), "operations_research.MPGeneralConstraintProto")
	proto.RegisterType((*MPIndicatorConstraint)(nil), "operations_research.MPIndicatorConstraint")
	proto.RegisterType((*MPSosConstraint)(nil), "operations_research.MPSosConstraint")
	proto.RegisterType((*MPQuadraticConstraint)(nil), "operations_research.MPQuadraticConstraint")
	proto.RegisterType((*MPAbsConstraint)(nil), "operations_research.MPAbsConstraint")
	proto.RegisterType((*MPArrayConstraint)(nil), "operations_research.MPArrayConstraint")
	proto.RegisterType((*MPArrayWithConstantConstraint)(nil), "operations_research.MPArrayWithConstantConstraint")
	proto.RegisterType((*MPQuadraticObjective)(nil), "operations_research.MPQuadraticObjective")
	proto.RegisterType((*PartialVariableAssignment)(nil), "operations_research.PartialVariableAssignment")
	proto.RegisterType((*MPModelProto)(nil), "operations_research.MPModelProto")
	proto.RegisterType((*OptionalDouble)(nil), "operations_research.OptionalDouble")
	proto.RegisterType((*MPSolverCommonParameters)(nil), "operations_research.MPSolverCommonParameters")
	proto.RegisterType((*MPModelDeltaProto)(nil), "operations_research.MPModelDeltaProto")
	proto.RegisterMapType((map[int32]*MPConstraintProto)(nil), "operations_research.MPModelDeltaProto.ConstraintOverridesEntry")
	proto.RegisterMapType((map[int32]*MPVariableProto)(nil), "operations_research.MPModelDeltaProto.VariableOverridesEntry")
	proto.RegisterType((*MPModelRequest)(nil), "operations_research.MPModelRequest")
	proto.RegisterType((*MPSolutionResponse)(nil), "operations_research.MPSolutionResponse")
}

func init() {
	proto.RegisterFile("ortools/linear_solver/linear_solver.proto", fileDescriptor_dc74569f987c0a21)
}

var fileDescriptor_dc74569f987c0a21 = []byte{
	// 2124 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0x4b, 0x77, 0xdb, 0xc6,
	0xf5, 0x17, 0xf8, 0xd0, 0xe3, 0x4a, 0xa2, 0xa1, 0x91, 0x2c, 0xd3, 0x4a, 0x1c, 0xcb, 0xb4, 0xe3,
	0xbf, 0x9c, 0x7f, 0xc2, 0x38, 0x5a, 0x34, 0xad, 0x4e, 0x7a, 0x52, 0xf0, 0x61, 0x99, 0x35, 0x49,
	0xa0, 0x00, 0xa5, 0xb8, 0x69, 0xda, 0xe9, 0x88, 0x1c, 0x51, 0x93, 0x82, 0x00, 0x04, 0x80, 0xb2,
	0xe5, 0x55, 0x17, 0x5d, 0xb4, 0x3d, 0xa7, 0xdd, 0xf7, 0x03, 0xf4, 0x33, 0xf4, 0xd3, 0x74, 0xd1,
	0xaf, 0xd1, 0xd3, 0x45, 0xcf, 0xcc, 0x00, 0x20, 0x41, 0x81, 0x8c, 0x92, 0xae, 0x48, 0xdc, 0xc7,
	0xef, 0xde, 0xb9, 0xb8, 0xaf, 0x01, 0x3c, 0x73, 0xfd, 0xd0, 0x75, 0xed, 0xe0, 0x53, 0x9b, 0x39,
	0x94, 0xf8, 0x38, 0x70, 0xed, 0x2b, 0xea, 0xa7, 0x9f, 0xaa, 0x9e, 0xef, 0x86, 0x2e, 0xda, 0x76,
	0x3d, 0xea, 0x93, 0x90, 0xb9, 0x4e, 0x80, 0x7d, 0x1a, 0x50, 0xe2, 0xf7, 0x2f, 0xf6, 0x1e, 0xc7,
	0xfa, 0xe3, 0x90, 0xd9, 0x9f, 0xba, 0x1e, 0x67, 0x13, 0x1b, 0x9f, 0xb9, 0xae, 0x4d, 0x89, 0x23,
	0x35, 0x2b, 0x7f, 0xc8, 0xc1, 0x9d, 0x8e, 0x71, 0x4a, 0x7c, 0x46, 0xce, 0x6c, 0x6a, 0x08, 0xb4,
	0x0f, 0x61, 0xdd, 0x76, 0xdf, 0x50, 0x1f, 0x9f, 0xb9, 0x63, 0x67, 0x50, 0x56, 0xf6, 0x95, 0x03,
	0xe5, 0xa8, 0xf0, 0x09, 0x73, 0xce, 0x4d, 0x10, 0x8c, 0x1a, 0xa7, 0xa3, 0x27, 0xb0, 0x3e, 0xf6,
	0xbc, 0x44, 0x2c, 0x27, 0xc4, 0xf2, 0x42, 0x4a, 0xd0, 0xa5, 0xd4, 0x8f, 0xe0, 0xae, 0x7b, 0xf6,
	0x2d, 0xed, 0x87, 0xec, 0x8a, 0xe2, 0xbe, 0x4b, 0xcf, 0xcf, 0x59, 0x9f, 0x51, 0x27, 0x2c, 0xe7,
	0x85, 0xbc, 0xf2, 0xdc, 0xdc, 0x49, 0xf8, 0xf5, 0x09, 0x1b, 0x3d, 0x01, 0x60, 0x01, 0x66, 0x4e,
	0x48, 0x87, 0xd4, 0x2f, 0x17, 0xf6, 0x95, 0x83, 0xd5, 0xa3, 0xe2, 0x39, 0xb1, 0x03, 0x6a, 0xae,
	0xb1, 0xa0, 0x25, 0xe9, 0x68, 0x07, 0x0a, 0x0e, 0x19, 0xd1, 0x72, 0x71, 0x5f, 0x39, 0x58, 0x3b,
	0x5a, 0x32, 0xc5, 0x13, 0x7a, 0x0e, 0xe8, 0xcc, 0x27, 0x4e, 0xff, 0x82, 0x39, 0x43, 0xec, 0xf9,
	0xcc, 0xf5, 0x59, 0x78, 0x5d, 0x5e, 0xde, 0x57, 0x0e, 0x8a, 0xdc, 0xe0, 0x56, 0xc2, 0x34, 0x22,
	0x5e, 0xe5, 0x9f, 0x0a, 0x6c, 0x75, 0x8c, 0xba, 0xeb, 0x04, 0xa1, 0x4f, 0x98, 0x13, 0xca, 0x40,
	0x3c, 0x84, 0xb5, 0x2b, 0xe2, 0x63, 0xe6, 0x0c, 0xe8, 0xdb, 0xf2, 0xf2, 0x7e, 0xfe, 0xa0, 0x58,
	0xcb, 0xa9, 0x8a, 0xb9, 0x7a, 0x45, 0xfc, 0x16, 0xa7, 0xf1, 0x10, 0x4c, 0x1f, 0x69, 0x65, 0x3f,
	0x7f, 0xa0, 0x08, 0x91, 0x69, 0xf2, 0x6c, 0x3c, 0x73, 0xb7, 0x8b, 0x67, 0x3e, 0x3b, 0x9e, 0xf1,
	0x89, 0x0b, 0xa9, 0x13, 0x7f, 0x00, 0x2b, 0x2c, 0xc0, 0x36, 0x79, 0x77, 0x2d, 0x42, 0x91, 0x84,
	0x6a, 0x99, 0x05, 0x6d, 0xf2, 0xee, 0xba, 0xf2, 0xfb, 0x65, 0x28, 0x77, 0x8c, 0x63, 0xea, 0x50,
	0x9f, 0xd8, 0xb3, 0xc7, 0x8c, 0x21, 0x95, 0x14, 0x24, 0x86, 0x1d, 0xe6, 0x0c, 0x58, 0x9f, 0x84,
	0xae, 0x8f, 0xfb, 0x89, 0x8a, 0x70, 0x7f, 0xfd, 0xf0, 0xa3, 0x6a, 0x46, 0xca, 0x55, 0x3b, 0x46,
	0x2b, 0x56, 0x99, 0x18, 0x79, 0xb9, 0x64, 0x6e, 0xb3, 0x9b, 0x64, 0xd4, 0x81, 0x52, 0xe0, 0x06,
	0xd3, 0xd0, 0x79, 0x01, 0xfd, 0x64, 0x0e, 0xb4, 0xe5, 0x06, 0x29, 0xd0, 0xcd, 0x60, 0x9a, 0xc0,
	0xfd, 0xbd, 0x1c, 0x93, 0x01, 0x57, 0xec, 0x4f, 0x83, 0x16, 0x16, 0xfa, 0xfb, 0x8b, 0x58, 0x25,
	0xed, 0xef, 0xe5, 0x4d, 0x32, 0xf7, 0x97, 0x9c, 0xa5, 0xfc, 0x2d, 0x2e, 0xf4, 0x57, 0x3b, 0x9b,
	0xf1, 0x97, 0x4c, 0x13, 0x90, 0x0e, 0x25, 0xe2, 0x0c, 0xa6, 0xe1, 0x96, 0x05, 0xdc, 0xd3, 0x79,
	0x70, 0xbe, 0x4f, 0xae, 0x67, 0x00, 0x9d, 0x41, 0xca, 0xbf, 0xcd, 0xf4, 0x9b, 0x5a, 0xf9, 0x9e,
	0x78, 0x1b, 0xa9, 0xd7, 0xf3, 0x2b, 0x28, 0x8d, 0x98, 0x33, 0x8d, 0xb7, 0x2a, 0xf0, 0x0e, 0x17,
	0xe1, 0x7d, 0xc5, 0xc2, 0x0b, 0x81, 0x41, 0x9c, 0x30, 0xed, 0xeb, 0x88, 0x39, 0x33, 0xe0, 0xe4,
	0xed, 0x34, 0xf8, 0xda, 0xff, 0x04, 0x4e, 0xde, 0x4e, 0x08, 0xb5, 0x1d, 0x40, 0x43, 0x99, 0xe9,
	0x53, 0x06, 0x2a, 0x7f, 0x53, 0xe0, 0x6e, 0x66, 0x7e, 0xa2, 0xf7, 0xa6, 0xcb, 0x9c, 0x17, 0x41,
	0x71, 0xaa, 0xc4, 0x23, 0xe6, 0x15, 0xb1, 0xc7, 0x54, 0xe4, 0xbe, 0x64, 0x9e, 0xf2, 0x67, 0xf4,
	0x02, 0xe0, 0x46, 0xfa, 0xce, 0x8b, 0xf7, 0x4c, 0xd5, 0x99, 0x53, 0x9a, 0x95, 0x7f, 0x28, 0xbc,
	0x0b, 0xa7, 0x12, 0x1c, 0xbd, 0x82, 0x42, 0x78, 0xed, 0xc9, 0xaa, 0x2c, 0x1d, 0x3e, 0xbb, 0x4d,
	0x51, 0x54, 0x7b, 0xd7, 0x1e, 0x3d, 0xda, 0xb0, 0x74, 0xeb, 0x33, 0xdc, 0x68, 0xbe, 0xd0, 0x4e,
	0xda, 0x3d, 0x53, 0x80, 0xa4, 0x8f, 0x98, 0xe3, 0x9d, 0x6c, 0xea, 0x88, 0xbb, 0xb0, 0xfc, 0x86,
	0xb2, 0xe1, 0x05, 0x3f, 0x41, 0xfe, 0x40, 0x31, 0xa3, 0xa7, 0x4a, 0x05, 0x0a, 0x1c, 0x10, 0xa9,
	0x90, 0x82, 0x54, 0x97, 0xd0, 0x2a, 0x14, 0x2c, 0xdd, 0x3a, 0x54, 0x95, 0xca, 0x9f, 0x72, 0x3c,
	0xaa, 0x19, 0x55, 0x34, 0x1b, 0xd5, 0xb4, 0xc9, 0xfd, 0x74, 0xe3, 0xcc, 0x09, 0xbb, 0xa9, 0xa6,
	0xf9, 0x10, 0xd6, 0x2f, 0xaf, 0x88, 0xff, 0x59, 0x04, 0x90, 0x17, 0x00, 0x20, 0x48, 0x12, 0x22,
	0x12, 0x38, 0x8c, 0x04, 0x0a, 0x13, 0x81, 0x43, 0x29, 0x50, 0x81, 0x8d, 0xcb, 0x69, 0x23, 0x45,
	0x61, 0x24, 0x45, 0x9b, 0x6d, 0xcd, 0xcb, 0xb7, 0x6b, 0xcd, 0x2b, 0x99, 0xad, 0xb9, 0xf2, 0x1b,
	0xfe, 0x12, 0x53, 0x55, 0xbf, 0x38, 0xb5, 0xaa, 0xb0, 0xed, 0xd3, 0x60, 0x6c, 0xf3, 0x7c, 0xc6,
	0xd3, 0xaf, 0x87, 0x8b, 0x6d, 0x25, 0xac, 0xd3, 0x48, 0xbe, 0xf2, 0x5b, 0x3e, 0xa3, 0x66, 0xca,
	0x76, 0x71, 0x98, 0xbf, 0xaf, 0x85, 0x3f, 0x2a, 0xf0, 0x60, 0x61, 0xb1, 0x2d, 0x36, 0xb7, 0x07,
	0xab, 0xfd, 0x48, 0x45, 0x4e, 0x39, 0x33, 0x79, 0x9e, 0xe7, 0x4a, 0x7e, 0x9e, 0x2b, 0xef, 0x60,
	0x67, 0x2a, 0xaf, 0xf4, 0x78, 0x45, 0x98, 0xcd, 0x0b, 0xe5, 0xbb, 0xf2, 0x22, 0x77, 0x23, 0x2f,
	0x66, 0x72, 0x2f, 0x7f, 0x23, 0xf7, 0x2a, 0xbf, 0x86, 0xfb, 0x06, 0xf1, 0x43, 0x46, 0xec, 0x78,
	0x31, 0xd2, 0x82, 0x80, 0x0d, 0x9d, 0x91, 0x4c, 0xcc, 0xd9, 0x08, 0xcc, 0x2c, 0x05, 0x0f, 0xd3,
	0x1d, 0x23, 0x5e, 0x09, 0x92, 0xae, 0x51, 0xf9, 0x6b, 0x01, 0x36, 0x3a, 0x46, 0xc7, 0x1d, 0x50,
	0x5b, 0x0e, 0xe0, 0x9f, 0x01, 0x67, 0x0a, 0x43, 0xc2, 0x9d, 0xf9, 0x33, 0x25, 0xb5, 0xa8, 0x99,
	0x89, 0xd6, 0x4c, 0x23, 0x2a, 0x08, 0x8c, 0x1f, 0xd0, 0x88, 0xd0, 0x37, 0x59, 0xad, 0x53, 0xec,
	0x35, 0xeb, 0x87, 0x9f, 0xcc, 0xc1, 0xcb, 0xde, 0x2a, 0xcc, 0xad, 0xe1, 0x2c, 0x1d, 0x3d, 0x82,
	0xd5, 0x11, 0x79, 0xcb, 0x46, 0xec, 0x9d, 0x6c, 0x6b, 0xc9, 0x9a, 0x92, 0x90, 0xd1, 0xc7, 0xa0,
	0x4e, 0xd6, 0x45, 0xf7, 0xfc, 0x3c, 0xa0, 0x51, 0x2a, 0xf1, 0xc5, 0xed, 0x4e, 0xc2, 0xd2, 0x05,
	0x07, 0x7d, 0x0d, 0x93, 0x49, 0x8d, 0x13, 0x66, 0x34, 0xa8, 0x9e, 0x7d, 0xd7, 0xc8, 0x4f, 0x92,
	0xca, 0x44, 0x97, 0x37, 0x13, 0x2d, 0x7b, 0xb5, 0xb4, 0x60, 0x33, 0x70, 0xed, 0x31, 0x07, 0xc5,
	0x17, 0x93, 0xa1, 0x5d, 0xcd, 0xb4, 0x35, 0x37, 0x89, 0xcc, 0x8d, 0x18, 0xe4, 0x25, 0x6f, 0xff,
	0x4f, 0xa1, 0xa4, 0x47, 0xeb, 0x79, 0xc3, 0x1d, 0xf3, 0xf7, 0xb9, 0x03, 0x45, 0x99, 0x3f, 0x62,
	0xf9, 0x36, 0xe5, 0x43, 0xe5, 0x2f, 0x45, 0xbe, 0xc5, 0x59, 0x62, 0xf3, 0xaf, 0xbb, 0xa3, 0x91,
	0xeb, 0x18, 0xc4, 0x27, 0x23, 0x1a, 0x52, 0x3f, 0x40, 0x1d, 0x50, 0x7d, 0x6a, 0x13, 0x11, 0xb8,
	0x11, 0xf3, 0xf0, 0x90, 0x78, 0x42, 0x7b, 0xfd, 0xf0, 0x71, 0xa6, 0x73, 0x69, 0x8b, 0x66, 0x29,
	0x56, 0xee, 0x30, 0xef, 0x98, 0x78, 0xa8, 0x0b, 0xaa, 0xe7, 0xb3, 0x11, 0xb1, 0x71, 0xe8, 0xda,
	0x94, 0x2f, 0xcc, 0x34, 0x5a, 0xfd, 0x6e, 0x05, 0x77, 0x47, 0x2a, 0xf7, 0x62, 0x5d, 0xf4, 0x73,
	0x28, 0x0d, 0xc6, 0x29, 0xb4, 0xfc, 0xed, 0xd1, 0x36, 0xb9, 0xea, 0x04, 0xeb, 0x0d, 0x6c, 0xd8,
	0x1e, 0x26, 0xf6, 0x90, 0x2f, 0xef, 0x17, 0x23, 0xb1, 0xe2, 0x95, 0x0e, 0xbf, 0x9c, 0x3b, 0x22,
	0xb3, 0xe2, 0x55, 0x6d, 0x1b, 0x5a, 0x0c, 0x20, 0xca, 0x32, 0x38, 0xda, 0x6e, 0x1b, 0x58, 0x6b,
	0x1f, 0xeb, 0xf8, 0xa4, 0x6b, 0x19, 0xcd, 0x7a, 0xeb, 0x45, 0xab, 0xd9, 0x30, 0xd7, 0x6d, 0x2f,
	0x91, 0x43, 0x26, 0xac, 0x7a, 0x3e, 0x15, 0x57, 0x2f, 0x91, 0x17, 0xa5, 0x39, 0x85, 0x1a, 0xbb,
	0x5f, 0x93, 0x77, 0xad, 0x23, 0xb5, 0xa6, 0xeb, 0xed, 0x14, 0x6c, 0x82, 0x83, 0x0c, 0x58, 0x09,
	0xfa, 0xc4, 0x66, 0xce, 0x50, 0xcc, 0x95, 0x1f, 0x0e, 0x19, 0xc3, 0x54, 0x86, 0xb0, 0x75, 0xe3,
	0x70, 0xe8, 0x1e, 0x64, 0x1d, 0x4f, 0x5d, 0xe2, 0xd3, 0x3d, 0x66, 0x34, 0x4e, 0xb4, 0xb6, 0xaa,
	0x20, 0x04, 0xa5, 0x98, 0x62, 0x98, 0xad, 0x8e, 0xd6, 0x56, 0x73, 0x68, 0x1b, 0xee, 0xc4, 0xb4,
	0x9a, 0x66, 0x9a, 0xad, 0xa6, 0xa9, 0xe6, 0x2b, 0x7f, 0x2e, 0xf0, 0x89, 0x24, 0x1a, 0x59, 0x83,
	0xda, 0x21, 0x91, 0xdd, 0xec, 0x73, 0x28, 0x9f, 0x91, 0x80, 0xf2, 0x7b, 0x2a, 0x1e, 0x71, 0x1e,
	0x3e, 0x67, 0x36, 0xc5, 0x1e, 0x09, 0x2f, 0xe4, 0x15, 0xc3, 0xbc, 0x1b, 0xf3, 0x85, 0xea, 0x0b,
	0x66, 0x53, 0x83, 0x84, 0x17, 0xc8, 0x06, 0x14, 0x37, 0x34, 0xec, 0x5e, 0x51, 0xdf, 0x67, 0x03,
	0x1a, 0x88, 0x0e, 0xba, 0x7e, 0xf8, 0xd3, 0x39, 0x2f, 0x77, 0xc6, 0x78, 0x35, 0xae, 0x35, 0x3d,
	0xd6, 0x6f, 0x3a, 0xa1, 0x7f, 0x6d, 0x6e, 0x5d, 0xcd, 0xd2, 0x91, 0x0f, 0x3b, 0x93, 0x16, 0x37,
	0x65, 0x4f, 0x36, 0xe0, 0x2f, 0x6f, 0x69, 0x6f, 0xd2, 0xdd, 0x66, 0x2c, 0x6e, 0xf7, 0x6f, 0x72,
	0xf6, 0xbe, 0x85, 0xdd, 0x6c, 0x07, 0x91, 0x0a, 0xf9, 0xdf, 0xd1, 0xeb, 0x68, 0x45, 0xe0, 0x7f,
	0xd1, 0x51, 0xdc, 0x02, 0x72, 0x0b, 0x6f, 0x19, 0xe9, 0x89, 0x20, 0x55, 0x8e, 0x72, 0x3f, 0x56,
	0xf6, 0x1c, 0x28, 0xcf, 0x73, 0x2e, 0xc3, 0xda, 0x17, 0x69, 0x6b, 0xb7, 0x9d, 0x1d, 0x13, 0x7b,
	0x95, 0xbf, 0xaf, 0x40, 0x29, 0x8a, 0x8f, 0x49, 0x2f, 0xc7, 0x34, 0x08, 0xd1, 0xe7, 0x50, 0x14,
	0x09, 0x10, 0xf5, 0xa1, 0x47, 0x8b, 0x62, 0x1a, 0xe1, 0x09, 0x79, 0xa4, 0xc3, 0xba, 0xfc, 0xbe,
	0x81, 0xc5, 0x0a, 0x9c, 0x13, 0x75, 0x51, 0x5d, 0xa4, 0x1e, 0x99, 0xac, 0xca, 0x62, 0xe7, 0x6b,
	0xab, 0x09, 0x41, 0xf2, 0x1f, 0xfd, 0x04, 0xee, 0xc7, 0x80, 0x6c, 0x44, 0xb1, 0xcd, 0x46, 0x2c,
	0xc4, 0x01, 0xed, 0xbb, 0xce, 0x20, 0x90, 0x37, 0x6d, 0x73, 0x37, 0x12, 0x67, 0x23, 0xda, 0xe6,
	0x6c, 0x4b, 0x72, 0xd1, 0x4b, 0x78, 0x40, 0x1d, 0x91, 0x93, 0xcc, 0x09, 0xa9, 0xef, 0x10, 0x3b,
	0xfa, 0xf6, 0x82, 0xdd, 0x71, 0xe8, 0x8d, 0xc3, 0xf4, 0xb7, 0x89, 0x3d, 0x29, 0xdb, 0x8a, 0x44,
	0xa5, 0x3b, 0xba, 0x10, 0x44, 0x5f, 0xc0, 0x5e, 0xa4, 0x19, 0x78, 0xb4, 0xcf, 0xce, 0x59, 0x1f,
	0x7b, 0x49, 0x3f, 0x92, 0x73, 0xc6, 0x2c, 0x4b, 0x09, 0x2b, 0x12, 0x98, 0xea, 0xef, 0xc7, 0xb0,
	0x2e, 0xab, 0x69, 0xc0, 0xb3, 0x2f, 0x9a, 0x71, 0x4f, 0x6f, 0x97, 0xa6, 0x26, 0x8c, 0x12, 0x42,
	0xe5, 0x3f, 0x79, 0x80, 0x49, 0x98, 0xd0, 0x7b, 0x70, 0xef, 0xb8, 0xad, 0x1b, 0xb8, 0xdd, 0xea,
	0x36, 0x35, 0x13, 0x1b, 0xa6, 0x7e, 0x6c, 0x6a, 0x9d, 0x4e, 0xab, 0x7b, 0xac, 0xe6, 0xd0, 0x1e,
	0xec, 0xd6, 0xdb, 0x99, 0xbc, 0x25, 0xa9, 0x68, 0xbc, 0xca, 0x62, 0x2a, 0xe8, 0x01, 0xdc, 0x3f,
	0x3e, 0x31, 0xf5, 0x5a, 0x2b, 0x8b, 0xbd, 0xcc, 0xd9, 0xaf, 0x0d, 0xb3, 0x69, 0x59, 0x59, 0x6c,
	0x8a, 0xde, 0x87, 0x72, 0xdd, 0x68, 0x37, 0x5f, 0x67, 0x71, 0x01, 0x55, 0xe0, 0x03, 0xab, 0xde,
	0x32, 0x70, 0xa7, 0xf5, 0xba, 0xd9, 0xc0, 0xad, 0x6e, 0xaf, 0x79, 0xdc, 0x4c, 0xcb, 0xe4, 0xb9,
	0x8c, 0x70, 0x6e, 0xbe, 0x4c, 0x01, 0x3d, 0x82, 0x07, 0xf5, 0x5a, 0x7d, 0x81, 0x48, 0x11, 0x3d,
	0x81, 0xfd, 0xe8, 0x18, 0xf3, 0xa5, 0x56, 0xb8, 0x54, 0x74, 0x9a, 0xf9, 0x52, 0xe7, 0xe8, 0x31,
	0x3c, 0x94, 0x87, 0x9a, 0x2f, 0xb4, 0xce, 0x83, 0x5a, 0xd3, 0x8d, 0x4c, 0xe6, 0x06, 0x67, 0x5a,
	0x5a, 0x2f, 0x93, 0x59, 0x42, 0x4f, 0xa1, 0xf2, 0xaa, 0xab, 0x19, 0x96, 0x56, 0x5f, 0x74, 0xea,
	0xcd, 0xca, 0xbf, 0x72, 0x80, 0xc4, 0x50, 0x14, 0xfb, 0x87, 0x49, 0x03, 0xcf, 0x75, 0x02, 0x8a,
	0xbe, 0x81, 0xe5, 0x20, 0x24, 0xe1, 0x38, 0x88, 0x2e, 0x9c, 0xff, 0xbf, 0x70, 0x9a, 0xc6, 0x6a,
	0x96, 0x50, 0x39, 0xba, 0xd7, 0x31, 0x2c, 0xbd, 0x7d, 0xda, 0x34, 0xf1, 0x49, 0xf7, 0x55, 0x57,
	0xff, 0xaa, 0x8b, 0xad, 0x9e, 0xd6, 0x3b, 0xb1, 0xcc, 0x08, 0x13, 0x3d, 0x00, 0x90, 0xff, 0x70,
	0x10, 0xfa, 0x62, 0xce, 0xad, 0x99, 0x6b, 0x92, 0x62, 0x85, 0x3e, 0xfa, 0x3f, 0x98, 0xac, 0x76,
	0x53, 0x57, 0x6d, 0xc5, 0x2c, 0x25, 0x64, 0x79, 0xe1, 0x7e, 0x0e, 0x3b, 0x67, 0x34, 0x08, 0x27,
	0xbb, 0x5e, 0x74, 0x23, 0x2b, 0x0a, 0x69, 0xc4, 0x79, 0xc9, 0x06, 0x27, 0xaf, 0x6e, 0xcf, 0xa0,
	0x94, 0x0c, 0x15, 0x89, 0x9c, 0x4f, 0x56, 0xf2, 0xcd, 0x98, 0x23, 0xc1, 0x1f, 0x01, 0x88, 0x15,
	0x45, 0x8a, 0x15, 0x12, 0xb1, 0x35, 0x4e, 0x95, 0x22, 0x1f, 0xc2, 0x86, 0x4f, 0x07, 0xe3, 0x3e,
	0x1d, 0xe0, 0xbe, 0x1b, 0x84, 0xe2, 0xa3, 0x60, 0xf4, 0xc5, 0x2f, 0xa2, 0xd7, 0xdd, 0x20, 0xfc,
	0xe8, 0xdf, 0x39, 0xd8, 0xcd, 0x0e, 0x15, 0xda, 0x01, 0x35, 0x09, 0x96, 0x6e, 0xf4, 0xc4, 0x78,
	0x5d, 0x42, 0x77, 0xf9, 0x20, 0x8d, 0xa8, 0x2f, 0x9a, 0x9a, 0xd5, 0xaa, 0xb5, 0x9b, 0xaa, 0xc2,
	0x87, 0x76, 0x42, 0x6e, 0x75, 0x13, 0x46, 0x0e, 0xed, 0x8a, 0x77, 0x18, 0x87, 0xbc, 0xa6, 0x9f,
	0x74, 0x1b, 0xcd, 0x86, 0x9a, 0x4f, 0xe1, 0x68, 0xb5, 0xae, 0x6e, 0x72, 0xf8, 0x42, 0x0a, 0xa7,
	0xab, 0xf7, 0xb0, 0xf8, 0xdb, 0x50, 0x97, 0x79, 0x46, 0x25, 0x8c, 0x8e, 0xde, 0x68, 0xb6, 0x71,
	0xcb, 0xc2, 0xa7, 0x5a, 0xbb, 0xd5, 0x50, 0x49, 0x8a, 0x99, 0x7e, 0xaf, 0x6a, 0x9f, 0x77, 0x86,
	0x59, 0xcd, 0xae, 0x54, 0x2c, 0xa2, 0x03, 0x78, 0x92, 0xcd, 0xe3, 0x86, 0x4f, 0x7a, 0x2d, 0xbd,
	0x8b, 0x5f, 0xb6, 0xba, 0x3d, 0xb5, 0x87, 0x3e, 0x86, 0x83, 0xf9, 0x92, 0x9c, 0x68, 0x68, 0xa6,
	0xd6, 0x69, 0xf6, 0x9a, 0xa6, 0xa5, 0x9e, 0xf0, 0x3a, 0x4b, 0xa4, 0xa3, 0x9f, 0xde, 0x2f, 0x8d,
	0x26, 0x3e, 0xe9, 0x6a, 0xa7, 0x5a, 0xab, 0xad, 0xf1, 0xd8, 0xac, 0xd4, 0x34, 0x78, 0xd8, 0x77,
	0x47, 0xd5, 0xa1, 0xeb, 0x0e, 0x6d, 0x5a, 0x8d, 0x3e, 0x82, 0x57, 0xe5, 0x67, 0x73, 0xd9, 0x5d,
	0x0d, 0xe5, 0xeb, 0xf7, 0xe3, 0x8f, 0xe3, 0x43, 0x77, 0xe6, 0xfb, 0xfa, 0x90, 0x3a, 0xff, 0x0d,
	0x00, 0x00, 0xff, 0xff, 0x23, 0xb6, 0x43, 0x57, 0x7b, 0x17, 0x00, 0x00,
}
