// Code generated by protoc-gen-go. DO NOT EDIT.
// source: ortools/constraint_solver/routing_enums.proto

package gen

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type FirstSolutionStrategy_Value int32

const (
	// See the homonymous value in LocalSearchMetaheuristic.
	FirstSolutionStrategy_UNSET FirstSolutionStrategy_Value = 0
	// Lets the solver detect which strategy to use according to the model being
	// solved.
	FirstSolutionStrategy_AUTOMATIC FirstSolutionStrategy_Value = 15
	// --- Path addition heuristics ---
	// Starting from a route "start" node, connect it to the node which produces
	// the cheapest route segment, then extend the route by iterating on the
	// last node added to the route.
	FirstSolutionStrategy_PATH_CHEAPEST_ARC FirstSolutionStrategy_Value = 3
	// Same as PATH_CHEAPEST_ARC, but arcs are evaluated with a comparison-based
	// selector which will favor the most constrained arc first. To assign a
	// selector to the routing model, see
	// RoutingModel::ArcIsMoreConstrainedThanArc() in routing.h for details.
	FirstSolutionStrategy_PATH_MOST_CONSTRAINED_ARC FirstSolutionStrategy_Value = 4
	// Same as PATH_CHEAPEST_ARC, except that arc costs are evaluated using the
	// function passed to RoutingModel::SetFirstSolutionEvaluator()
	// (cf. routing.h).
	FirstSolutionStrategy_EVALUATOR_STRATEGY FirstSolutionStrategy_Value = 5
	// Savings algorithm (Clarke & Wright).
	// Reference: Clarke, G. & Wright, J.W.:
	// "Scheduling of Vehicles from a Central Depot to a Number of Delivery
	// Points", Operations Research, Vol. 12, 1964, pp. 568-581
	FirstSolutionStrategy_SAVINGS FirstSolutionStrategy_Value = 10
	// Sweep algorithm (Wren & Holliday).
	// Reference: Anthony Wren & Alan Holliday: Computer Scheduling of Vehicles
	// from One or More Depots to a Number of Delivery Points Operational
	// Research Quarterly (1970-1977),
	// Vol. 23, No. 3 (Sep., 1972), pp. 333-344
	FirstSolutionStrategy_SWEEP FirstSolutionStrategy_Value = 11
	// Christofides algorithm (actually a variant of the Christofides algorithm
	// using a maximal matching instead of a maximum matching, which does
	// not guarantee the 3/2 factor of the approximation on a metric travelling
	// salesman). Works on generic vehicle routing models by extending a route
	// until no nodes can be inserted on it.
	// Reference: Nicos Christofides, Worst-case analysis of a new heuristic for
	// the travelling salesman problem, Report 388, Graduate School of
	// Industrial Administration, CMU, 1976.
	FirstSolutionStrategy_CHRISTOFIDES FirstSolutionStrategy_Value = 13
	// --- Path insertion heuristics ---
	// Make all nodes inactive. Only finds a solution if nodes are optional (are
	// element of a disjunction constraint with a finite penalty cost).
	FirstSolutionStrategy_ALL_UNPERFORMED FirstSolutionStrategy_Value = 6
	// Iteratively build a solution by inserting the cheapest node at its
	// cheapest position; the cost of insertion is based on the global cost
	// function of the routing model. As of 2/2012, only works on models with
	// optional nodes (with finite penalty costs).
	FirstSolutionStrategy_BEST_INSERTION FirstSolutionStrategy_Value = 7
	// Iteratively build a solution by inserting the cheapest node at its
	// cheapest position; the cost of insertion is based on the arc cost
	// function. Is faster than BEST_INSERTION.
	FirstSolutionStrategy_PARALLEL_CHEAPEST_INSERTION FirstSolutionStrategy_Value = 8
	// Iteratively build a solution by constructing routes sequentially, for
	// each route inserting the cheapest node at its cheapest position until the
	// route is completed; the cost of insertion is based on the arc cost
	// function. Is faster than PARALLEL_CHEAPEST_INSERTION.
	FirstSolutionStrategy_SEQUENTIAL_CHEAPEST_INSERTION FirstSolutionStrategy_Value = 14
	// Iteratively build a solution by inserting each node at its cheapest
	// position; the cost of insertion is based on the arc cost function.
	// Differs from PARALLEL_CHEAPEST_INSERTION by the node selected for
	// insertion; here nodes are considered in decreasing order of distance to
	// the start/ends of the routes, i.e. farthest nodes are inserted first.
	// Is faster than SEQUENTIAL_CHEAPEST_INSERTION.
	FirstSolutionStrategy_LOCAL_CHEAPEST_INSERTION FirstSolutionStrategy_Value = 9
	// --- Variable-based heuristics ---
	// Iteratively connect two nodes which produce the cheapest route segment.
	FirstSolutionStrategy_GLOBAL_CHEAPEST_ARC FirstSolutionStrategy_Value = 1
	// Select the first node with an unbound successor and connect it to the
	// node which produces the cheapest route segment.
	FirstSolutionStrategy_LOCAL_CHEAPEST_ARC FirstSolutionStrategy_Value = 2
	// Select the first node with an unbound successor and connect it to the
	// first available node.
	// This is equivalent to the CHOOSE_FIRST_UNBOUND strategy combined with
	// ASSIGN_MIN_VALUE (cf. constraint_solver.h).
	FirstSolutionStrategy_FIRST_UNBOUND_MIN_VALUE FirstSolutionStrategy_Value = 12
)

var FirstSolutionStrategy_Value_name = map[int32]string{
	0:  "UNSET",
	15: "AUTOMATIC",
	3:  "PATH_CHEAPEST_ARC",
	4:  "PATH_MOST_CONSTRAINED_ARC",
	5:  "EVALUATOR_STRATEGY",
	10: "SAVINGS",
	11: "SWEEP",
	13: "CHRISTOFIDES",
	6:  "ALL_UNPERFORMED",
	7:  "BEST_INSERTION",
	8:  "PARALLEL_CHEAPEST_INSERTION",
	14: "SEQUENTIAL_CHEAPEST_INSERTION",
	9:  "LOCAL_CHEAPEST_INSERTION",
	1:  "GLOBAL_CHEAPEST_ARC",
	2:  "LOCAL_CHEAPEST_ARC",
	12: "FIRST_UNBOUND_MIN_VALUE",
}

var FirstSolutionStrategy_Value_value = map[string]int32{
	"UNSET":                         0,
	"AUTOMATIC":                     15,
	"PATH_CHEAPEST_ARC":             3,
	"PATH_MOST_CONSTRAINED_ARC":     4,
	"EVALUATOR_STRATEGY":            5,
	"SAVINGS":                       10,
	"SWEEP":                         11,
	"CHRISTOFIDES":                  13,
	"ALL_UNPERFORMED":               6,
	"BEST_INSERTION":                7,
	"PARALLEL_CHEAPEST_INSERTION":   8,
	"SEQUENTIAL_CHEAPEST_INSERTION": 14,
	"LOCAL_CHEAPEST_INSERTION":      9,
	"GLOBAL_CHEAPEST_ARC":           1,
	"LOCAL_CHEAPEST_ARC":            2,
	"FIRST_UNBOUND_MIN_VALUE":       12,
}

func (x FirstSolutionStrategy_Value) String() string {
	return proto.EnumName(FirstSolutionStrategy_Value_name, int32(x))
}

func (FirstSolutionStrategy_Value) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b7b5978686650e8a, []int{0, 0}
}

type LocalSearchMetaheuristic_Value int32

const (
	// Means "not set". If the solver sees that, it'll behave like for
	// AUTOMATIC. But this value won't override others upon a proto MergeFrom(),
	// whereas "AUTOMATIC" will.
	LocalSearchMetaheuristic_UNSET LocalSearchMetaheuristic_Value = 0
	// Lets the solver select the metaheuristic.
	LocalSearchMetaheuristic_AUTOMATIC LocalSearchMetaheuristic_Value = 6
	// Accepts improving (cost-reducing) local search neighbors until a local
	// minimum is reached.
	LocalSearchMetaheuristic_GREEDY_DESCENT LocalSearchMetaheuristic_Value = 1
	// Uses guided local search to escape local minima
	// (cf. http://en.wikipedia.org/wiki/Guided_Local_Search); this is generally
	// the most efficient metaheuristic for vehicle routing.
	LocalSearchMetaheuristic_GUIDED_LOCAL_SEARCH LocalSearchMetaheuristic_Value = 2
	// Uses simulated annealing to escape local minima
	// (cf. http://en.wikipedia.org/wiki/Simulated_annealing).
	LocalSearchMetaheuristic_SIMULATED_ANNEALING LocalSearchMetaheuristic_Value = 3
	// Uses tabu search to escape local minima
	// (cf. http://en.wikipedia.org/wiki/Tabu_search).
	LocalSearchMetaheuristic_TABU_SEARCH LocalSearchMetaheuristic_Value = 4
	// Uses tabu search on a list of variables to escape local minima. The list
	// of variables to use must be provided via the SetTabuVarsCallback
	// callback.
	LocalSearchMetaheuristic_GENERIC_TABU_SEARCH LocalSearchMetaheuristic_Value = 5
)

var LocalSearchMetaheuristic_Value_name = map[int32]string{
	0: "UNSET",
	6: "AUTOMATIC",
	1: "GREEDY_DESCENT",
	2: "GUIDED_LOCAL_SEARCH",
	3: "SIMULATED_ANNEALING",
	4: "TABU_SEARCH",
	5: "GENERIC_TABU_SEARCH",
}

var LocalSearchMetaheuristic_Value_value = map[string]int32{
	"UNSET":               0,
	"AUTOMATIC":           6,
	"GREEDY_DESCENT":      1,
	"GUIDED_LOCAL_SEARCH": 2,
	"SIMULATED_ANNEALING": 3,
	"TABU_SEARCH":         4,
	"GENERIC_TABU_SEARCH": 5,
}

func (x LocalSearchMetaheuristic_Value) String() string {
	return proto.EnumName(LocalSearchMetaheuristic_Value_name, int32(x))
}

func (LocalSearchMetaheuristic_Value) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b7b5978686650e8a, []int{1, 0}
}

// First solution strategies, used as starting point of local search.
type FirstSolutionStrategy struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FirstSolutionStrategy) Reset()         { *m = FirstSolutionStrategy{} }
func (m *FirstSolutionStrategy) String() string { return proto.CompactTextString(m) }
func (*FirstSolutionStrategy) ProtoMessage()    {}
func (*FirstSolutionStrategy) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7b5978686650e8a, []int{0}
}

func (m *FirstSolutionStrategy) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FirstSolutionStrategy.Unmarshal(m, b)
}
func (m *FirstSolutionStrategy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FirstSolutionStrategy.Marshal(b, m, deterministic)
}
func (m *FirstSolutionStrategy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirstSolutionStrategy.Merge(m, src)
}
func (m *FirstSolutionStrategy) XXX_Size() int {
	return xxx_messageInfo_FirstSolutionStrategy.Size(m)
}
func (m *FirstSolutionStrategy) XXX_DiscardUnknown() {
	xxx_messageInfo_FirstSolutionStrategy.DiscardUnknown(m)
}

var xxx_messageInfo_FirstSolutionStrategy proto.InternalMessageInfo

// Local search metaheuristics used to guide the search. Apart from greedy
// descent, they will try to escape local minima.
type LocalSearchMetaheuristic struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LocalSearchMetaheuristic) Reset()         { *m = LocalSearchMetaheuristic{} }
func (m *LocalSearchMetaheuristic) String() string { return proto.CompactTextString(m) }
func (*LocalSearchMetaheuristic) ProtoMessage()    {}
func (*LocalSearchMetaheuristic) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7b5978686650e8a, []int{1}
}

func (m *LocalSearchMetaheuristic) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LocalSearchMetaheuristic.Unmarshal(m, b)
}
func (m *LocalSearchMetaheuristic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LocalSearchMetaheuristic.Marshal(b, m, deterministic)
}
func (m *LocalSearchMetaheuristic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocalSearchMetaheuristic.Merge(m, src)
}
func (m *LocalSearchMetaheuristic) XXX_Size() int {
	return xxx_messageInfo_LocalSearchMetaheuristic.Size(m)
}
func (m *LocalSearchMetaheuristic) XXX_DiscardUnknown() {
	xxx_messageInfo_LocalSearchMetaheuristic.DiscardUnknown(m)
}

var xxx_messageInfo_LocalSearchMetaheuristic proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("operations_research.FirstSolutionStrategy_Value", FirstSolutionStrategy_Value_name, FirstSolutionStrategy_Value_value)
	proto.RegisterEnum("operations_research.LocalSearchMetaheuristic_Value", LocalSearchMetaheuristic_Value_name, LocalSearchMetaheuristic_Value_value)
	proto.RegisterType((*FirstSolutionStrategy)(nil), "operations_research.FirstSolutionStrategy")
	proto.RegisterType((*LocalSearchMetaheuristic)(nil), "operations_research.LocalSearchMetaheuristic")
}

func init() {
	proto.RegisterFile("ortools/constraint_solver/routing_enums.proto", fileDescriptor_b7b5978686650e8a)
}

var fileDescriptor_b7b5978686650e8a = []byte{
	// 505 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x92, 0xdf, 0x6e, 0xd3, 0x30,
	0x14, 0xc6, 0x69, 0xb7, 0x6e, 0xcc, 0xfb, 0x53, 0xe3, 0x6a, 0x6c, 0x68, 0x4c, 0x83, 0x72, 0x4d,
	0x77, 0xc1, 0x13, 0xb8, 0xc9, 0x69, 0x6a, 0x29, 0x71, 0x82, 0xed, 0x14, 0x8d, 0x1b, 0x2b, 0x54,
	0x51, 0x16, 0x91, 0xc5, 0x93, 0xe3, 0x22, 0xf1, 0x0e, 0xdc, 0xf0, 0x1a, 0x5c, 0xf0, 0x70, 0x3c,
	0x01, 0x4a, 0xca, 0xe8, 0x84, 0x2a, 0x71, 0x7b, 0x7e, 0x9f, 0x8f, 0xbf, 0x73, 0xce, 0x87, 0xde,
	0x1a, 0xeb, 0x8c, 0xa9, 0x9a, 0xeb, 0xa5, 0xa9, 0x1b, 0x67, 0xb3, 0xb2, 0x76, 0xba, 0x31, 0xd5,
	0x97, 0xdc, 0x5e, 0x5b, 0xb3, 0x72, 0x65, 0x5d, 0xe8, 0xbc, 0x5e, 0xdd, 0x35, 0x93, 0x7b, 0x6b,
	0x9c, 0x21, 0x23, 0x73, 0x9f, 0xdb, 0xcc, 0x95, 0xa6, 0x6e, 0xb4, 0xcd, 0x9b, 0x3c, 0xb3, 0xcb,
	0xdb, 0xf1, 0xb7, 0x1d, 0x74, 0x3a, 0x2b, 0x6d, 0xe3, 0xa4, 0xa9, 0x56, 0x2d, 0x93, 0xce, 0x66,
	0x2e, 0x2f, 0xbe, 0x8e, 0x7f, 0xf5, 0xd1, 0x60, 0x91, 0x55, 0xab, 0x9c, 0x1c, 0xa0, 0x41, 0xca,
	0x25, 0x28, 0xfc, 0x84, 0x1c, 0xa3, 0x03, 0x9a, 0xaa, 0x38, 0xa2, 0x8a, 0x79, 0x78, 0x48, 0x4e,
	0xd1, 0xb3, 0x84, 0xaa, 0xb9, 0xf6, 0xe6, 0x40, 0x13, 0x90, 0x4a, 0x53, 0xe1, 0xe1, 0x1d, 0x72,
	0x89, 0x5e, 0x74, 0xe5, 0x28, 0x96, 0x4a, 0x7b, 0x31, 0x97, 0x4a, 0x50, 0xc6, 0xc1, 0xef, 0xf0,
	0x2e, 0x79, 0x8e, 0x08, 0x2c, 0x68, 0x98, 0x52, 0x15, 0x0b, 0xdd, 0x32, 0x05, 0xc1, 0x0d, 0x1e,
	0x90, 0x43, 0xb4, 0x2f, 0xe9, 0x82, 0xf1, 0x40, 0x62, 0xd4, 0x7e, 0x2a, 0x3f, 0x00, 0x24, 0xf8,
	0x90, 0x60, 0x74, 0xe4, 0xcd, 0x05, 0x93, 0x2a, 0x9e, 0x31, 0x1f, 0x24, 0x3e, 0x26, 0x23, 0x34,
	0xa4, 0x61, 0xa8, 0x53, 0x9e, 0x80, 0x98, 0xc5, 0x22, 0x02, 0x1f, 0xef, 0x11, 0x82, 0x4e, 0xa6,
	0xad, 0x07, 0xc6, 0x25, 0x08, 0xc5, 0x62, 0x8e, 0xf7, 0xc9, 0x15, 0xba, 0x48, 0xa8, 0xa0, 0x61,
	0x08, 0xe1, 0xc6, 0xe4, 0x46, 0xf0, 0x94, 0xbc, 0x46, 0x97, 0x12, 0xde, 0xa7, 0xc0, 0x15, 0xa3,
	0x5b, 0x25, 0x27, 0xe4, 0x25, 0x3a, 0x0f, 0x63, 0x6f, 0x3b, 0x3d, 0x20, 0x67, 0x68, 0x14, 0x84,
	0xf1, 0xf4, 0x31, 0x6e, 0xa7, 0xec, 0xb5, 0x53, 0xfe, 0xf3, 0xac, 0xad, 0xf7, 0xc9, 0x05, 0x3a,
	0x9b, 0x31, 0x21, 0x95, 0x4e, 0xf9, 0x34, 0x4e, 0xb9, 0xaf, 0x23, 0xc6, 0x75, 0xbb, 0x0e, 0xc0,
	0x47, 0xe3, 0x9f, 0x3d, 0x74, 0x1e, 0x9a, 0x65, 0x56, 0xc9, 0xee, 0x3c, 0x51, 0xee, 0xb2, 0xdb,
	0x7c, 0x65, 0xcb, 0xc6, 0x95, 0xcb, 0xf1, 0xf7, 0xde, 0xff, 0x2e, 0xd2, 0x2d, 0x21, 0x10, 0x00,
	0xfe, 0x8d, 0xf6, 0x41, 0x7a, 0xc0, 0x15, 0xee, 0x75, 0x16, 0x53, 0xe6, 0x83, 0xaf, 0xd7, 0x86,
	0x24, 0x50, 0xe1, 0xcd, 0x71, 0xbf, 0x05, 0x92, 0x45, 0x69, 0x48, 0x55, 0x7b, 0x1b, 0xce, 0x81,
	0x86, 0x8c, 0x07, 0x78, 0x87, 0x0c, 0xd1, 0xa1, 0xa2, 0xd3, 0xf4, 0x41, 0xb9, 0xdb, 0xb5, 0x00,
	0x0e, 0x82, 0x79, 0xfa, 0x31, 0x18, 0x4c, 0x3f, 0xa3, 0x37, 0x4b, 0x73, 0x37, 0x29, 0x8c, 0x29,
	0xaa, 0x7c, 0xf2, 0x27, 0x90, 0x93, 0x4d, 0x20, 0xd7, 0x79, 0x4c, 0x7a, 0x1f, 0x5f, 0x3d, 0x84,
	0xb5, 0x30, 0x5b, 0xf2, 0x5a, 0xe4, 0xf5, 0x8f, 0xfe, 0x55, 0xb0, 0xee, 0x12, 0x5b, 0xd5, 0x75,
	0xf1, 0xfe, 0xca, 0x64, 0xa7, 0xfa, 0xb4, 0xd7, 0x05, 0xf9, 0xdd, 0xef, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x82, 0x22, 0x51, 0xba, 0xf9, 0x02, 0x00, 0x00,
}
