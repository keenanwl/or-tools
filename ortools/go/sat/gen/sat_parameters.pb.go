// Code generated by protoc-gen-go. DO NOT EDIT.
// source: ortools/sat/sat_parameters.proto

package gen

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Variables without activity (i.e. at the beginning of the search) will be
// tried in this preferred order.
type SatParameters_VariableOrder int32

const (
	SatParameters_IN_ORDER         SatParameters_VariableOrder = 0
	SatParameters_IN_REVERSE_ORDER SatParameters_VariableOrder = 1
	SatParameters_IN_RANDOM_ORDER  SatParameters_VariableOrder = 2
)

var SatParameters_VariableOrder_name = map[int32]string{
	0: "IN_ORDER",
	1: "IN_REVERSE_ORDER",
	2: "IN_RANDOM_ORDER",
}

var SatParameters_VariableOrder_value = map[string]int32{
	"IN_ORDER":         0,
	"IN_REVERSE_ORDER": 1,
	"IN_RANDOM_ORDER":  2,
}

func (x SatParameters_VariableOrder) Enum() *SatParameters_VariableOrder {
	p := new(SatParameters_VariableOrder)
	*p = x
	return p
}

func (x SatParameters_VariableOrder) String() string {
	return proto.EnumName(SatParameters_VariableOrder_name, int32(x))
}

func (x *SatParameters_VariableOrder) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SatParameters_VariableOrder_value, data, "SatParameters_VariableOrder")
	if err != nil {
		return err
	}
	*x = SatParameters_VariableOrder(value)
	return nil
}

func (SatParameters_VariableOrder) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c726f7f6ef83bf4, []int{0, 0}
}

// Specifies the initial polarity (true/false) when the solver branches on a
// variable. This can be modified later by the user, or the phase saving
// heuristic.
//
// Note(user): POLARITY_FALSE is usually a good choice because of the
// "natural" way to express a linear boolean problem.
type SatParameters_Polarity int32

const (
	SatParameters_POLARITY_TRUE   SatParameters_Polarity = 0
	SatParameters_POLARITY_FALSE  SatParameters_Polarity = 1
	SatParameters_POLARITY_RANDOM SatParameters_Polarity = 2
	// Choose the sign that tends to satisfy the most constraints. This is
	// computed using a weighted sum: if a literal l appears in a constraint of
	// the form: ... + coeff * l +... <= rhs with positive coefficients and
	// rhs, then -sign(l) * coeff / rhs is added to the weight of l.variable().
	SatParameters_POLARITY_WEIGHTED_SIGN SatParameters_Polarity = 3
	// The opposite choice of POLARITY_WEIGHTED_SIGN.
	SatParameters_POLARITY_REVERSE_WEIGHTED_SIGN SatParameters_Polarity = 4
)

var SatParameters_Polarity_name = map[int32]string{
	0: "POLARITY_TRUE",
	1: "POLARITY_FALSE",
	2: "POLARITY_RANDOM",
	3: "POLARITY_WEIGHTED_SIGN",
	4: "POLARITY_REVERSE_WEIGHTED_SIGN",
}

var SatParameters_Polarity_value = map[string]int32{
	"POLARITY_TRUE":                  0,
	"POLARITY_FALSE":                 1,
	"POLARITY_RANDOM":                2,
	"POLARITY_WEIGHTED_SIGN":         3,
	"POLARITY_REVERSE_WEIGHTED_SIGN": 4,
}

func (x SatParameters_Polarity) Enum() *SatParameters_Polarity {
	p := new(SatParameters_Polarity)
	*p = x
	return p
}

func (x SatParameters_Polarity) String() string {
	return proto.EnumName(SatParameters_Polarity_name, int32(x))
}

func (x *SatParameters_Polarity) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SatParameters_Polarity_value, data, "SatParameters_Polarity")
	if err != nil {
		return err
	}
	*x = SatParameters_Polarity(value)
	return nil
}

func (SatParameters_Polarity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c726f7f6ef83bf4, []int{0, 1}
}

// Do we try to minimize conflicts (greedily) when creating them.
type SatParameters_ConflictMinimizationAlgorithm int32

const (
	SatParameters_NONE         SatParameters_ConflictMinimizationAlgorithm = 0
	SatParameters_SIMPLE       SatParameters_ConflictMinimizationAlgorithm = 1
	SatParameters_RECURSIVE    SatParameters_ConflictMinimizationAlgorithm = 2
	SatParameters_EXPERIMENTAL SatParameters_ConflictMinimizationAlgorithm = 3
)

var SatParameters_ConflictMinimizationAlgorithm_name = map[int32]string{
	0: "NONE",
	1: "SIMPLE",
	2: "RECURSIVE",
	3: "EXPERIMENTAL",
}

var SatParameters_ConflictMinimizationAlgorithm_value = map[string]int32{
	"NONE":         0,
	"SIMPLE":       1,
	"RECURSIVE":    2,
	"EXPERIMENTAL": 3,
}

func (x SatParameters_ConflictMinimizationAlgorithm) Enum() *SatParameters_ConflictMinimizationAlgorithm {
	p := new(SatParameters_ConflictMinimizationAlgorithm)
	*p = x
	return p
}

func (x SatParameters_ConflictMinimizationAlgorithm) String() string {
	return proto.EnumName(SatParameters_ConflictMinimizationAlgorithm_name, int32(x))
}

func (x *SatParameters_ConflictMinimizationAlgorithm) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SatParameters_ConflictMinimizationAlgorithm_value, data, "SatParameters_ConflictMinimizationAlgorithm")
	if err != nil {
		return err
	}
	*x = SatParameters_ConflictMinimizationAlgorithm(value)
	return nil
}

func (SatParameters_ConflictMinimizationAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c726f7f6ef83bf4, []int{0, 2}
}

// Whether to expoit the binary clause to minimize learned clauses further.
// This will have an effect only if treat_binary_clauses_separately is true.
type SatParameters_BinaryMinizationAlgorithm int32

const (
	SatParameters_NO_BINARY_MINIMIZATION                              SatParameters_BinaryMinizationAlgorithm = 0
	SatParameters_BINARY_MINIMIZATION_FIRST                           SatParameters_BinaryMinizationAlgorithm = 1
	SatParameters_BINARY_MINIMIZATION_FIRST_WITH_TRANSITIVE_REDUCTION SatParameters_BinaryMinizationAlgorithm = 4
	SatParameters_BINARY_MINIMIZATION_WITH_REACHABILITY               SatParameters_BinaryMinizationAlgorithm = 2
	SatParameters_EXPERIMENTAL_BINARY_MINIMIZATION                    SatParameters_BinaryMinizationAlgorithm = 3
)

var SatParameters_BinaryMinizationAlgorithm_name = map[int32]string{
	0: "NO_BINARY_MINIMIZATION",
	1: "BINARY_MINIMIZATION_FIRST",
	4: "BINARY_MINIMIZATION_FIRST_WITH_TRANSITIVE_REDUCTION",
	2: "BINARY_MINIMIZATION_WITH_REACHABILITY",
	3: "EXPERIMENTAL_BINARY_MINIMIZATION",
}

var SatParameters_BinaryMinizationAlgorithm_value = map[string]int32{
	"NO_BINARY_MINIMIZATION":                              0,
	"BINARY_MINIMIZATION_FIRST":                           1,
	"BINARY_MINIMIZATION_FIRST_WITH_TRANSITIVE_REDUCTION": 4,
	"BINARY_MINIMIZATION_WITH_REACHABILITY":               2,
	"EXPERIMENTAL_BINARY_MINIMIZATION":                    3,
}

func (x SatParameters_BinaryMinizationAlgorithm) Enum() *SatParameters_BinaryMinizationAlgorithm {
	p := new(SatParameters_BinaryMinizationAlgorithm)
	*p = x
	return p
}

func (x SatParameters_BinaryMinizationAlgorithm) String() string {
	return proto.EnumName(SatParameters_BinaryMinizationAlgorithm_name, int32(x))
}

func (x *SatParameters_BinaryMinizationAlgorithm) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SatParameters_BinaryMinizationAlgorithm_value, data, "SatParameters_BinaryMinizationAlgorithm")
	if err != nil {
		return err
	}
	*x = SatParameters_BinaryMinizationAlgorithm(value)
	return nil
}

func (SatParameters_BinaryMinizationAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c726f7f6ef83bf4, []int{0, 3}
}

// Each time a clause activity is bumped, the clause has a chance to be
// protected during the next cleanup phase. Note that clauses used as a reason
// are always protected.
type SatParameters_ClauseProtection int32

const (
	SatParameters_PROTECTION_NONE   SatParameters_ClauseProtection = 0
	SatParameters_PROTECTION_ALWAYS SatParameters_ClauseProtection = 1
	SatParameters_PROTECTION_LBD    SatParameters_ClauseProtection = 2
)

var SatParameters_ClauseProtection_name = map[int32]string{
	0: "PROTECTION_NONE",
	1: "PROTECTION_ALWAYS",
	2: "PROTECTION_LBD",
}

var SatParameters_ClauseProtection_value = map[string]int32{
	"PROTECTION_NONE":   0,
	"PROTECTION_ALWAYS": 1,
	"PROTECTION_LBD":    2,
}

func (x SatParameters_ClauseProtection) Enum() *SatParameters_ClauseProtection {
	p := new(SatParameters_ClauseProtection)
	*p = x
	return p
}

func (x SatParameters_ClauseProtection) String() string {
	return proto.EnumName(SatParameters_ClauseProtection_name, int32(x))
}

func (x *SatParameters_ClauseProtection) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SatParameters_ClauseProtection_value, data, "SatParameters_ClauseProtection")
	if err != nil {
		return err
	}
	*x = SatParameters_ClauseProtection(value)
	return nil
}

func (SatParameters_ClauseProtection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c726f7f6ef83bf4, []int{0, 4}
}

// The clauses that will be kept during a cleanup are the ones that come
// first under this order. We always keep or exclude ties together.
type SatParameters_ClauseOrdering int32

const (
	// Order clause by decreasing activity, then by increasing LBD.
	SatParameters_CLAUSE_ACTIVITY SatParameters_ClauseOrdering = 0
	// Order clause by increasing LBD, then by decreasing activity.
	SatParameters_CLAUSE_LBD SatParameters_ClauseOrdering = 1
)

var SatParameters_ClauseOrdering_name = map[int32]string{
	0: "CLAUSE_ACTIVITY",
	1: "CLAUSE_LBD",
}

var SatParameters_ClauseOrdering_value = map[string]int32{
	"CLAUSE_ACTIVITY": 0,
	"CLAUSE_LBD":      1,
}

func (x SatParameters_ClauseOrdering) Enum() *SatParameters_ClauseOrdering {
	p := new(SatParameters_ClauseOrdering)
	*p = x
	return p
}

func (x SatParameters_ClauseOrdering) String() string {
	return proto.EnumName(SatParameters_ClauseOrdering_name, int32(x))
}

func (x *SatParameters_ClauseOrdering) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SatParameters_ClauseOrdering_value, data, "SatParameters_ClauseOrdering")
	if err != nil {
		return err
	}
	*x = SatParameters_ClauseOrdering(value)
	return nil
}

func (SatParameters_ClauseOrdering) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c726f7f6ef83bf4, []int{0, 5}
}

// Restart algorithms.
//
// A reference for the more advanced ones is:
// Gilles Audemard, Laurent Simon, "Refining Restarts Strategies for SAT
// and UNSAT", Principles and Practice of Constraint Programming Lecture
// Notes in Computer Science 2012, pp 118-126
type SatParameters_RestartAlgorithm int32

const (
	SatParameters_NO_RESTART SatParameters_RestartAlgorithm = 0
	// Just follow a Luby sequence times restart_period.
	SatParameters_LUBY_RESTART SatParameters_RestartAlgorithm = 1
	// Moving average restart based on the decision level of conflicts.
	SatParameters_DL_MOVING_AVERAGE_RESTART SatParameters_RestartAlgorithm = 2
	// Moving average restart based on the LBD of conflicts.
	SatParameters_LBD_MOVING_AVERAGE_RESTART SatParameters_RestartAlgorithm = 3
	// Fixed period restart every restart period.
	SatParameters_FIXED_RESTART SatParameters_RestartAlgorithm = 4
)

var SatParameters_RestartAlgorithm_name = map[int32]string{
	0: "NO_RESTART",
	1: "LUBY_RESTART",
	2: "DL_MOVING_AVERAGE_RESTART",
	3: "LBD_MOVING_AVERAGE_RESTART",
	4: "FIXED_RESTART",
}

var SatParameters_RestartAlgorithm_value = map[string]int32{
	"NO_RESTART":                 0,
	"LUBY_RESTART":               1,
	"DL_MOVING_AVERAGE_RESTART":  2,
	"LBD_MOVING_AVERAGE_RESTART": 3,
	"FIXED_RESTART":              4,
}

func (x SatParameters_RestartAlgorithm) Enum() *SatParameters_RestartAlgorithm {
	p := new(SatParameters_RestartAlgorithm)
	*p = x
	return p
}

func (x SatParameters_RestartAlgorithm) String() string {
	return proto.EnumName(SatParameters_RestartAlgorithm_name, int32(x))
}

func (x *SatParameters_RestartAlgorithm) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SatParameters_RestartAlgorithm_value, data, "SatParameters_RestartAlgorithm")
	if err != nil {
		return err
	}
	*x = SatParameters_RestartAlgorithm(value)
	return nil
}

func (SatParameters_RestartAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c726f7f6ef83bf4, []int{0, 6}
}

// In what order do we add the assumptions in a core-based max-sat algorithm
type SatParameters_MaxSatAssumptionOrder int32

const (
	SatParameters_DEFAULT_ASSUMPTION_ORDER   SatParameters_MaxSatAssumptionOrder = 0
	SatParameters_ORDER_ASSUMPTION_BY_DEPTH  SatParameters_MaxSatAssumptionOrder = 1
	SatParameters_ORDER_ASSUMPTION_BY_WEIGHT SatParameters_MaxSatAssumptionOrder = 2
)

var SatParameters_MaxSatAssumptionOrder_name = map[int32]string{
	0: "DEFAULT_ASSUMPTION_ORDER",
	1: "ORDER_ASSUMPTION_BY_DEPTH",
	2: "ORDER_ASSUMPTION_BY_WEIGHT",
}

var SatParameters_MaxSatAssumptionOrder_value = map[string]int32{
	"DEFAULT_ASSUMPTION_ORDER":   0,
	"ORDER_ASSUMPTION_BY_DEPTH":  1,
	"ORDER_ASSUMPTION_BY_WEIGHT": 2,
}

func (x SatParameters_MaxSatAssumptionOrder) Enum() *SatParameters_MaxSatAssumptionOrder {
	p := new(SatParameters_MaxSatAssumptionOrder)
	*p = x
	return p
}

func (x SatParameters_MaxSatAssumptionOrder) String() string {
	return proto.EnumName(SatParameters_MaxSatAssumptionOrder_name, int32(x))
}

func (x *SatParameters_MaxSatAssumptionOrder) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SatParameters_MaxSatAssumptionOrder_value, data, "SatParameters_MaxSatAssumptionOrder")
	if err != nil {
		return err
	}
	*x = SatParameters_MaxSatAssumptionOrder(value)
	return nil
}

func (SatParameters_MaxSatAssumptionOrder) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c726f7f6ef83bf4, []int{0, 7}
}

// What stratification algorithm we use in the presence of weight.
type SatParameters_MaxSatStratificationAlgorithm int32

const (
	// No stratification of the problem.
	SatParameters_STRATIFICATION_NONE SatParameters_MaxSatStratificationAlgorithm = 0
	// Start with literals with the highest weight, and when SAT, add the
	// literals with the next highest weight and so on.
	SatParameters_STRATIFICATION_DESCENT SatParameters_MaxSatStratificationAlgorithm = 1
	// Start with all literals. Each time a core is found with a given minimum
	// weight, do not consider literals with a lower weight for the next core
	// computation. If the subproblem is SAT, do like in STRATIFICATION_DESCENT
	// and just add the literals with the next highest weight.
	SatParameters_STRATIFICATION_ASCENT SatParameters_MaxSatStratificationAlgorithm = 2
)

var SatParameters_MaxSatStratificationAlgorithm_name = map[int32]string{
	0: "STRATIFICATION_NONE",
	1: "STRATIFICATION_DESCENT",
	2: "STRATIFICATION_ASCENT",
}

var SatParameters_MaxSatStratificationAlgorithm_value = map[string]int32{
	"STRATIFICATION_NONE":    0,
	"STRATIFICATION_DESCENT": 1,
	"STRATIFICATION_ASCENT":  2,
}

func (x SatParameters_MaxSatStratificationAlgorithm) Enum() *SatParameters_MaxSatStratificationAlgorithm {
	p := new(SatParameters_MaxSatStratificationAlgorithm)
	*p = x
	return p
}

func (x SatParameters_MaxSatStratificationAlgorithm) String() string {
	return proto.EnumName(SatParameters_MaxSatStratificationAlgorithm_name, int32(x))
}

func (x *SatParameters_MaxSatStratificationAlgorithm) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SatParameters_MaxSatStratificationAlgorithm_value, data, "SatParameters_MaxSatStratificationAlgorithm")
	if err != nil {
		return err
	}
	*x = SatParameters_MaxSatStratificationAlgorithm(value)
	return nil
}

func (SatParameters_MaxSatStratificationAlgorithm) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c726f7f6ef83bf4, []int{0, 8}
}

// The search branching will be used to decide how to branch on unfixed nodes.
type SatParameters_SearchBranching int32

const (
	// Try to fix all literals using the underlying SAT solver's heuristics,
	// then generate and fix literals until integer variables are fixed.
	SatParameters_AUTOMATIC_SEARCH SatParameters_SearchBranching = 0
	// If used then all decisions taken by the solver are made using a fixed
	// order as specified in the API or in the CpModelProto search_strategy
	// field.
	SatParameters_FIXED_SEARCH SatParameters_SearchBranching = 1
	// If used, the solver will use various generic heuristics in turn.
	SatParameters_PORTFOLIO_SEARCH SatParameters_SearchBranching = 2
	// If used, the solver will use heuristics from the LP relaxation. This
	// exploit the reduced costs of the variables in the relaxation.
	//
	// TODO(user): Maybe rename REDUCED_COST_SEARCH?
	SatParameters_LP_SEARCH SatParameters_SearchBranching = 3
	// If used, the solver uses the pseudo costs for branching. Pseudo costs
	// are computed using the historical change in objective bounds when some
	// decision are taken.
	SatParameters_PSEUDO_COST_SEARCH SatParameters_SearchBranching = 4
	// Mainly exposed here for testing. This quickly tries a lot of randomized
	// heuristics with a low conflict limit. It usually provides a good first
	// solution.
	SatParameters_PORTFOLIO_WITH_QUICK_RESTART_SEARCH SatParameters_SearchBranching = 5
	// Mainly used internally. This is like FIXED_SEARCH, except we follow the
	// solution_hint field of the CpModelProto rather than using the information
	// provided in the search_strategy.
	SatParameters_HINT_SEARCH SatParameters_SearchBranching = 6
)

var SatParameters_SearchBranching_name = map[int32]string{
	0: "AUTOMATIC_SEARCH",
	1: "FIXED_SEARCH",
	2: "PORTFOLIO_SEARCH",
	3: "LP_SEARCH",
	4: "PSEUDO_COST_SEARCH",
	5: "PORTFOLIO_WITH_QUICK_RESTART_SEARCH",
	6: "HINT_SEARCH",
}

var SatParameters_SearchBranching_value = map[string]int32{
	"AUTOMATIC_SEARCH":                    0,
	"FIXED_SEARCH":                        1,
	"PORTFOLIO_SEARCH":                    2,
	"LP_SEARCH":                           3,
	"PSEUDO_COST_SEARCH":                  4,
	"PORTFOLIO_WITH_QUICK_RESTART_SEARCH": 5,
	"HINT_SEARCH":                         6,
}

func (x SatParameters_SearchBranching) Enum() *SatParameters_SearchBranching {
	p := new(SatParameters_SearchBranching)
	*p = x
	return p
}

func (x SatParameters_SearchBranching) String() string {
	return proto.EnumName(SatParameters_SearchBranching_name, int32(x))
}

func (x *SatParameters_SearchBranching) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SatParameters_SearchBranching_value, data, "SatParameters_SearchBranching")
	if err != nil {
		return err
	}
	*x = SatParameters_SearchBranching(value)
	return nil
}

func (SatParameters_SearchBranching) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c726f7f6ef83bf4, []int{0, 9}
}

// Rounding method to use for feasibility pump.
type SatParameters_FPRoundingMethod int32

const (
	// Rounds to the nearest integer value.
	SatParameters_NEAREST_INTEGER SatParameters_FPRoundingMethod = 0
	// Counts the number of linear constraints restricting the variable in the
	// increasing values (up locks) and decreasing values (down locks). Rounds
	// the variable in the direction of lesser locks.
	SatParameters_LOCK_BASED SatParameters_FPRoundingMethod = 1
	// Similar to lock based rounding except this only considers locks of active
	// constraints from the last lp solve.
	SatParameters_ACTIVE_LOCK_BASED SatParameters_FPRoundingMethod = 3
	// This is expensive rounding algorithm. We round variables one by one and
	// propagate the bounds in between. If none of the rounded values fall in
	// the continuous domain specified by lower and upper bound, we use the
	// current lower/upper bound (whichever one is closest) instead of rounding
	// the fractional lp solution value. If both the rounded values are in the
	// domain, we round to nearest integer.
	SatParameters_PROPAGATION_ASSISTED SatParameters_FPRoundingMethod = 2
)

var SatParameters_FPRoundingMethod_name = map[int32]string{
	0: "NEAREST_INTEGER",
	1: "LOCK_BASED",
	3: "ACTIVE_LOCK_BASED",
	2: "PROPAGATION_ASSISTED",
}

var SatParameters_FPRoundingMethod_value = map[string]int32{
	"NEAREST_INTEGER":      0,
	"LOCK_BASED":           1,
	"ACTIVE_LOCK_BASED":    3,
	"PROPAGATION_ASSISTED": 2,
}

func (x SatParameters_FPRoundingMethod) Enum() *SatParameters_FPRoundingMethod {
	p := new(SatParameters_FPRoundingMethod)
	*p = x
	return p
}

func (x SatParameters_FPRoundingMethod) String() string {
	return proto.EnumName(SatParameters_FPRoundingMethod_name, int32(x))
}

func (x *SatParameters_FPRoundingMethod) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(SatParameters_FPRoundingMethod_value, data, "SatParameters_FPRoundingMethod")
	if err != nil {
		return err
	}
	*x = SatParameters_FPRoundingMethod(value)
	return nil
}

func (SatParameters_FPRoundingMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c726f7f6ef83bf4, []int{0, 10}
}

// Contains the definitions for all the sat algorithm parameters and their
// default values.
//
// NEXT TAG: 167
type SatParameters struct {
	PreferredVariableOrder *SatParameters_VariableOrder `protobuf:"varint,1,opt,name=preferred_variable_order,json=preferredVariableOrder,enum=operations_research.sat.SatParameters_VariableOrder,def=0" json:"preferred_variable_order,omitempty"`
	InitialPolarity        *SatParameters_Polarity      `protobuf:"varint,2,opt,name=initial_polarity,json=initialPolarity,enum=operations_research.sat.SatParameters_Polarity,def=1" json:"initial_polarity,omitempty"`
	// If this is true, then the polarity of a variable will be the last value it
	// was assigned to, or its default polarity if it was never assigned since the
	// call to ResetDecisionHeuristic().
	//
	// This is called 'literal phase saving'. For details see 'A Lightweight
	// Component Caching Scheme for Satisfiability Solvers' K. Pipatsrisawat and
	// A.Darwiche, In 10th International Conference on Theory and Applications of
	// Satisfiability Testing, 2007.
	UsePhaseSaving *bool `protobuf:"varint,44,opt,name=use_phase_saving,json=usePhaseSaving,def=1" json:"use_phase_saving,omitempty"`
	// The proportion of polarity chosen at random. Note that this take
	// precedence over the phase saving heuristic. This is different from
	// initial_polarity:POLARITY_RANDOM because it will select a new random
	// polarity each time the variable is branched upon instead of selecting one
	// initially and then always taking this choice.
	RandomPolarityRatio *float64 `protobuf:"fixed64,45,opt,name=random_polarity_ratio,json=randomPolarityRatio,def=0" json:"random_polarity_ratio,omitempty"`
	// A number between 0 and 1 that indicates the proportion of branching
	// variables that are selected randomly instead of choosing the first variable
	// from the given variable_ordering strategy.
	RandomBranchesRatio *float64 `protobuf:"fixed64,32,opt,name=random_branches_ratio,json=randomBranchesRatio,def=0" json:"random_branches_ratio,omitempty"`
	// Whether we use the ERWA (Exponential Recency Weighted Average) heuristic as
	// described in "Learning Rate Based Branching Heuristic for SAT solvers",
	// J.H.Liang, V. Ganesh, P. Poupart, K.Czarnecki, SAT 2016.
	UseErwaHeuristic *bool `protobuf:"varint,75,opt,name=use_erwa_heuristic,json=useErwaHeuristic,def=0" json:"use_erwa_heuristic,omitempty"`
	// The initial value of the variables activity. A non-zero value only make
	// sense when use_erwa_heuristic is true. Experiments with a value of 1e-2
	// together with the ERWA heuristic showed slighthly better result than simply
	// using zero. The idea is that when the "learning rate" of a variable becomes
	// lower than this value, then we prefer to branch on never explored before
	// variables. This is not in the ERWA paper.
	InitialVariablesActivity *float64 `protobuf:"fixed64,76,opt,name=initial_variables_activity,json=initialVariablesActivity,def=0" json:"initial_variables_activity,omitempty"`
	// When this is true, then the variables that appear in any of the reason of
	// the variables in a conflict have their activity bumped. This is addition to
	// the variables in the conflict, and the one that were used during conflict
	// resolution.
	AlsoBumpVariablesInConflictReasons *bool                                        `protobuf:"varint,77,opt,name=also_bump_variables_in_conflict_reasons,json=alsoBumpVariablesInConflictReasons,def=0" json:"also_bump_variables_in_conflict_reasons,omitempty"`
	MinimizationAlgorithm              *SatParameters_ConflictMinimizationAlgorithm `protobuf:"varint,4,opt,name=minimization_algorithm,json=minimizationAlgorithm,enum=operations_research.sat.SatParameters_ConflictMinimizationAlgorithm,def=2" json:"minimization_algorithm,omitempty"`
	BinaryMinimizationAlgorithm        *SatParameters_BinaryMinizationAlgorithm     `protobuf:"varint,34,opt,name=binary_minimization_algorithm,json=binaryMinimizationAlgorithm,enum=operations_research.sat.SatParameters_BinaryMinizationAlgorithm,def=1" json:"binary_minimization_algorithm,omitempty"`
	// At a really low cost, during the 1-UIP conflict computation, it is easy to
	// detect if some of the involved reasons are subsumed by the current
	// conflict. When this is true, such clauses are detached and later removed
	// from the problem.
	SubsumptionDuringConflictAnalysis *bool `protobuf:"varint,56,opt,name=subsumption_during_conflict_analysis,json=subsumptionDuringConflictAnalysis,def=1" json:"subsumption_during_conflict_analysis,omitempty"`
	// Trigger a cleanup when this number of "deletable" clauses is learned.
	ClauseCleanupPeriod *int32 `protobuf:"varint,11,opt,name=clause_cleanup_period,json=clauseCleanupPeriod,def=10000" json:"clause_cleanup_period,omitempty"`
	// During a cleanup, we will always keep that number of "deletable" clauses.
	// Note that this doesn't include the "protected" clauses.
	ClauseCleanupTarget     *int32                          `protobuf:"varint,13,opt,name=clause_cleanup_target,json=clauseCleanupTarget,def=10000" json:"clause_cleanup_target,omitempty"`
	ClauseCleanupProtection *SatParameters_ClauseProtection `protobuf:"varint,58,opt,name=clause_cleanup_protection,json=clauseCleanupProtection,enum=operations_research.sat.SatParameters_ClauseProtection,def=0" json:"clause_cleanup_protection,omitempty"`
	// All the clauses with a LBD (literal blocks distance) lower or equal to this
	// parameters will always be kept.
	ClauseCleanupLbdBound *int32                        `protobuf:"varint,59,opt,name=clause_cleanup_lbd_bound,json=clauseCleanupLbdBound,def=5" json:"clause_cleanup_lbd_bound,omitempty"`
	ClauseCleanupOrdering *SatParameters_ClauseOrdering `protobuf:"varint,60,opt,name=clause_cleanup_ordering,json=clauseCleanupOrdering,enum=operations_research.sat.SatParameters_ClauseOrdering,def=0" json:"clause_cleanup_ordering,omitempty"`
	// Same as for the clauses, but for the learned pseudo-Boolean constraints.
	PbCleanupIncrement *int32   `protobuf:"varint,46,opt,name=pb_cleanup_increment,json=pbCleanupIncrement,def=200" json:"pb_cleanup_increment,omitempty"`
	PbCleanupRatio     *float64 `protobuf:"fixed64,47,opt,name=pb_cleanup_ratio,json=pbCleanupRatio,def=0.5" json:"pb_cleanup_ratio,omitempty"`
	// Parameters for an heuristic similar to the one descibed in "An effective
	// learnt clause minimization approach for CDCL Sat Solvers",
	// https://www.ijcai.org/proceedings/2017/0098.pdf
	//
	// For now, we have a somewhat simpler implementation where every x restart we
	// spend y decisions on clause minimization. The minimization technique is the
	// same as the one used to minimize core in max-sat. We also minimize problem
	// clauses and not just the learned clause that we keep forever like in the
	// paper.
	//
	// Changing these parameters or the kind of clause we minimize seems to have
	// a big impact on the overall perf on our benchmarks. So this technique seems
	// definitely useful, but it is hard to tune properly.
	MinimizeWithPropagationRestartPeriod *int32 `protobuf:"varint,96,opt,name=minimize_with_propagation_restart_period,json=minimizeWithPropagationRestartPeriod,def=10" json:"minimize_with_propagation_restart_period,omitempty"`
	MinimizeWithPropagationNumDecisions  *int32 `protobuf:"varint,97,opt,name=minimize_with_propagation_num_decisions,json=minimizeWithPropagationNumDecisions,def=1000" json:"minimize_with_propagation_num_decisions,omitempty"`
	// Each time a conflict is found, the activities of some variables are
	// increased by one. Then, the activity of all variables are multiplied by
	// variable_activity_decay.
	//
	// To implement this efficiently, the activity of all the variables is not
	// decayed at each conflict. Instead, the activity increment is multiplied by
	// 1 / decay. When an activity reach max_variable_activity_value, all the
	// activity are multiplied by 1 / max_variable_activity_value.
	VariableActivityDecay    *float64 `protobuf:"fixed64,15,opt,name=variable_activity_decay,json=variableActivityDecay,def=0.8" json:"variable_activity_decay,omitempty"`
	MaxVariableActivityValue *float64 `protobuf:"fixed64,16,opt,name=max_variable_activity_value,json=maxVariableActivityValue,def=1e+100" json:"max_variable_activity_value,omitempty"`
	// The activity starts at 0.8 and increment by 0.01 every 5000 conflicts until
	// 0.95. This "hack" seems to work well and comes from:
	//
	// Glucose 2.3 in the SAT 2013 Competition - SAT Competition 2013
	// http://edacc4.informatik.uni-ulm.de/SC13/solver-description-download/136
	GlucoseMaxDecay             *float64 `protobuf:"fixed64,22,opt,name=glucose_max_decay,json=glucoseMaxDecay,def=0.95" json:"glucose_max_decay,omitempty"`
	GlucoseDecayIncrement       *float64 `protobuf:"fixed64,23,opt,name=glucose_decay_increment,json=glucoseDecayIncrement,def=0.01" json:"glucose_decay_increment,omitempty"`
	GlucoseDecayIncrementPeriod *int32   `protobuf:"varint,24,opt,name=glucose_decay_increment_period,json=glucoseDecayIncrementPeriod,def=5000" json:"glucose_decay_increment_period,omitempty"`
	// Clause activity parameters (same effect as the one on the variables).
	ClauseActivityDecay    *float64 `protobuf:"fixed64,17,opt,name=clause_activity_decay,json=clauseActivityDecay,def=0.999" json:"clause_activity_decay,omitempty"`
	MaxClauseActivityValue *float64 `protobuf:"fixed64,18,opt,name=max_clause_activity_value,json=maxClauseActivityValue,def=1e+20" json:"max_clause_activity_value,omitempty"`
	// The restart strategies will change each time the strategy_counter is
	// increased. The current strategy will simply be the one at index
	// strategy_counter modulo the number of strategy. Note that if this list
	// includes a NO_RESTART, nothing will change when it is reached because the
	// strategy_counter will only increment after a restart.
	//
	// The idea of switching of search strategy tailored for SAT/UNSAT comes from
	// Chanseok Oh with his COMiniSatPS solver, see http://cs.nyu.edu/~chanseok/.
	// But more generally, it seems REALLY beneficial to try different strategy.
	RestartAlgorithms        []SatParameters_RestartAlgorithm `protobuf:"varint,61,rep,name=restart_algorithms,json=restartAlgorithms,enum=operations_research.sat.SatParameters_RestartAlgorithm" json:"restart_algorithms,omitempty"`
	DefaultRestartAlgorithms *string                          `protobuf:"bytes,70,opt,name=default_restart_algorithms,json=defaultRestartAlgorithms,def=LUBY_RESTART,LBD_MOVING_AVERAGE_RESTART,DL_MOVING_AVERAGE_RESTART" json:"default_restart_algorithms,omitempty"`
	// Restart period for the FIXED_RESTART strategy. This is also the multiplier
	// used by the LUBY_RESTART strategy.
	RestartPeriod *int32 `protobuf:"varint,30,opt,name=restart_period,json=restartPeriod,def=50" json:"restart_period,omitempty"`
	// Size of the window for the moving average restarts.
	RestartRunningWindowSize *int32 `protobuf:"varint,62,opt,name=restart_running_window_size,json=restartRunningWindowSize,def=50" json:"restart_running_window_size,omitempty"`
	// In the moving average restart algorithms, a restart is triggered if the
	// window average times this ratio is greater that the global average.
	RestartDlAverageRatio  *float64 `protobuf:"fixed64,63,opt,name=restart_dl_average_ratio,json=restartDlAverageRatio,def=1" json:"restart_dl_average_ratio,omitempty"`
	RestartLbdAverageRatio *float64 `protobuf:"fixed64,71,opt,name=restart_lbd_average_ratio,json=restartLbdAverageRatio,def=1" json:"restart_lbd_average_ratio,omitempty"`
	// Block a moving restart algorithm if the trail size of the current conflict
	// is greater than the multiplier times the moving average of the trail size
	// at the previous conflicts.
	UseBlockingRestart        *bool    `protobuf:"varint,64,opt,name=use_blocking_restart,json=useBlockingRestart,def=0" json:"use_blocking_restart,omitempty"`
	BlockingRestartWindowSize *int32   `protobuf:"varint,65,opt,name=blocking_restart_window_size,json=blockingRestartWindowSize,def=5000" json:"blocking_restart_window_size,omitempty"`
	BlockingRestartMultiplier *float64 `protobuf:"fixed64,66,opt,name=blocking_restart_multiplier,json=blockingRestartMultiplier,def=1.4" json:"blocking_restart_multiplier,omitempty"`
	// After each restart, if the number of conflict since the last strategy
	// change is greater that this, then we increment a "strategy_counter" that
	// can be use to change the search strategy used by the following restarts.
	NumConflictsBeforeStrategyChanges *int32 `protobuf:"varint,68,opt,name=num_conflicts_before_strategy_changes,json=numConflictsBeforeStrategyChanges,def=0" json:"num_conflicts_before_strategy_changes,omitempty"`
	// The parameter num_conflicts_before_strategy_changes is increased by that
	// much after each strategy change.
	StrategyChangeIncreaseRatio *float64 `protobuf:"fixed64,69,opt,name=strategy_change_increase_ratio,json=strategyChangeIncreaseRatio,def=0" json:"strategy_change_increase_ratio,omitempty"`
	// Maximum time allowed in seconds to solve a problem.
	// The counter will starts at the beginning of the Solve() call.
	MaxTimeInSeconds *float64 `protobuf:"fixed64,36,opt,name=max_time_in_seconds,json=maxTimeInSeconds,def=inf" json:"max_time_in_seconds,omitempty"`
	// Maximum time allowed in deterministic time to solve a problem.
	// The deterministic time should be correlated with the real time used by the
	// solver, the time unit being as close as possible to a second.
	MaxDeterministicTime *float64 `protobuf:"fixed64,67,opt,name=max_deterministic_time,json=maxDeterministicTime,def=inf" json:"max_deterministic_time,omitempty"`
	// Maximum number of conflicts allowed to solve a problem.
	//
	// TODO(user,user): Maybe change the way the conflict limit is enforced?
	// currently it is enforced on each independent internal SAT solve, rather
	// than on the overall number of conflicts across all solves. So in the
	// context of an optimization problem, this is not really usable directly by a
	// client.
	MaxNumberOfConflicts *int64 `protobuf:"varint,37,opt,name=max_number_of_conflicts,json=maxNumberOfConflicts,def=9223372036854775807" json:"max_number_of_conflicts,omitempty"`
	// Maximum memory allowed for the whole thread containing the solver. The
	// solver will abort as soon as it detects that this limit is crossed. As a
	// result, this limit is approximative, but usually the solver will not go too
	// much over.
	MaxMemoryInMb *int64 `protobuf:"varint,40,opt,name=max_memory_in_mb,json=maxMemoryInMb,def=10000" json:"max_memory_in_mb,omitempty"`
	// Stop the search when the gap between the best feasible objective (O) and
	// our best objective bound (B) is smaller than a limit.
	// The exact definition is:
	// - Absolute: abs(O - B)
	// - Relative: abs(O - B) / max(1, abs(O)).
	//
	// Important: The relative gap depends on the objective offset! If you
	// artificially shift the objective, you will get widely different value of
	// the relative gap.
	//
	// Note that if the gap is reached, the search status will be OPTIMAL. But
	// one can check the best objective bound to see the actual gap.
	AbsoluteGapLimit *float64 `protobuf:"fixed64,159,opt,name=absolute_gap_limit,json=absoluteGapLimit,def=0" json:"absolute_gap_limit,omitempty"`
	RelativeGapLimit *float64 `protobuf:"fixed64,160,opt,name=relative_gap_limit,json=relativeGapLimit,def=0" json:"relative_gap_limit,omitempty"`
	// If true, the binary clauses are treated separately from the others. This
	// should be faster and uses less memory. However it changes the propagation
	// order.
	TreatBinaryClausesSeparately *bool `protobuf:"varint,33,opt,name=treat_binary_clauses_separately,json=treatBinaryClausesSeparately,def=1" json:"treat_binary_clauses_separately,omitempty"`
	// At the beginning of each solve, the random number generator used in some
	// part of the solver is reinitialized to this seed. If you change the random
	// seed, the solver may make different choices during the solving process.
	//
	// For some problems, the running time may vary a lot depending on small
	// change in the solving algorithm. Running the solver with different seeds
	// enables to have more robust benchmarks when evaluating new features.
	RandomSeed *int32 `protobuf:"varint,31,opt,name=random_seed,json=randomSeed,def=1" json:"random_seed,omitempty"`
	// Whether the solver should log the search progress to LOG(INFO).
	LogSearchProgress *bool `protobuf:"varint,41,opt,name=log_search_progress,json=logSearchProgress,def=0" json:"log_search_progress,omitempty"`
	// Whether to use pseudo-Boolean resolution to analyze a conflict. Note that
	// this option only make sense if your problem is modelized using
	// pseudo-Boolean constraints. If you only have clauses, this shouldn't change
	// anything (except slow the solver down).
	UsePbResolution *bool `protobuf:"varint,43,opt,name=use_pb_resolution,json=usePbResolution,def=0" json:"use_pb_resolution,omitempty"`
	// A different algorithm during PB resolution. It minimizes the number of
	// calls to ReduceCoefficients() which can be time consuming. However, the
	// search space will be different and if the coefficients are large, this may
	// lead to integer overflows that could otherwise be prevented.
	MinimizeReductionDuringPbResolution *bool `protobuf:"varint,48,opt,name=minimize_reduction_during_pb_resolution,json=minimizeReductionDuringPbResolution,def=0" json:"minimize_reduction_during_pb_resolution,omitempty"`
	// Whether or not the assumption levels are taken into account during the LBD
	// computation. According to the reference below, not counting them improves
	// the solver in some situation. Note that this only impact solves under
	// assumptions.
	//
	// Gilles Audemard, Jean-Marie Lagniez, Laurent Simon, "Improving Glucose for
	// Incremental SAT Solving with Assumptions: Application to MUS Extraction"
	// Theory and Applications of Satisfiability Testing - SAT 2013, Lecture Notes
	// in Computer Science Volume 7962, 2013, pp 309-317.
	CountAssumptionLevelsInLbd *bool `protobuf:"varint,49,opt,name=count_assumption_levels_in_lbd,json=countAssumptionLevelsInLbd,def=1" json:"count_assumption_levels_in_lbd,omitempty"`
	// During presolve, only try to perform the bounded variable elimination (BVE)
	// of a variable x if the number of occurrences of x times the number of
	// occurrences of not(x) is not greater than this parameter.
	PresolveBveThreshold *int32 `protobuf:"varint,54,opt,name=presolve_bve_threshold,json=presolveBveThreshold,def=500" json:"presolve_bve_threshold,omitempty"`
	// During presolve, we apply BVE only if this weight times the number of
	// clauses plus the number of clause literals is not increased.
	PresolveBveClauseWeight *int32 `protobuf:"varint,55,opt,name=presolve_bve_clause_weight,json=presolveBveClauseWeight,def=3" json:"presolve_bve_clause_weight,omitempty"`
	// The maximum "deterministic" time limit to spend in probing. A value of
	// zero will disable the probing.
	PresolveProbingDeterministicTimeLimit *float64 `protobuf:"fixed64,57,opt,name=presolve_probing_deterministic_time_limit,json=presolveProbingDeterministicTimeLimit,def=30" json:"presolve_probing_deterministic_time_limit,omitempty"`
	// Whether we use an heuristic to detect some basic case of blocked clause
	// in the SAT presolve.
	PresolveBlockedClause *bool `protobuf:"varint,88,opt,name=presolve_blocked_clause,json=presolveBlockedClause,def=1" json:"presolve_blocked_clause,omitempty"`
	// Whether or not we use Bounded Variable Addition (BVA) in the presolve.
	PresolveUseBva *bool `protobuf:"varint,72,opt,name=presolve_use_bva,json=presolveUseBva,def=1" json:"presolve_use_bva,omitempty"`
	// Apply Bounded Variable Addition (BVA) if the number of clauses is reduced
	// by stricly more than this threshold. The algorithm described in the paper
	// uses 0, but quick experiments showed that 1 is a good value. It may not be
	// worth it to add a new variable just to remove one clause.
	PresolveBvaThreshold *int32 `protobuf:"varint,73,opt,name=presolve_bva_threshold,json=presolveBvaThreshold,def=1" json:"presolve_bva_threshold,omitempty"`
	// In case of large reduction in a presolve iteration, we perform multiple
	// presolve iterations. This parameter controls the maximum number of such
	// presolve iterations.
	MaxPresolveIterations *int32 `protobuf:"varint,138,opt,name=max_presolve_iterations,json=maxPresolveIterations,def=3" json:"max_presolve_iterations,omitempty"`
	// Whether we presolve the cp_model before solving it.
	CpModelPresolve *bool `protobuf:"varint,86,opt,name=cp_model_presolve,json=cpModelPresolve,def=1" json:"cp_model_presolve,omitempty"`
	// Advanced usage. We have two different postsolve code. The default one
	// should be better and it allows for a more powerful presolve, but some
	// rarely used features like not fully assigning all variables require the
	// other one.
	CpModelPostsolveWithFullSolver *bool `protobuf:"varint,162,opt,name=cp_model_postsolve_with_full_solver,json=cpModelPostsolveWithFullSolver,def=0" json:"cp_model_postsolve_with_full_solver,omitempty"`
	// If positive, try to stop just after that many presolve rules have been
	// applied. This is mainly useful for debugging presolve.
	CpModelMaxNumPresolveOperations *int32 `protobuf:"varint,151,opt,name=cp_model_max_num_presolve_operations,json=cpModelMaxNumPresolveOperations,def=0" json:"cp_model_max_num_presolve_operations,omitempty"`
	// How much effort do we spend on probing. 0 disables it completely.
	CpModelProbingLevel *int32 `protobuf:"varint,110,opt,name=cp_model_probing_level,json=cpModelProbingLevel,def=2" json:"cp_model_probing_level,omitempty"`
	// Whether we also use the sat presolve when cp_model_presolve is true.
	CpModelUseSatPresolve *bool `protobuf:"varint,93,opt,name=cp_model_use_sat_presolve,json=cpModelUseSatPresolve,def=1" json:"cp_model_use_sat_presolve,omitempty"`
	UseSatInprocessing    *bool `protobuf:"varint,163,opt,name=use_sat_inprocessing,json=useSatInprocessing,def=0" json:"use_sat_inprocessing,omitempty"`
	// If true, the element constraints are expanded into many
	// linear constraints of the form (index == i) => (element[i] == target).
	ExpandElementConstraints *bool `protobuf:"varint,140,opt,name=expand_element_constraints,json=expandElementConstraints,def=1" json:"expand_element_constraints,omitempty"`
	// If true, the automaton constraints are expanded.
	ExpandAutomatonConstraints *bool `protobuf:"varint,143,opt,name=expand_automaton_constraints,json=expandAutomatonConstraints,def=1" json:"expand_automaton_constraints,omitempty"`
	// If true, the positive table constraints are expanded.
	// Note that currently, negative table constraints are always expanded.
	ExpandTableConstraints *bool `protobuf:"varint,158,opt,name=expand_table_constraints,json=expandTableConstraints,def=1" json:"expand_table_constraints,omitempty"`
	// During presolve, we use a maximum clique heuristic to merge together
	// no-overlap constraints or at most one constraints. This code can be slow,
	// so we have a limit in place on the number of explored nodes in the
	// underlying graph. The internal limit is an int64, but we use double here to
	// simplify manual input.
	MergeNoOverlapWorkLimit *float64 `protobuf:"fixed64,145,opt,name=merge_no_overlap_work_limit,json=mergeNoOverlapWorkLimit,def=1e+12" json:"merge_no_overlap_work_limit,omitempty"`
	MergeAtMostOneWorkLimit *float64 `protobuf:"fixed64,146,opt,name=merge_at_most_one_work_limit,json=mergeAtMostOneWorkLimit,def=1e+08" json:"merge_at_most_one_work_limit,omitempty"`
	// How much substitution (also called free variable aggregation in MIP
	// litterature) should we perform at presolve. This currently only concerns
	// variable appearing only in linear constraints. For now the value 0 turns it
	// off and any positive value performs substitution.
	PresolveSubstitutionLevel *int32 `protobuf:"varint,147,opt,name=presolve_substitution_level,json=presolveSubstitutionLevel,def=1" json:"presolve_substitution_level,omitempty"`
	// For an optimization problem, whether we follow some hints in order to find
	// a better first solution. For a variable with hint, the solver will always
	// try to follow the hint. It will revert to the variable_branching default
	// otherwise.
	UseOptimizationHints *bool `protobuf:"varint,35,opt,name=use_optimization_hints,json=useOptimizationHints,def=1" json:"use_optimization_hints,omitempty"`
	// Whether we use a simple heuristic to try to minimize an UNSAT core.
	MinimizeCore *bool `protobuf:"varint,50,opt,name=minimize_core,json=minimizeCore,def=1" json:"minimize_core,omitempty"`
	// Whether we try to find more independent cores for a given set of
	// assumptions in the core based max-SAT algorithms.
	FindMultipleCores *bool `protobuf:"varint,84,opt,name=find_multiple_cores,json=findMultipleCores,def=1" json:"find_multiple_cores,omitempty"`
	// If true, when the max-sat algo find a core, we compute the minimal number
	// of literals in the core that needs to be true to have a feasible solution.
	CoverOptimization     *bool                                `protobuf:"varint,89,opt,name=cover_optimization,json=coverOptimization,def=1" json:"cover_optimization,omitempty"`
	MaxSatAssumptionOrder *SatParameters_MaxSatAssumptionOrder `protobuf:"varint,51,opt,name=max_sat_assumption_order,json=maxSatAssumptionOrder,enum=operations_research.sat.SatParameters_MaxSatAssumptionOrder,def=0" json:"max_sat_assumption_order,omitempty"`
	// If true, adds the assumption in the reverse order of the one defined by
	// max_sat_assumption_order.
	MaxSatReverseAssumptionOrder *bool                                        `protobuf:"varint,52,opt,name=max_sat_reverse_assumption_order,json=maxSatReverseAssumptionOrder,def=0" json:"max_sat_reverse_assumption_order,omitempty"`
	MaxSatStratification         *SatParameters_MaxSatStratificationAlgorithm `protobuf:"varint,53,opt,name=max_sat_stratification,json=maxSatStratification,enum=operations_research.sat.SatParameters_MaxSatStratificationAlgorithm,def=1" json:"max_sat_stratification,omitempty"`
	// When this is true, then a disjunctive constraint will try to use the
	// precedence relations between time intervals to propagate their bounds
	// further. For instance if task A and B are both before C and task A and B
	// are in disjunction, then we can deduce that task C must start after
	// duration(A) + duration(B) instead of simply max(duration(A), duration(B)),
	// provided that the start time for all task was currently zero.
	//
	// This always result in better propagation, but it is usually slow, so
	// depending on the problem, turning this off may lead to a faster solution.
	UsePrecedencesInDisjunctiveConstraint *bool `protobuf:"varint,74,opt,name=use_precedences_in_disjunctive_constraint,json=usePrecedencesInDisjunctiveConstraint,def=1" json:"use_precedences_in_disjunctive_constraint,omitempty"`
	// When this is true, the cumulative constraint is reinforced with overload
	// checking, i.e., an additional level of reasoning based on energy. This
	// additional level supplements the default level of reasoning as well as
	// timetable edge finding.
	//
	// This always result in better propagation, but it is usually slow, so
	// depending on the problem, turning this off may lead to a faster solution.
	UseOverloadCheckerInCumulativeConstraint *bool `protobuf:"varint,78,opt,name=use_overload_checker_in_cumulative_constraint,json=useOverloadCheckerInCumulativeConstraint,def=0" json:"use_overload_checker_in_cumulative_constraint,omitempty"`
	// When this is true, the cumulative constraint is reinforced with timetable
	// edge finding, i.e., an additional level of reasoning based on the
	// conjunction of energy and mandatory parts. This additional level
	// supplements the default level of reasoning as well as overload_checker.
	//
	// This always result in better propagation, but it is usually slow, so
	// depending on the problem, turning this off may lead to a faster solution.
	UseTimetableEdgeFindingInCumulativeConstraint *bool `protobuf:"varint,79,opt,name=use_timetable_edge_finding_in_cumulative_constraint,json=useTimetableEdgeFindingInCumulativeConstraint,def=0" json:"use_timetable_edge_finding_in_cumulative_constraint,omitempty"`
	// When this is true, the cumulative constraint is reinforced with propagators
	// from the disjunctive constraint to improve the inference on a set of tasks
	// that are disjunctive at the root of the problem. This additional level
	// supplements the default level of reasoning.
	//
	// Propagators of the cumulative constraint will not be used at all if all the
	// tasks are disjunctive at root node.
	//
	// This always result in better propagation, but it is usually slow, so
	// depending on the problem, turning this off may lead to a faster solution.
	UseDisjunctiveConstraintInCumulativeConstraint *bool `protobuf:"varint,80,opt,name=use_disjunctive_constraint_in_cumulative_constraint,json=useDisjunctiveConstraintInCumulativeConstraint,def=1" json:"use_disjunctive_constraint_in_cumulative_constraint,omitempty"`
	// A non-negative level indicating the type of constraints we consider in the
	// LP relaxation. At level zero, no LP relaxation is used. At level 1, only
	// the linear constraint and full encoding are added. At level 2, we also add
	// all the Boolean constraints.
	LinearizationLevel *int32 `protobuf:"varint,90,opt,name=linearization_level,json=linearizationLevel,def=1" json:"linearization_level,omitempty"`
	// A non-negative level indicating how much we should try to fully encode
	// Integer variables as Boolean.
	BooleanEncodingLevel *int32 `protobuf:"varint,107,opt,name=boolean_encoding_level,json=booleanEncodingLevel,def=1" json:"boolean_encoding_level,omitempty"`
	// The limit on the number of cuts in our cut pool. When this is reached we do
	// not generate cuts anymore.
	//
	// TODO(user): We should probably remove this parameters, and just always
	// generate cuts but only keep the best n or something.
	MaxNumCuts *int32 `protobuf:"varint,91,opt,name=max_num_cuts,json=maxNumCuts,def=10000" json:"max_num_cuts,omitempty"`
	// For the cut that can be generated at any level, this control if we only
	// try to generate them at the root node.
	OnlyAddCutsAtLevelZero *bool `protobuf:"varint,92,opt,name=only_add_cuts_at_level_zero,json=onlyAddCutsAtLevelZero,def=0" json:"only_add_cuts_at_level_zero,omitempty"`
	// Whether we generate knapsack cuts. Note that in our setting where all
	// variables are integer and bounded on both side, such a cut could be applied
	// to any constraint.
	AddKnapsackCuts *bool `protobuf:"varint,111,opt,name=add_knapsack_cuts,json=addKnapsackCuts,def=0" json:"add_knapsack_cuts,omitempty"`
	// Whether we generate and add Chvatal-Gomory cuts to the LP at root node.
	// Note that for now, this is not heavily tunned.
	AddCgCuts *bool `protobuf:"varint,117,opt,name=add_cg_cuts,json=addCgCuts,def=1" json:"add_cg_cuts,omitempty"`
	// Whether we generate MIR cuts at root node.
	// Note that for now, this is not heavily tunned.
	AddMirCuts *bool `protobuf:"varint,120,opt,name=add_mir_cuts,json=addMirCuts,def=1" json:"add_mir_cuts,omitempty"`
	// Cut generator for all diffs can add too many cuts for large all_diff
	// constraints. This parameter restricts the large all_diff constraints to
	// have a cut generator.
	MaxAllDiffCutSize *int32 `protobuf:"varint,148,opt,name=max_all_diff_cut_size,json=maxAllDiffCutSize,def=7" json:"max_all_diff_cut_size,omitempty"`
	// For the lin max constraints, generates the cuts described in "Strong
	// mixed-integer programming formulations for trained neural networks" by Ross
	// Anderson et. (https://arxiv.org/pdf/1811.01988.pdf)
	AddLinMaxCuts *bool `protobuf:"varint,152,opt,name=add_lin_max_cuts,json=addLinMaxCuts,def=1" json:"add_lin_max_cuts,omitempty"`
	// In the integer rounding procedure used for MIR and Gomory cut, the maximum
	// "scaling" we use (must be positive). The lower this is, the lower the
	// integer coefficients of the cut will be. Note that cut generated by lower
	// values are not necessarily worse than cut generated by larger value. There
	// is no strict dominance relationship.
	//
	// Setting this to 2 result in the "strong fractional rouding" of Letchford
	// and Lodi.
	MaxIntegerRoundingScaling *int32 `protobuf:"varint,119,opt,name=max_integer_rounding_scaling,json=maxIntegerRoundingScaling,def=600" json:"max_integer_rounding_scaling,omitempty"`
	// If true, we start by an empty LP, and only add constraints not satisfied
	// by the current LP solution batch by batch. A constraint that is only added
	// like this is known as a "lazy" constraint in the literature, except that we
	// currently consider all constraints as lazy here.
	AddLpConstraintsLazily *bool `protobuf:"varint,112,opt,name=add_lp_constraints_lazily,json=addLpConstraintsLazily,def=1" json:"add_lp_constraints_lazily,omitempty"`
	// While adding constraints, skip the constraints which have orthogonality
	// less than 'min_orthogonality_for_lp_constraints' with already added
	// constraints during current call. Orthogonality is defined as 1 -
	// cosine(vector angle between constraints). A value of zero disable this
	// feature.
	MinOrthogonalityForLpConstraints *float64 `protobuf:"fixed64,115,opt,name=min_orthogonality_for_lp_constraints,json=minOrthogonalityForLpConstraints,def=0.05" json:"min_orthogonality_for_lp_constraints,omitempty"`
	// Max number of time we perform cut generation and resolve the LP at level 0.
	MaxCutRoundsAtLevelZero *int32 `protobuf:"varint,154,opt,name=max_cut_rounds_at_level_zero,json=maxCutRoundsAtLevelZero,def=1" json:"max_cut_rounds_at_level_zero,omitempty"`
	// If a constraint/cut in LP is not active for that many consecutive OPTIMAL
	// solves, remove it from the LP. Note that it might be added again later if
	// it become violated by the current LP solution.
	MaxConsecutiveInactiveCount *int32 `protobuf:"varint,121,opt,name=max_consecutive_inactive_count,json=maxConsecutiveInactiveCount,def=100" json:"max_consecutive_inactive_count,omitempty"`
	// These parameters are similar to sat clause management activity parameters.
	// They are effective only if the number of generated cuts exceed the storage
	// limit. Default values are based on a few experiments on miplib instances.
	CutMaxActiveCountValue *float64 `protobuf:"fixed64,155,opt,name=cut_max_active_count_value,json=cutMaxActiveCountValue,def=1e+10" json:"cut_max_active_count_value,omitempty"`
	CutActiveCountDecay    *float64 `protobuf:"fixed64,156,opt,name=cut_active_count_decay,json=cutActiveCountDecay,def=0.8" json:"cut_active_count_decay,omitempty"`
	// Target number of constraints to remove during cleanup.
	CutCleanupTarget *int32 `protobuf:"varint,157,opt,name=cut_cleanup_target,json=cutCleanupTarget,def=1000" json:"cut_cleanup_target,omitempty"`
	// Add that many lazy contraints (or cuts) at once in the LP. Note that at the
	// beginning of the solve, we do add more than this.
	NewConstraintsBatchSize *int32                         `protobuf:"varint,122,opt,name=new_constraints_batch_size,json=newConstraintsBatchSize,def=50" json:"new_constraints_batch_size,omitempty"`
	SearchBranching         *SatParameters_SearchBranching `protobuf:"varint,82,opt,name=search_branching,json=searchBranching,enum=operations_research.sat.SatParameters_SearchBranching,def=0" json:"search_branching,omitempty"`
	// When we try to follow the hint, we do a FIXED_SEARCH using the hint until
	// this number of conflict is reached.
	HintConflictLimit *int32 `protobuf:"varint,153,opt,name=hint_conflict_limit,json=hintConflictLimit,def=10" json:"hint_conflict_limit,omitempty"`
	// If true and the Lp relaxation of the problem has an integer optimal
	// solution, try to exploit it. Note that since the LP relaxation may not
	// contain all the constraints, such a solution is not necessarily a solution
	// of the full problem.
	ExploitIntegerLpSolution *bool `protobuf:"varint,94,opt,name=exploit_integer_lp_solution,json=exploitIntegerLpSolution,def=1" json:"exploit_integer_lp_solution,omitempty"`
	// If true and the Lp relaxation of the problem has a solution, try to exploit
	// it. This is same as above except in this case the lp solution might not be
	// an integer solution.
	ExploitAllLpSolution *bool `protobuf:"varint,116,opt,name=exploit_all_lp_solution,json=exploitAllLpSolution,def=1" json:"exploit_all_lp_solution,omitempty"`
	// When branching on a variable, follow the last best solution value.
	ExploitBestSolution *bool `protobuf:"varint,130,opt,name=exploit_best_solution,json=exploitBestSolution,def=0" json:"exploit_best_solution,omitempty"`
	// When branching on a variable, follow the last best relaxation solution
	// value. We use the relaxation with the tightest bound on the objective as
	// the best relaxation solution.
	ExploitRelaxationSolution *bool `protobuf:"varint,161,opt,name=exploit_relaxation_solution,json=exploitRelaxationSolution,def=0" json:"exploit_relaxation_solution,omitempty"`
	// When branching an a variable that directly affect the objective,
	// branch on the value that lead to the best objective first.
	ExploitObjective *bool `protobuf:"varint,131,opt,name=exploit_objective,json=exploitObjective,def=1" json:"exploit_objective,omitempty"`
	// If set at zero (the default), it is disabled. Otherwise the solver attempts
	// probing at every 'probing_period' root node. Period of 1 enables probing at
	// every root node.
	ProbingPeriodAtRoot *int64 `protobuf:"varint,142,opt,name=probing_period_at_root,json=probingPeriodAtRoot,def=0" json:"probing_period_at_root,omitempty"`
	// The solver ignores the pseudo costs of variables with number of recordings
	// less than this threshold.
	PseudoCostReliabilityThreshold *int64 `protobuf:"varint,123,opt,name=pseudo_cost_reliability_threshold,json=pseudoCostReliabilityThreshold,def=100" json:"pseudo_cost_reliability_threshold,omitempty"`
	// The default optimization method is a simple "linear scan", each time trying
	// to find a better solution than the previous one. If this is true, then we
	// use a core-based approach (like in max-SAT) when we try to increase the
	// lower bound instead.
	OptimizeWithCore *bool `protobuf:"varint,83,opt,name=optimize_with_core,json=optimizeWithCore,def=0" json:"optimize_with_core,omitempty"`
	// If non-negative, perform a binary search on the objective variable in order
	// to find an [min, max] interval outside of which the solver proved unsat/sat
	// under this amount of conflict. This can quickly reduce the objective domain
	// on some problems.
	BinarySearchNumConflicts *int32 `protobuf:"varint,99,opt,name=binary_search_num_conflicts,json=binarySearchNumConflicts,def=-1" json:"binary_search_num_conflicts,omitempty"`
	// This has no effect if optimize_with_core is false. If true, use a different
	// core-based algorithm similar to the max-HS algo for max-SAT. This is a
	// hybrid MIP/CP approach and it uses a MIP solver in addition to the CP/SAT
	// one. This is also related to the PhD work of tobyodavies@
	// "Automatic Logic-Based Benders Decomposition with MiniZinc"
	// http://aaai.org/ocs/index.php/AAAI/AAAI17/paper/view/14489
	OptimizeWithMaxHs *bool `protobuf:"varint,85,opt,name=optimize_with_max_hs,json=optimizeWithMaxHs,def=0" json:"optimize_with_max_hs,omitempty"`
	// Whether we enumerate all solutions of a problem without objective. Note
	// that setting this to true automatically disable the presolve. This is
	// because the presolve rules only guarantee the existence of one feasible
	// solution to the presolved problem.
	//
	// TODO(user): Activate the presolve but with just the rules that do not
	// change the set of feasible solutions.
	EnumerateAllSolutions *bool `protobuf:"varint,87,opt,name=enumerate_all_solutions,json=enumerateAllSolutions,def=0" json:"enumerate_all_solutions,omitempty"`
	// If true, add information about the derived variable domains to the
	// CpSolverResponse. It is an option because it makes the response slighly
	// bigger and there is a bit more work involved during the postsolve to
	// construct it, but it should still have a low overhead. See the
	// tightened_variables field in CpSolverResponse for more details.
	FillTightenedDomainsInResponse *bool `protobuf:"varint,132,opt,name=fill_tightened_domains_in_response,json=fillTightenedDomainsInResponse,def=0" json:"fill_tightened_domains_in_response,omitempty"`
	// If true, the solver will add a default integer branching strategy to the
	// already defined search strategy.
	InstantiateAllVariables *bool `protobuf:"varint,106,opt,name=instantiate_all_variables,json=instantiateAllVariables,def=1" json:"instantiate_all_variables,omitempty"`
	// If true, then the precedences propagator try to detect for each variable if
	// it has a set of "optional incoming arc" for which at least one of them is
	// present. This is usually useful to have but can be slow on model with a lot
	// of precedence.
	AutoDetectGreaterThanAtLeastOneOf *bool `protobuf:"varint,95,opt,name=auto_detect_greater_than_at_least_one_of,json=autoDetectGreaterThanAtLeastOneOf,def=1" json:"auto_detect_greater_than_at_least_one_of,omitempty"`
	// For an optimization problem, stop the solver as soon as we have a solution.
	StopAfterFirstSolution *bool `protobuf:"varint,98,opt,name=stop_after_first_solution,json=stopAfterFirstSolution,def=0" json:"stop_after_first_solution,omitempty"`
	// Mainly used when improving the presolver. When true, stops the solver after
	// the presolve is complete.
	StopAfterPresolve *bool `protobuf:"varint,149,opt,name=stop_after_presolve,json=stopAfterPresolve,def=0" json:"stop_after_presolve,omitempty"`
	// Specify the number of parallel workers to use during search.
	// A number <= 1 means no parallelism.
	// As of 2020-04-10, if you're using SAT via MPSolver (to solve integer
	// programs) this field is overridden with a value of 8, if the field is not
	// set *explicitly*. Thus, always set this field explicitly or via
	// MPSolver::SetNumThreads().
	NumSearchWorkers *int32 `protobuf:"varint,100,opt,name=num_search_workers,json=numSearchWorkers,def=1" json:"num_search_workers,omitempty"`
	// Experimental. If this is true, then we interleave all our major search
	// strategy and distribute the work amongst num_search_workers.
	//
	// The search is deterministic (independently of num_search_workers!), and we
	// schedule and wait for interleave_batch_size task to be completed before
	// synchronizing and scheduling the next batch of tasks.
	InterleaveSearch    *bool  `protobuf:"varint,136,opt,name=interleave_search,json=interleaveSearch,def=0" json:"interleave_search,omitempty"`
	InterleaveBatchSize *int32 `protobuf:"varint,134,opt,name=interleave_batch_size,json=interleaveBatchSize,def=1" json:"interleave_batch_size,omitempty"`
	// Temporary parameter until the memory usage is more optimized.
	ReduceMemoryUsageInInterleaveMode *bool `protobuf:"varint,141,opt,name=reduce_memory_usage_in_interleave_mode,json=reduceMemoryUsageInInterleaveMode,def=0" json:"reduce_memory_usage_in_interleave_mode,omitempty"`
	// Allows objective sharing between workers.
	ShareObjectiveBounds *bool `protobuf:"varint,113,opt,name=share_objective_bounds,json=shareObjectiveBounds,def=1" json:"share_objective_bounds,omitempty"`
	// Allows sharing of the bounds of modified variables at level 0.
	ShareLevelZeroBounds *bool `protobuf:"varint,114,opt,name=share_level_zero_bounds,json=shareLevelZeroBounds,def=1" json:"share_level_zero_bounds,omitempty"`
	// LNS parameters.
	UseLnsOnly                  *bool `protobuf:"varint,101,opt,name=use_lns_only,json=useLnsOnly,def=0" json:"use_lns_only,omitempty"`
	LnsFocusOnDecisionVariables *bool `protobuf:"varint,105,opt,name=lns_focus_on_decision_variables,json=lnsFocusOnDecisionVariables,def=0" json:"lns_focus_on_decision_variables,omitempty"`
	// Turns on relaxation induced neighborhood generator.
	UseRinsLns *bool `protobuf:"varint,129,opt,name=use_rins_lns,json=useRinsLns,def=1" json:"use_rins_lns,omitempty"`
	// Adds a feasibility pump subsolver along with lns subsolvers.
	UseFeasibilityPump *bool                           `protobuf:"varint,164,opt,name=use_feasibility_pump,json=useFeasibilityPump,def=1" json:"use_feasibility_pump,omitempty"`
	FpRounding         *SatParameters_FPRoundingMethod `protobuf:"varint,165,opt,name=fp_rounding,json=fpRounding,enum=operations_research.sat.SatParameters_FPRoundingMethod,def=2" json:"fp_rounding,omitempty"`
	// Turns on a lns worker which solves relaxed version of the original problem
	// by removing constraints from the problem in order to get better bounds.
	UseRelaxationLns *bool `protobuf:"varint,150,opt,name=use_relaxation_lns,json=useRelaxationLns,def=0" json:"use_relaxation_lns,omitempty"`
	// If true, registers more lns subsolvers with different parameters.
	DiversifyLnsParams *bool `protobuf:"varint,137,opt,name=diversify_lns_params,json=diversifyLnsParams,def=0" json:"diversify_lns_params,omitempty"`
	// Randomize fixed search.
	RandomizeSearch *bool `protobuf:"varint,103,opt,name=randomize_search,json=randomizeSearch,def=0" json:"randomize_search,omitempty"`
	// Search randomization will collect equivalent 'max valued' variables, and
	// pick one randomly. For instance, if the variable strategy is CHOOSE_FIRST,
	// all unassigned variables are equivalent. If the variable strategy is
	// CHOOSE_LOWEST_MIN, and `lm` is the current lowest min of all unassigned
	// variables, then the set of max valued variables will be all unassigned
	// variables where
	//    lm <= variable min <= lm + search_randomization_tolerance
	SearchRandomizationTolerance *int64 `protobuf:"varint,104,opt,name=search_randomization_tolerance,json=searchRandomizationTolerance,def=0" json:"search_randomization_tolerance,omitempty"`
	// If true, we automatically detect variables whose constraint are always
	// enforced by the same literal and we mark them as optional. This allows
	// to propagate them as if they were present in some situation.
	UseOptionalVariables *bool `protobuf:"varint,108,opt,name=use_optional_variables,json=useOptionalVariables,def=1" json:"use_optional_variables,omitempty"`
	// The solver usually exploit the LP relaxation of a model. If this option is
	// true, then whatever is infered by the LP will be used like an heuristic to
	// compute EXACT propagation on the IP. So with this option, there is no
	// numerical imprecision issues.
	UseExactLpReason *bool `protobuf:"varint,109,opt,name=use_exact_lp_reason,json=useExactLpReason,def=1" json:"use_exact_lp_reason,omitempty"`
	// If true, the solver attemts to generate more info inside lp propagator by
	// branching on some variables if certain criteria are met during the search
	// tree exploration.
	UseBranchingInLp *bool `protobuf:"varint,139,opt,name=use_branching_in_lp,json=useBranchingInLp,def=0" json:"use_branching_in_lp,omitempty"`
	// This can be beneficial if there is a lot of no-overlap constraints but a
	// relatively low number of different intervals in the problem. Like 1000
	// intervals, but 1M intervals in the no-overlap constraints covering them.
	UseCombinedNoOverlap *bool `protobuf:"varint,133,opt,name=use_combined_no_overlap,json=useCombinedNoOverlap,def=0" json:"use_combined_no_overlap,omitempty"`
	// Indicates if the CP-SAT layer should catch Control-C (SIGINT) signals
	// when calling solve. If set, catching the SIGINT signal will terminate the
	// search gracefully, as if a time limit was reached.
	CatchSigintSignal *bool `protobuf:"varint,135,opt,name=catch_sigint_signal,json=catchSigintSignal,def=1" json:"catch_sigint_signal,omitempty"`
	// Stores and exploits "implied-bounds" in the solver. That is, relations of
	// the form literal => (var >= bound). This is currently used to derive
	// stronger cuts.
	UseImpliedBounds *bool `protobuf:"varint,144,opt,name=use_implied_bounds,json=useImpliedBounds,def=1" json:"use_implied_bounds,omitempty"`
	// We need to bound the maximum magnitude of the variables for CP-SAT, and
	// that is the bound we use. If the MIP model expect larger variable value in
	// the solution, then the converted model will likely not be relevant.
	MipMaxBound *float64 `protobuf:"fixed64,124,opt,name=mip_max_bound,json=mipMaxBound,def=1e+07" json:"mip_max_bound,omitempty"`
	// All continuous variable of the problem will be multiplied by this factor.
	// By default, we don't do any variable scaling and rely on the MIP model to
	// specify continuous variable domain with the wanted precision.
	MipVarScaling *float64 `protobuf:"fixed64,125,opt,name=mip_var_scaling,json=mipVarScaling,def=1" json:"mip_var_scaling,omitempty"`
	// If true, some continuous variable might be automatially scaled. For now,
	// this is only the case where we detect that a variable is actually an
	// integer multiple of a constant. For instance, variables of the form k * 0.5
	// are quite frequent, and if we detect this, we will scale such variable
	// domain by 2 to make it implied integer.
	MipAutomaticallyScaleVariables *bool `protobuf:"varint,166,opt,name=mip_automatically_scale_variables,json=mipAutomaticallyScaleVariables,def=1" json:"mip_automatically_scale_variables,omitempty"`
	// When scaling constraint with double coefficients to integer coefficients,
	// we will multiply by a power of 2 and round the coefficients. We will choose
	// the lowest power such that we have this relative precision on each of the
	// constraint (resp. objective) coefficient.
	//
	// We also use this to decide by how much we relax the constraint bounds so
	// that we can have a feasible integer solution of constraints involving
	// continuous variable. This is required for instance when you have an == rhs
	// constraint as in many situation you cannot have a perfect equality with
	// integer variables and coefficients.
	MipWantedPrecision *float64 `protobuf:"fixed64,126,opt,name=mip_wanted_precision,json=mipWantedPrecision,def=1e-06" json:"mip_wanted_precision,omitempty"`
	// To avoid integer overflow, we always force the maximum possible constraint
	// activity (and objective value) according to the initial variable domain to
	// be smaller than 2 to this given power. Because of this, we cannot always
	// reach the "mip_wanted_precision" parameter above.
	//
	// This can go as high as 62, but some internal algo currently abort early if
	// they might run into integer overflow, so it is better to keep it a bit
	// lower than this.
	MipMaxActivityExponent *int32 `protobuf:"varint,127,opt,name=mip_max_activity_exponent,json=mipMaxActivityExponent,def=53" json:"mip_max_activity_exponent,omitempty"`
	// As explained in mip_precision and mip_max_activity_exponent, we cannot
	// always reach the wanted coefficient precision during scaling. When we
	// cannot, we will report MODEL_INVALID if the relative preicision is larger
	// than this parameter.
	MipCheckPrecision    *float64 `protobuf:"fixed64,128,opt,name=mip_check_precision,json=mipCheckPrecision,def=0.0001" json:"mip_check_precision,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SatParameters) Reset()         { *m = SatParameters{} }
func (m *SatParameters) String() string { return proto.CompactTextString(m) }
func (*SatParameters) ProtoMessage()    {}
func (*SatParameters) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c726f7f6ef83bf4, []int{0}
}

func (m *SatParameters) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SatParameters.Unmarshal(m, b)
}
func (m *SatParameters) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SatParameters.Marshal(b, m, deterministic)
}
func (m *SatParameters) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SatParameters.Merge(m, src)
}
func (m *SatParameters) XXX_Size() int {
	return xxx_messageInfo_SatParameters.Size(m)
}
func (m *SatParameters) XXX_DiscardUnknown() {
	xxx_messageInfo_SatParameters.DiscardUnknown(m)
}

var xxx_messageInfo_SatParameters proto.InternalMessageInfo

const Default_SatParameters_PreferredVariableOrder SatParameters_VariableOrder = SatParameters_IN_ORDER
const Default_SatParameters_InitialPolarity SatParameters_Polarity = SatParameters_POLARITY_FALSE
const Default_SatParameters_UsePhaseSaving bool = true
const Default_SatParameters_RandomPolarityRatio float64 = 0
const Default_SatParameters_RandomBranchesRatio float64 = 0
const Default_SatParameters_UseErwaHeuristic bool = false
const Default_SatParameters_InitialVariablesActivity float64 = 0
const Default_SatParameters_AlsoBumpVariablesInConflictReasons bool = false
const Default_SatParameters_MinimizationAlgorithm SatParameters_ConflictMinimizationAlgorithm = SatParameters_RECURSIVE
const Default_SatParameters_BinaryMinimizationAlgorithm SatParameters_BinaryMinizationAlgorithm = SatParameters_BINARY_MINIMIZATION_FIRST
const Default_SatParameters_SubsumptionDuringConflictAnalysis bool = true
const Default_SatParameters_ClauseCleanupPeriod int32 = 10000
const Default_SatParameters_ClauseCleanupTarget int32 = 10000
const Default_SatParameters_ClauseCleanupProtection SatParameters_ClauseProtection = SatParameters_PROTECTION_NONE
const Default_SatParameters_ClauseCleanupLbdBound int32 = 5
const Default_SatParameters_ClauseCleanupOrdering SatParameters_ClauseOrdering = SatParameters_CLAUSE_ACTIVITY
const Default_SatParameters_PbCleanupIncrement int32 = 200
const Default_SatParameters_PbCleanupRatio float64 = 0.5
const Default_SatParameters_MinimizeWithPropagationRestartPeriod int32 = 10
const Default_SatParameters_MinimizeWithPropagationNumDecisions int32 = 1000
const Default_SatParameters_VariableActivityDecay float64 = 0.8
const Default_SatParameters_MaxVariableActivityValue float64 = 1e+100
const Default_SatParameters_GlucoseMaxDecay float64 = 0.95
const Default_SatParameters_GlucoseDecayIncrement float64 = 0.01
const Default_SatParameters_GlucoseDecayIncrementPeriod int32 = 5000
const Default_SatParameters_ClauseActivityDecay float64 = 0.999
const Default_SatParameters_MaxClauseActivityValue float64 = 1e+20
const Default_SatParameters_DefaultRestartAlgorithms string = "LUBY_RESTART,LBD_MOVING_AVERAGE_RESTART,DL_MOVING_AVERAGE_RESTART"
const Default_SatParameters_RestartPeriod int32 = 50
const Default_SatParameters_RestartRunningWindowSize int32 = 50
const Default_SatParameters_RestartDlAverageRatio float64 = 1
const Default_SatParameters_RestartLbdAverageRatio float64 = 1
const Default_SatParameters_UseBlockingRestart bool = false
const Default_SatParameters_BlockingRestartWindowSize int32 = 5000
const Default_SatParameters_BlockingRestartMultiplier float64 = 1.4
const Default_SatParameters_NumConflictsBeforeStrategyChanges int32 = 0
const Default_SatParameters_StrategyChangeIncreaseRatio float64 = 0

var Default_SatParameters_MaxTimeInSeconds float64 = math.Inf(1)
var Default_SatParameters_MaxDeterministicTime float64 = math.Inf(1)

const Default_SatParameters_MaxNumberOfConflicts int64 = 9223372036854775807
const Default_SatParameters_MaxMemoryInMb int64 = 10000
const Default_SatParameters_AbsoluteGapLimit float64 = 0
const Default_SatParameters_RelativeGapLimit float64 = 0
const Default_SatParameters_TreatBinaryClausesSeparately bool = true
const Default_SatParameters_RandomSeed int32 = 1
const Default_SatParameters_LogSearchProgress bool = false
const Default_SatParameters_UsePbResolution bool = false
const Default_SatParameters_MinimizeReductionDuringPbResolution bool = false
const Default_SatParameters_CountAssumptionLevelsInLbd bool = true
const Default_SatParameters_PresolveBveThreshold int32 = 500
const Default_SatParameters_PresolveBveClauseWeight int32 = 3
const Default_SatParameters_PresolveProbingDeterministicTimeLimit float64 = 30
const Default_SatParameters_PresolveBlockedClause bool = true
const Default_SatParameters_PresolveUseBva bool = true
const Default_SatParameters_PresolveBvaThreshold int32 = 1
const Default_SatParameters_MaxPresolveIterations int32 = 3
const Default_SatParameters_CpModelPresolve bool = true
const Default_SatParameters_CpModelPostsolveWithFullSolver bool = false
const Default_SatParameters_CpModelMaxNumPresolveOperations int32 = 0
const Default_SatParameters_CpModelProbingLevel int32 = 2
const Default_SatParameters_CpModelUseSatPresolve bool = true
const Default_SatParameters_UseSatInprocessing bool = false
const Default_SatParameters_ExpandElementConstraints bool = true
const Default_SatParameters_ExpandAutomatonConstraints bool = true
const Default_SatParameters_ExpandTableConstraints bool = true
const Default_SatParameters_MergeNoOverlapWorkLimit float64 = 1e+12
const Default_SatParameters_MergeAtMostOneWorkLimit float64 = 1e+08
const Default_SatParameters_PresolveSubstitutionLevel int32 = 1
const Default_SatParameters_UseOptimizationHints bool = true
const Default_SatParameters_MinimizeCore bool = true
const Default_SatParameters_FindMultipleCores bool = true
const Default_SatParameters_CoverOptimization bool = true
const Default_SatParameters_MaxSatAssumptionOrder SatParameters_MaxSatAssumptionOrder = SatParameters_DEFAULT_ASSUMPTION_ORDER
const Default_SatParameters_MaxSatReverseAssumptionOrder bool = false
const Default_SatParameters_MaxSatStratification SatParameters_MaxSatStratificationAlgorithm = SatParameters_STRATIFICATION_DESCENT
const Default_SatParameters_UsePrecedencesInDisjunctiveConstraint bool = true
const Default_SatParameters_UseOverloadCheckerInCumulativeConstraint bool = false
const Default_SatParameters_UseTimetableEdgeFindingInCumulativeConstraint bool = false
const Default_SatParameters_UseDisjunctiveConstraintInCumulativeConstraint bool = true
const Default_SatParameters_LinearizationLevel int32 = 1
const Default_SatParameters_BooleanEncodingLevel int32 = 1
const Default_SatParameters_MaxNumCuts int32 = 10000
const Default_SatParameters_OnlyAddCutsAtLevelZero bool = false
const Default_SatParameters_AddKnapsackCuts bool = false
const Default_SatParameters_AddCgCuts bool = true
const Default_SatParameters_AddMirCuts bool = true
const Default_SatParameters_MaxAllDiffCutSize int32 = 7
const Default_SatParameters_AddLinMaxCuts bool = true
const Default_SatParameters_MaxIntegerRoundingScaling int32 = 600
const Default_SatParameters_AddLpConstraintsLazily bool = true
const Default_SatParameters_MinOrthogonalityForLpConstraints float64 = 0.05
const Default_SatParameters_MaxCutRoundsAtLevelZero int32 = 1
const Default_SatParameters_MaxConsecutiveInactiveCount int32 = 100
const Default_SatParameters_CutMaxActiveCountValue float64 = 1e+10
const Default_SatParameters_CutActiveCountDecay float64 = 0.8
const Default_SatParameters_CutCleanupTarget int32 = 1000
const Default_SatParameters_NewConstraintsBatchSize int32 = 50
const Default_SatParameters_SearchBranching SatParameters_SearchBranching = SatParameters_AUTOMATIC_SEARCH
const Default_SatParameters_HintConflictLimit int32 = 10
const Default_SatParameters_ExploitIntegerLpSolution bool = true
const Default_SatParameters_ExploitAllLpSolution bool = true
const Default_SatParameters_ExploitBestSolution bool = false
const Default_SatParameters_ExploitRelaxationSolution bool = false
const Default_SatParameters_ExploitObjective bool = true
const Default_SatParameters_ProbingPeriodAtRoot int64 = 0
const Default_SatParameters_PseudoCostReliabilityThreshold int64 = 100
const Default_SatParameters_OptimizeWithCore bool = false
const Default_SatParameters_BinarySearchNumConflicts int32 = -1
const Default_SatParameters_OptimizeWithMaxHs bool = false
const Default_SatParameters_EnumerateAllSolutions bool = false
const Default_SatParameters_FillTightenedDomainsInResponse bool = false
const Default_SatParameters_InstantiateAllVariables bool = true
const Default_SatParameters_AutoDetectGreaterThanAtLeastOneOf bool = true
const Default_SatParameters_StopAfterFirstSolution bool = false
const Default_SatParameters_StopAfterPresolve bool = false
const Default_SatParameters_NumSearchWorkers int32 = 1
const Default_SatParameters_InterleaveSearch bool = false
const Default_SatParameters_InterleaveBatchSize int32 = 1
const Default_SatParameters_ReduceMemoryUsageInInterleaveMode bool = false
const Default_SatParameters_ShareObjectiveBounds bool = true
const Default_SatParameters_ShareLevelZeroBounds bool = true
const Default_SatParameters_UseLnsOnly bool = false
const Default_SatParameters_LnsFocusOnDecisionVariables bool = false
const Default_SatParameters_UseRinsLns bool = true
const Default_SatParameters_UseFeasibilityPump bool = true
const Default_SatParameters_FpRounding SatParameters_FPRoundingMethod = SatParameters_PROPAGATION_ASSISTED
const Default_SatParameters_UseRelaxationLns bool = false
const Default_SatParameters_DiversifyLnsParams bool = false
const Default_SatParameters_RandomizeSearch bool = false
const Default_SatParameters_SearchRandomizationTolerance int64 = 0
const Default_SatParameters_UseOptionalVariables bool = true
const Default_SatParameters_UseExactLpReason bool = true
const Default_SatParameters_UseBranchingInLp bool = false
const Default_SatParameters_UseCombinedNoOverlap bool = false
const Default_SatParameters_CatchSigintSignal bool = true
const Default_SatParameters_UseImpliedBounds bool = true
const Default_SatParameters_MipMaxBound float64 = 1e+07
const Default_SatParameters_MipVarScaling float64 = 1
const Default_SatParameters_MipAutomaticallyScaleVariables bool = true
const Default_SatParameters_MipWantedPrecision float64 = 1e-06
const Default_SatParameters_MipMaxActivityExponent int32 = 53
const Default_SatParameters_MipCheckPrecision float64 = 0.0001

func (m *SatParameters) GetPreferredVariableOrder() SatParameters_VariableOrder {
	if m != nil && m.PreferredVariableOrder != nil {
		return *m.PreferredVariableOrder
	}
	return Default_SatParameters_PreferredVariableOrder
}

func (m *SatParameters) GetInitialPolarity() SatParameters_Polarity {
	if m != nil && m.InitialPolarity != nil {
		return *m.InitialPolarity
	}
	return Default_SatParameters_InitialPolarity
}

func (m *SatParameters) GetUsePhaseSaving() bool {
	if m != nil && m.UsePhaseSaving != nil {
		return *m.UsePhaseSaving
	}
	return Default_SatParameters_UsePhaseSaving
}

func (m *SatParameters) GetRandomPolarityRatio() float64 {
	if m != nil && m.RandomPolarityRatio != nil {
		return *m.RandomPolarityRatio
	}
	return Default_SatParameters_RandomPolarityRatio
}

func (m *SatParameters) GetRandomBranchesRatio() float64 {
	if m != nil && m.RandomBranchesRatio != nil {
		return *m.RandomBranchesRatio
	}
	return Default_SatParameters_RandomBranchesRatio
}

func (m *SatParameters) GetUseErwaHeuristic() bool {
	if m != nil && m.UseErwaHeuristic != nil {
		return *m.UseErwaHeuristic
	}
	return Default_SatParameters_UseErwaHeuristic
}

func (m *SatParameters) GetInitialVariablesActivity() float64 {
	if m != nil && m.InitialVariablesActivity != nil {
		return *m.InitialVariablesActivity
	}
	return Default_SatParameters_InitialVariablesActivity
}

func (m *SatParameters) GetAlsoBumpVariablesInConflictReasons() bool {
	if m != nil && m.AlsoBumpVariablesInConflictReasons != nil {
		return *m.AlsoBumpVariablesInConflictReasons
	}
	return Default_SatParameters_AlsoBumpVariablesInConflictReasons
}

func (m *SatParameters) GetMinimizationAlgorithm() SatParameters_ConflictMinimizationAlgorithm {
	if m != nil && m.MinimizationAlgorithm != nil {
		return *m.MinimizationAlgorithm
	}
	return Default_SatParameters_MinimizationAlgorithm
}

func (m *SatParameters) GetBinaryMinimizationAlgorithm() SatParameters_BinaryMinizationAlgorithm {
	if m != nil && m.BinaryMinimizationAlgorithm != nil {
		return *m.BinaryMinimizationAlgorithm
	}
	return Default_SatParameters_BinaryMinimizationAlgorithm
}

func (m *SatParameters) GetSubsumptionDuringConflictAnalysis() bool {
	if m != nil && m.SubsumptionDuringConflictAnalysis != nil {
		return *m.SubsumptionDuringConflictAnalysis
	}
	return Default_SatParameters_SubsumptionDuringConflictAnalysis
}

func (m *SatParameters) GetClauseCleanupPeriod() int32 {
	if m != nil && m.ClauseCleanupPeriod != nil {
		return *m.ClauseCleanupPeriod
	}
	return Default_SatParameters_ClauseCleanupPeriod
}

func (m *SatParameters) GetClauseCleanupTarget() int32 {
	if m != nil && m.ClauseCleanupTarget != nil {
		return *m.ClauseCleanupTarget
	}
	return Default_SatParameters_ClauseCleanupTarget
}

func (m *SatParameters) GetClauseCleanupProtection() SatParameters_ClauseProtection {
	if m != nil && m.ClauseCleanupProtection != nil {
		return *m.ClauseCleanupProtection
	}
	return Default_SatParameters_ClauseCleanupProtection
}

func (m *SatParameters) GetClauseCleanupLbdBound() int32 {
	if m != nil && m.ClauseCleanupLbdBound != nil {
		return *m.ClauseCleanupLbdBound
	}
	return Default_SatParameters_ClauseCleanupLbdBound
}

func (m *SatParameters) GetClauseCleanupOrdering() SatParameters_ClauseOrdering {
	if m != nil && m.ClauseCleanupOrdering != nil {
		return *m.ClauseCleanupOrdering
	}
	return Default_SatParameters_ClauseCleanupOrdering
}

func (m *SatParameters) GetPbCleanupIncrement() int32 {
	if m != nil && m.PbCleanupIncrement != nil {
		return *m.PbCleanupIncrement
	}
	return Default_SatParameters_PbCleanupIncrement
}

func (m *SatParameters) GetPbCleanupRatio() float64 {
	if m != nil && m.PbCleanupRatio != nil {
		return *m.PbCleanupRatio
	}
	return Default_SatParameters_PbCleanupRatio
}

func (m *SatParameters) GetMinimizeWithPropagationRestartPeriod() int32 {
	if m != nil && m.MinimizeWithPropagationRestartPeriod != nil {
		return *m.MinimizeWithPropagationRestartPeriod
	}
	return Default_SatParameters_MinimizeWithPropagationRestartPeriod
}

func (m *SatParameters) GetMinimizeWithPropagationNumDecisions() int32 {
	if m != nil && m.MinimizeWithPropagationNumDecisions != nil {
		return *m.MinimizeWithPropagationNumDecisions
	}
	return Default_SatParameters_MinimizeWithPropagationNumDecisions
}

func (m *SatParameters) GetVariableActivityDecay() float64 {
	if m != nil && m.VariableActivityDecay != nil {
		return *m.VariableActivityDecay
	}
	return Default_SatParameters_VariableActivityDecay
}

func (m *SatParameters) GetMaxVariableActivityValue() float64 {
	if m != nil && m.MaxVariableActivityValue != nil {
		return *m.MaxVariableActivityValue
	}
	return Default_SatParameters_MaxVariableActivityValue
}

func (m *SatParameters) GetGlucoseMaxDecay() float64 {
	if m != nil && m.GlucoseMaxDecay != nil {
		return *m.GlucoseMaxDecay
	}
	return Default_SatParameters_GlucoseMaxDecay
}

func (m *SatParameters) GetGlucoseDecayIncrement() float64 {
	if m != nil && m.GlucoseDecayIncrement != nil {
		return *m.GlucoseDecayIncrement
	}
	return Default_SatParameters_GlucoseDecayIncrement
}

func (m *SatParameters) GetGlucoseDecayIncrementPeriod() int32 {
	if m != nil && m.GlucoseDecayIncrementPeriod != nil {
		return *m.GlucoseDecayIncrementPeriod
	}
	return Default_SatParameters_GlucoseDecayIncrementPeriod
}

func (m *SatParameters) GetClauseActivityDecay() float64 {
	if m != nil && m.ClauseActivityDecay != nil {
		return *m.ClauseActivityDecay
	}
	return Default_SatParameters_ClauseActivityDecay
}

func (m *SatParameters) GetMaxClauseActivityValue() float64 {
	if m != nil && m.MaxClauseActivityValue != nil {
		return *m.MaxClauseActivityValue
	}
	return Default_SatParameters_MaxClauseActivityValue
}

func (m *SatParameters) GetRestartAlgorithms() []SatParameters_RestartAlgorithm {
	if m != nil {
		return m.RestartAlgorithms
	}
	return nil
}

func (m *SatParameters) GetDefaultRestartAlgorithms() string {
	if m != nil && m.DefaultRestartAlgorithms != nil {
		return *m.DefaultRestartAlgorithms
	}
	return Default_SatParameters_DefaultRestartAlgorithms
}

func (m *SatParameters) GetRestartPeriod() int32 {
	if m != nil && m.RestartPeriod != nil {
		return *m.RestartPeriod
	}
	return Default_SatParameters_RestartPeriod
}

func (m *SatParameters) GetRestartRunningWindowSize() int32 {
	if m != nil && m.RestartRunningWindowSize != nil {
		return *m.RestartRunningWindowSize
	}
	return Default_SatParameters_RestartRunningWindowSize
}

func (m *SatParameters) GetRestartDlAverageRatio() float64 {
	if m != nil && m.RestartDlAverageRatio != nil {
		return *m.RestartDlAverageRatio
	}
	return Default_SatParameters_RestartDlAverageRatio
}

func (m *SatParameters) GetRestartLbdAverageRatio() float64 {
	if m != nil && m.RestartLbdAverageRatio != nil {
		return *m.RestartLbdAverageRatio
	}
	return Default_SatParameters_RestartLbdAverageRatio
}

func (m *SatParameters) GetUseBlockingRestart() bool {
	if m != nil && m.UseBlockingRestart != nil {
		return *m.UseBlockingRestart
	}
	return Default_SatParameters_UseBlockingRestart
}

func (m *SatParameters) GetBlockingRestartWindowSize() int32 {
	if m != nil && m.BlockingRestartWindowSize != nil {
		return *m.BlockingRestartWindowSize
	}
	return Default_SatParameters_BlockingRestartWindowSize
}

func (m *SatParameters) GetBlockingRestartMultiplier() float64 {
	if m != nil && m.BlockingRestartMultiplier != nil {
		return *m.BlockingRestartMultiplier
	}
	return Default_SatParameters_BlockingRestartMultiplier
}

func (m *SatParameters) GetNumConflictsBeforeStrategyChanges() int32 {
	if m != nil && m.NumConflictsBeforeStrategyChanges != nil {
		return *m.NumConflictsBeforeStrategyChanges
	}
	return Default_SatParameters_NumConflictsBeforeStrategyChanges
}

func (m *SatParameters) GetStrategyChangeIncreaseRatio() float64 {
	if m != nil && m.StrategyChangeIncreaseRatio != nil {
		return *m.StrategyChangeIncreaseRatio
	}
	return Default_SatParameters_StrategyChangeIncreaseRatio
}

func (m *SatParameters) GetMaxTimeInSeconds() float64 {
	if m != nil && m.MaxTimeInSeconds != nil {
		return *m.MaxTimeInSeconds
	}
	return Default_SatParameters_MaxTimeInSeconds
}

func (m *SatParameters) GetMaxDeterministicTime() float64 {
	if m != nil && m.MaxDeterministicTime != nil {
		return *m.MaxDeterministicTime
	}
	return Default_SatParameters_MaxDeterministicTime
}

func (m *SatParameters) GetMaxNumberOfConflicts() int64 {
	if m != nil && m.MaxNumberOfConflicts != nil {
		return *m.MaxNumberOfConflicts
	}
	return Default_SatParameters_MaxNumberOfConflicts
}

func (m *SatParameters) GetMaxMemoryInMb() int64 {
	if m != nil && m.MaxMemoryInMb != nil {
		return *m.MaxMemoryInMb
	}
	return Default_SatParameters_MaxMemoryInMb
}

func (m *SatParameters) GetAbsoluteGapLimit() float64 {
	if m != nil && m.AbsoluteGapLimit != nil {
		return *m.AbsoluteGapLimit
	}
	return Default_SatParameters_AbsoluteGapLimit
}

func (m *SatParameters) GetRelativeGapLimit() float64 {
	if m != nil && m.RelativeGapLimit != nil {
		return *m.RelativeGapLimit
	}
	return Default_SatParameters_RelativeGapLimit
}

func (m *SatParameters) GetTreatBinaryClausesSeparately() bool {
	if m != nil && m.TreatBinaryClausesSeparately != nil {
		return *m.TreatBinaryClausesSeparately
	}
	return Default_SatParameters_TreatBinaryClausesSeparately
}

func (m *SatParameters) GetRandomSeed() int32 {
	if m != nil && m.RandomSeed != nil {
		return *m.RandomSeed
	}
	return Default_SatParameters_RandomSeed
}

func (m *SatParameters) GetLogSearchProgress() bool {
	if m != nil && m.LogSearchProgress != nil {
		return *m.LogSearchProgress
	}
	return Default_SatParameters_LogSearchProgress
}

func (m *SatParameters) GetUsePbResolution() bool {
	if m != nil && m.UsePbResolution != nil {
		return *m.UsePbResolution
	}
	return Default_SatParameters_UsePbResolution
}

func (m *SatParameters) GetMinimizeReductionDuringPbResolution() bool {
	if m != nil && m.MinimizeReductionDuringPbResolution != nil {
		return *m.MinimizeReductionDuringPbResolution
	}
	return Default_SatParameters_MinimizeReductionDuringPbResolution
}

func (m *SatParameters) GetCountAssumptionLevelsInLbd() bool {
	if m != nil && m.CountAssumptionLevelsInLbd != nil {
		return *m.CountAssumptionLevelsInLbd
	}
	return Default_SatParameters_CountAssumptionLevelsInLbd
}

func (m *SatParameters) GetPresolveBveThreshold() int32 {
	if m != nil && m.PresolveBveThreshold != nil {
		return *m.PresolveBveThreshold
	}
	return Default_SatParameters_PresolveBveThreshold
}

func (m *SatParameters) GetPresolveBveClauseWeight() int32 {
	if m != nil && m.PresolveBveClauseWeight != nil {
		return *m.PresolveBveClauseWeight
	}
	return Default_SatParameters_PresolveBveClauseWeight
}

func (m *SatParameters) GetPresolveProbingDeterministicTimeLimit() float64 {
	if m != nil && m.PresolveProbingDeterministicTimeLimit != nil {
		return *m.PresolveProbingDeterministicTimeLimit
	}
	return Default_SatParameters_PresolveProbingDeterministicTimeLimit
}

func (m *SatParameters) GetPresolveBlockedClause() bool {
	if m != nil && m.PresolveBlockedClause != nil {
		return *m.PresolveBlockedClause
	}
	return Default_SatParameters_PresolveBlockedClause
}

func (m *SatParameters) GetPresolveUseBva() bool {
	if m != nil && m.PresolveUseBva != nil {
		return *m.PresolveUseBva
	}
	return Default_SatParameters_PresolveUseBva
}

func (m *SatParameters) GetPresolveBvaThreshold() int32 {
	if m != nil && m.PresolveBvaThreshold != nil {
		return *m.PresolveBvaThreshold
	}
	return Default_SatParameters_PresolveBvaThreshold
}

func (m *SatParameters) GetMaxPresolveIterations() int32 {
	if m != nil && m.MaxPresolveIterations != nil {
		return *m.MaxPresolveIterations
	}
	return Default_SatParameters_MaxPresolveIterations
}

func (m *SatParameters) GetCpModelPresolve() bool {
	if m != nil && m.CpModelPresolve != nil {
		return *m.CpModelPresolve
	}
	return Default_SatParameters_CpModelPresolve
}

func (m *SatParameters) GetCpModelPostsolveWithFullSolver() bool {
	if m != nil && m.CpModelPostsolveWithFullSolver != nil {
		return *m.CpModelPostsolveWithFullSolver
	}
	return Default_SatParameters_CpModelPostsolveWithFullSolver
}

func (m *SatParameters) GetCpModelMaxNumPresolveOperations() int32 {
	if m != nil && m.CpModelMaxNumPresolveOperations != nil {
		return *m.CpModelMaxNumPresolveOperations
	}
	return Default_SatParameters_CpModelMaxNumPresolveOperations
}

func (m *SatParameters) GetCpModelProbingLevel() int32 {
	if m != nil && m.CpModelProbingLevel != nil {
		return *m.CpModelProbingLevel
	}
	return Default_SatParameters_CpModelProbingLevel
}

func (m *SatParameters) GetCpModelUseSatPresolve() bool {
	if m != nil && m.CpModelUseSatPresolve != nil {
		return *m.CpModelUseSatPresolve
	}
	return Default_SatParameters_CpModelUseSatPresolve
}

func (m *SatParameters) GetUseSatInprocessing() bool {
	if m != nil && m.UseSatInprocessing != nil {
		return *m.UseSatInprocessing
	}
	return Default_SatParameters_UseSatInprocessing
}

func (m *SatParameters) GetExpandElementConstraints() bool {
	if m != nil && m.ExpandElementConstraints != nil {
		return *m.ExpandElementConstraints
	}
	return Default_SatParameters_ExpandElementConstraints
}

func (m *SatParameters) GetExpandAutomatonConstraints() bool {
	if m != nil && m.ExpandAutomatonConstraints != nil {
		return *m.ExpandAutomatonConstraints
	}
	return Default_SatParameters_ExpandAutomatonConstraints
}

func (m *SatParameters) GetExpandTableConstraints() bool {
	if m != nil && m.ExpandTableConstraints != nil {
		return *m.ExpandTableConstraints
	}
	return Default_SatParameters_ExpandTableConstraints
}

func (m *SatParameters) GetMergeNoOverlapWorkLimit() float64 {
	if m != nil && m.MergeNoOverlapWorkLimit != nil {
		return *m.MergeNoOverlapWorkLimit
	}
	return Default_SatParameters_MergeNoOverlapWorkLimit
}

func (m *SatParameters) GetMergeAtMostOneWorkLimit() float64 {
	if m != nil && m.MergeAtMostOneWorkLimit != nil {
		return *m.MergeAtMostOneWorkLimit
	}
	return Default_SatParameters_MergeAtMostOneWorkLimit
}

func (m *SatParameters) GetPresolveSubstitutionLevel() int32 {
	if m != nil && m.PresolveSubstitutionLevel != nil {
		return *m.PresolveSubstitutionLevel
	}
	return Default_SatParameters_PresolveSubstitutionLevel
}

func (m *SatParameters) GetUseOptimizationHints() bool {
	if m != nil && m.UseOptimizationHints != nil {
		return *m.UseOptimizationHints
	}
	return Default_SatParameters_UseOptimizationHints
}

func (m *SatParameters) GetMinimizeCore() bool {
	if m != nil && m.MinimizeCore != nil {
		return *m.MinimizeCore
	}
	return Default_SatParameters_MinimizeCore
}

func (m *SatParameters) GetFindMultipleCores() bool {
	if m != nil && m.FindMultipleCores != nil {
		return *m.FindMultipleCores
	}
	return Default_SatParameters_FindMultipleCores
}

func (m *SatParameters) GetCoverOptimization() bool {
	if m != nil && m.CoverOptimization != nil {
		return *m.CoverOptimization
	}
	return Default_SatParameters_CoverOptimization
}

func (m *SatParameters) GetMaxSatAssumptionOrder() SatParameters_MaxSatAssumptionOrder {
	if m != nil && m.MaxSatAssumptionOrder != nil {
		return *m.MaxSatAssumptionOrder
	}
	return Default_SatParameters_MaxSatAssumptionOrder
}

func (m *SatParameters) GetMaxSatReverseAssumptionOrder() bool {
	if m != nil && m.MaxSatReverseAssumptionOrder != nil {
		return *m.MaxSatReverseAssumptionOrder
	}
	return Default_SatParameters_MaxSatReverseAssumptionOrder
}

func (m *SatParameters) GetMaxSatStratification() SatParameters_MaxSatStratificationAlgorithm {
	if m != nil && m.MaxSatStratification != nil {
		return *m.MaxSatStratification
	}
	return Default_SatParameters_MaxSatStratification
}

func (m *SatParameters) GetUsePrecedencesInDisjunctiveConstraint() bool {
	if m != nil && m.UsePrecedencesInDisjunctiveConstraint != nil {
		return *m.UsePrecedencesInDisjunctiveConstraint
	}
	return Default_SatParameters_UsePrecedencesInDisjunctiveConstraint
}

func (m *SatParameters) GetUseOverloadCheckerInCumulativeConstraint() bool {
	if m != nil && m.UseOverloadCheckerInCumulativeConstraint != nil {
		return *m.UseOverloadCheckerInCumulativeConstraint
	}
	return Default_SatParameters_UseOverloadCheckerInCumulativeConstraint
}

func (m *SatParameters) GetUseTimetableEdgeFindingInCumulativeConstraint() bool {
	if m != nil && m.UseTimetableEdgeFindingInCumulativeConstraint != nil {
		return *m.UseTimetableEdgeFindingInCumulativeConstraint
	}
	return Default_SatParameters_UseTimetableEdgeFindingInCumulativeConstraint
}

func (m *SatParameters) GetUseDisjunctiveConstraintInCumulativeConstraint() bool {
	if m != nil && m.UseDisjunctiveConstraintInCumulativeConstraint != nil {
		return *m.UseDisjunctiveConstraintInCumulativeConstraint
	}
	return Default_SatParameters_UseDisjunctiveConstraintInCumulativeConstraint
}

func (m *SatParameters) GetLinearizationLevel() int32 {
	if m != nil && m.LinearizationLevel != nil {
		return *m.LinearizationLevel
	}
	return Default_SatParameters_LinearizationLevel
}

func (m *SatParameters) GetBooleanEncodingLevel() int32 {
	if m != nil && m.BooleanEncodingLevel != nil {
		return *m.BooleanEncodingLevel
	}
	return Default_SatParameters_BooleanEncodingLevel
}

func (m *SatParameters) GetMaxNumCuts() int32 {
	if m != nil && m.MaxNumCuts != nil {
		return *m.MaxNumCuts
	}
	return Default_SatParameters_MaxNumCuts
}

func (m *SatParameters) GetOnlyAddCutsAtLevelZero() bool {
	if m != nil && m.OnlyAddCutsAtLevelZero != nil {
		return *m.OnlyAddCutsAtLevelZero
	}
	return Default_SatParameters_OnlyAddCutsAtLevelZero
}

func (m *SatParameters) GetAddKnapsackCuts() bool {
	if m != nil && m.AddKnapsackCuts != nil {
		return *m.AddKnapsackCuts
	}
	return Default_SatParameters_AddKnapsackCuts
}

func (m *SatParameters) GetAddCgCuts() bool {
	if m != nil && m.AddCgCuts != nil {
		return *m.AddCgCuts
	}
	return Default_SatParameters_AddCgCuts
}

func (m *SatParameters) GetAddMirCuts() bool {
	if m != nil && m.AddMirCuts != nil {
		return *m.AddMirCuts
	}
	return Default_SatParameters_AddMirCuts
}

func (m *SatParameters) GetMaxAllDiffCutSize() int32 {
	if m != nil && m.MaxAllDiffCutSize != nil {
		return *m.MaxAllDiffCutSize
	}
	return Default_SatParameters_MaxAllDiffCutSize
}

func (m *SatParameters) GetAddLinMaxCuts() bool {
	if m != nil && m.AddLinMaxCuts != nil {
		return *m.AddLinMaxCuts
	}
	return Default_SatParameters_AddLinMaxCuts
}

func (m *SatParameters) GetMaxIntegerRoundingScaling() int32 {
	if m != nil && m.MaxIntegerRoundingScaling != nil {
		return *m.MaxIntegerRoundingScaling
	}
	return Default_SatParameters_MaxIntegerRoundingScaling
}

func (m *SatParameters) GetAddLpConstraintsLazily() bool {
	if m != nil && m.AddLpConstraintsLazily != nil {
		return *m.AddLpConstraintsLazily
	}
	return Default_SatParameters_AddLpConstraintsLazily
}

func (m *SatParameters) GetMinOrthogonalityForLpConstraints() float64 {
	if m != nil && m.MinOrthogonalityForLpConstraints != nil {
		return *m.MinOrthogonalityForLpConstraints
	}
	return Default_SatParameters_MinOrthogonalityForLpConstraints
}

func (m *SatParameters) GetMaxCutRoundsAtLevelZero() int32 {
	if m != nil && m.MaxCutRoundsAtLevelZero != nil {
		return *m.MaxCutRoundsAtLevelZero
	}
	return Default_SatParameters_MaxCutRoundsAtLevelZero
}

func (m *SatParameters) GetMaxConsecutiveInactiveCount() int32 {
	if m != nil && m.MaxConsecutiveInactiveCount != nil {
		return *m.MaxConsecutiveInactiveCount
	}
	return Default_SatParameters_MaxConsecutiveInactiveCount
}

func (m *SatParameters) GetCutMaxActiveCountValue() float64 {
	if m != nil && m.CutMaxActiveCountValue != nil {
		return *m.CutMaxActiveCountValue
	}
	return Default_SatParameters_CutMaxActiveCountValue
}

func (m *SatParameters) GetCutActiveCountDecay() float64 {
	if m != nil && m.CutActiveCountDecay != nil {
		return *m.CutActiveCountDecay
	}
	return Default_SatParameters_CutActiveCountDecay
}

func (m *SatParameters) GetCutCleanupTarget() int32 {
	if m != nil && m.CutCleanupTarget != nil {
		return *m.CutCleanupTarget
	}
	return Default_SatParameters_CutCleanupTarget
}

func (m *SatParameters) GetNewConstraintsBatchSize() int32 {
	if m != nil && m.NewConstraintsBatchSize != nil {
		return *m.NewConstraintsBatchSize
	}
	return Default_SatParameters_NewConstraintsBatchSize
}

func (m *SatParameters) GetSearchBranching() SatParameters_SearchBranching {
	if m != nil && m.SearchBranching != nil {
		return *m.SearchBranching
	}
	return Default_SatParameters_SearchBranching
}

func (m *SatParameters) GetHintConflictLimit() int32 {
	if m != nil && m.HintConflictLimit != nil {
		return *m.HintConflictLimit
	}
	return Default_SatParameters_HintConflictLimit
}

func (m *SatParameters) GetExploitIntegerLpSolution() bool {
	if m != nil && m.ExploitIntegerLpSolution != nil {
		return *m.ExploitIntegerLpSolution
	}
	return Default_SatParameters_ExploitIntegerLpSolution
}

func (m *SatParameters) GetExploitAllLpSolution() bool {
	if m != nil && m.ExploitAllLpSolution != nil {
		return *m.ExploitAllLpSolution
	}
	return Default_SatParameters_ExploitAllLpSolution
}

func (m *SatParameters) GetExploitBestSolution() bool {
	if m != nil && m.ExploitBestSolution != nil {
		return *m.ExploitBestSolution
	}
	return Default_SatParameters_ExploitBestSolution
}

func (m *SatParameters) GetExploitRelaxationSolution() bool {
	if m != nil && m.ExploitRelaxationSolution != nil {
		return *m.ExploitRelaxationSolution
	}
	return Default_SatParameters_ExploitRelaxationSolution
}

func (m *SatParameters) GetExploitObjective() bool {
	if m != nil && m.ExploitObjective != nil {
		return *m.ExploitObjective
	}
	return Default_SatParameters_ExploitObjective
}

func (m *SatParameters) GetProbingPeriodAtRoot() int64 {
	if m != nil && m.ProbingPeriodAtRoot != nil {
		return *m.ProbingPeriodAtRoot
	}
	return Default_SatParameters_ProbingPeriodAtRoot
}

func (m *SatParameters) GetPseudoCostReliabilityThreshold() int64 {
	if m != nil && m.PseudoCostReliabilityThreshold != nil {
		return *m.PseudoCostReliabilityThreshold
	}
	return Default_SatParameters_PseudoCostReliabilityThreshold
}

func (m *SatParameters) GetOptimizeWithCore() bool {
	if m != nil && m.OptimizeWithCore != nil {
		return *m.OptimizeWithCore
	}
	return Default_SatParameters_OptimizeWithCore
}

func (m *SatParameters) GetBinarySearchNumConflicts() int32 {
	if m != nil && m.BinarySearchNumConflicts != nil {
		return *m.BinarySearchNumConflicts
	}
	return Default_SatParameters_BinarySearchNumConflicts
}

func (m *SatParameters) GetOptimizeWithMaxHs() bool {
	if m != nil && m.OptimizeWithMaxHs != nil {
		return *m.OptimizeWithMaxHs
	}
	return Default_SatParameters_OptimizeWithMaxHs
}

func (m *SatParameters) GetEnumerateAllSolutions() bool {
	if m != nil && m.EnumerateAllSolutions != nil {
		return *m.EnumerateAllSolutions
	}
	return Default_SatParameters_EnumerateAllSolutions
}

func (m *SatParameters) GetFillTightenedDomainsInResponse() bool {
	if m != nil && m.FillTightenedDomainsInResponse != nil {
		return *m.FillTightenedDomainsInResponse
	}
	return Default_SatParameters_FillTightenedDomainsInResponse
}

func (m *SatParameters) GetInstantiateAllVariables() bool {
	if m != nil && m.InstantiateAllVariables != nil {
		return *m.InstantiateAllVariables
	}
	return Default_SatParameters_InstantiateAllVariables
}

func (m *SatParameters) GetAutoDetectGreaterThanAtLeastOneOf() bool {
	if m != nil && m.AutoDetectGreaterThanAtLeastOneOf != nil {
		return *m.AutoDetectGreaterThanAtLeastOneOf
	}
	return Default_SatParameters_AutoDetectGreaterThanAtLeastOneOf
}

func (m *SatParameters) GetStopAfterFirstSolution() bool {
	if m != nil && m.StopAfterFirstSolution != nil {
		return *m.StopAfterFirstSolution
	}
	return Default_SatParameters_StopAfterFirstSolution
}

func (m *SatParameters) GetStopAfterPresolve() bool {
	if m != nil && m.StopAfterPresolve != nil {
		return *m.StopAfterPresolve
	}
	return Default_SatParameters_StopAfterPresolve
}

func (m *SatParameters) GetNumSearchWorkers() int32 {
	if m != nil && m.NumSearchWorkers != nil {
		return *m.NumSearchWorkers
	}
	return Default_SatParameters_NumSearchWorkers
}

func (m *SatParameters) GetInterleaveSearch() bool {
	if m != nil && m.InterleaveSearch != nil {
		return *m.InterleaveSearch
	}
	return Default_SatParameters_InterleaveSearch
}

func (m *SatParameters) GetInterleaveBatchSize() int32 {
	if m != nil && m.InterleaveBatchSize != nil {
		return *m.InterleaveBatchSize
	}
	return Default_SatParameters_InterleaveBatchSize
}

func (m *SatParameters) GetReduceMemoryUsageInInterleaveMode() bool {
	if m != nil && m.ReduceMemoryUsageInInterleaveMode != nil {
		return *m.ReduceMemoryUsageInInterleaveMode
	}
	return Default_SatParameters_ReduceMemoryUsageInInterleaveMode
}

func (m *SatParameters) GetShareObjectiveBounds() bool {
	if m != nil && m.ShareObjectiveBounds != nil {
		return *m.ShareObjectiveBounds
	}
	return Default_SatParameters_ShareObjectiveBounds
}

func (m *SatParameters) GetShareLevelZeroBounds() bool {
	if m != nil && m.ShareLevelZeroBounds != nil {
		return *m.ShareLevelZeroBounds
	}
	return Default_SatParameters_ShareLevelZeroBounds
}

func (m *SatParameters) GetUseLnsOnly() bool {
	if m != nil && m.UseLnsOnly != nil {
		return *m.UseLnsOnly
	}
	return Default_SatParameters_UseLnsOnly
}

func (m *SatParameters) GetLnsFocusOnDecisionVariables() bool {
	if m != nil && m.LnsFocusOnDecisionVariables != nil {
		return *m.LnsFocusOnDecisionVariables
	}
	return Default_SatParameters_LnsFocusOnDecisionVariables
}

func (m *SatParameters) GetUseRinsLns() bool {
	if m != nil && m.UseRinsLns != nil {
		return *m.UseRinsLns
	}
	return Default_SatParameters_UseRinsLns
}

func (m *SatParameters) GetUseFeasibilityPump() bool {
	if m != nil && m.UseFeasibilityPump != nil {
		return *m.UseFeasibilityPump
	}
	return Default_SatParameters_UseFeasibilityPump
}

func (m *SatParameters) GetFpRounding() SatParameters_FPRoundingMethod {
	if m != nil && m.FpRounding != nil {
		return *m.FpRounding
	}
	return Default_SatParameters_FpRounding
}

func (m *SatParameters) GetUseRelaxationLns() bool {
	if m != nil && m.UseRelaxationLns != nil {
		return *m.UseRelaxationLns
	}
	return Default_SatParameters_UseRelaxationLns
}

func (m *SatParameters) GetDiversifyLnsParams() bool {
	if m != nil && m.DiversifyLnsParams != nil {
		return *m.DiversifyLnsParams
	}
	return Default_SatParameters_DiversifyLnsParams
}

func (m *SatParameters) GetRandomizeSearch() bool {
	if m != nil && m.RandomizeSearch != nil {
		return *m.RandomizeSearch
	}
	return Default_SatParameters_RandomizeSearch
}

func (m *SatParameters) GetSearchRandomizationTolerance() int64 {
	if m != nil && m.SearchRandomizationTolerance != nil {
		return *m.SearchRandomizationTolerance
	}
	return Default_SatParameters_SearchRandomizationTolerance
}

func (m *SatParameters) GetUseOptionalVariables() bool {
	if m != nil && m.UseOptionalVariables != nil {
		return *m.UseOptionalVariables
	}
	return Default_SatParameters_UseOptionalVariables
}

func (m *SatParameters) GetUseExactLpReason() bool {
	if m != nil && m.UseExactLpReason != nil {
		return *m.UseExactLpReason
	}
	return Default_SatParameters_UseExactLpReason
}

func (m *SatParameters) GetUseBranchingInLp() bool {
	if m != nil && m.UseBranchingInLp != nil {
		return *m.UseBranchingInLp
	}
	return Default_SatParameters_UseBranchingInLp
}

func (m *SatParameters) GetUseCombinedNoOverlap() bool {
	if m != nil && m.UseCombinedNoOverlap != nil {
		return *m.UseCombinedNoOverlap
	}
	return Default_SatParameters_UseCombinedNoOverlap
}

func (m *SatParameters) GetCatchSigintSignal() bool {
	if m != nil && m.CatchSigintSignal != nil {
		return *m.CatchSigintSignal
	}
	return Default_SatParameters_CatchSigintSignal
}

func (m *SatParameters) GetUseImpliedBounds() bool {
	if m != nil && m.UseImpliedBounds != nil {
		return *m.UseImpliedBounds
	}
	return Default_SatParameters_UseImpliedBounds
}

func (m *SatParameters) GetMipMaxBound() float64 {
	if m != nil && m.MipMaxBound != nil {
		return *m.MipMaxBound
	}
	return Default_SatParameters_MipMaxBound
}

func (m *SatParameters) GetMipVarScaling() float64 {
	if m != nil && m.MipVarScaling != nil {
		return *m.MipVarScaling
	}
	return Default_SatParameters_MipVarScaling
}

func (m *SatParameters) GetMipAutomaticallyScaleVariables() bool {
	if m != nil && m.MipAutomaticallyScaleVariables != nil {
		return *m.MipAutomaticallyScaleVariables
	}
	return Default_SatParameters_MipAutomaticallyScaleVariables
}

func (m *SatParameters) GetMipWantedPrecision() float64 {
	if m != nil && m.MipWantedPrecision != nil {
		return *m.MipWantedPrecision
	}
	return Default_SatParameters_MipWantedPrecision
}

func (m *SatParameters) GetMipMaxActivityExponent() int32 {
	if m != nil && m.MipMaxActivityExponent != nil {
		return *m.MipMaxActivityExponent
	}
	return Default_SatParameters_MipMaxActivityExponent
}

func (m *SatParameters) GetMipCheckPrecision() float64 {
	if m != nil && m.MipCheckPrecision != nil {
		return *m.MipCheckPrecision
	}
	return Default_SatParameters_MipCheckPrecision
}

func init() {
	proto.RegisterEnum("operations_research.sat.SatParameters_VariableOrder", SatParameters_VariableOrder_name, SatParameters_VariableOrder_value)
	proto.RegisterEnum("operations_research.sat.SatParameters_Polarity", SatParameters_Polarity_name, SatParameters_Polarity_value)
	proto.RegisterEnum("operations_research.sat.SatParameters_ConflictMinimizationAlgorithm", SatParameters_ConflictMinimizationAlgorithm_name, SatParameters_ConflictMinimizationAlgorithm_value)
	proto.RegisterEnum("operations_research.sat.SatParameters_BinaryMinizationAlgorithm", SatParameters_BinaryMinizationAlgorithm_name, SatParameters_BinaryMinizationAlgorithm_value)
	proto.RegisterEnum("operations_research.sat.SatParameters_ClauseProtection", SatParameters_ClauseProtection_name, SatParameters_ClauseProtection_value)
	proto.RegisterEnum("operations_research.sat.SatParameters_ClauseOrdering", SatParameters_ClauseOrdering_name, SatParameters_ClauseOrdering_value)
	proto.RegisterEnum("operations_research.sat.SatParameters_RestartAlgorithm", SatParameters_RestartAlgorithm_name, SatParameters_RestartAlgorithm_value)
	proto.RegisterEnum("operations_research.sat.SatParameters_MaxSatAssumptionOrder", SatParameters_MaxSatAssumptionOrder_name, SatParameters_MaxSatAssumptionOrder_value)
	proto.RegisterEnum("operations_research.sat.SatParameters_MaxSatStratificationAlgorithm", SatParameters_MaxSatStratificationAlgorithm_name, SatParameters_MaxSatStratificationAlgorithm_value)
	proto.RegisterEnum("operations_research.sat.SatParameters_SearchBranching", SatParameters_SearchBranching_name, SatParameters_SearchBranching_value)
	proto.RegisterEnum("operations_research.sat.SatParameters_FPRoundingMethod", SatParameters_FPRoundingMethod_name, SatParameters_FPRoundingMethod_value)
	proto.RegisterType((*SatParameters)(nil), "operations_research.sat.SatParameters")
}

func init() { proto.RegisterFile("ortools/sat/sat_parameters.proto", fileDescriptor_0c726f7f6ef83bf4) }

var fileDescriptor_0c726f7f6ef83bf4 = []byte{
	// 4661 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x7a, 0xf9, 0x72, 0xdc, 0x46,
	0x92, 0xb7, 0x9a, 0x92, 0x1d, 0x76, 0xe9, 0x60, 0xb3, 0x28, 0x92, 0xa0, 0x24, 0xcb, 0x14, 0x2d,
	0x8f, 0xa5, 0x98, 0x31, 0xdd, 0x14, 0x45, 0x51, 0xa2, 0x4f, 0xb0, 0xbb, 0x29, 0x62, 0xd4, 0xd7,
	0xa0, 0x9b, 0x94, 0xa5, 0x99, 0x6f, 0xf0, 0x55, 0x03, 0xd5, 0x4d, 0x58, 0xb8, 0x06, 0x05, 0x50,
	0x4d, 0xed, 0xee, 0xcc, 0x1e, 0xb3, 0xde, 0x7b, 0x67, 0x77, 0xf6, 0x3e, 0x67, 0xef, 0xbf, 0xf7,
	0x51, 0xf6, 0x11, 0xf6, 0x51, 0x36, 0xb2, 0x0a, 0x05, 0x14, 0x9a, 0xa4, 0x43, 0x56, 0x84, 0x22,
	0xd8, 0xa8, 0xdf, 0x2f, 0x2b, 0x91, 0x95, 0x95, 0x95, 0x99, 0x28, 0xb4, 0x12, 0xc6, 0x49, 0x18,
	0x7a, 0xec, 0x23, 0x46, 0x12, 0xf8, 0x6f, 0x45, 0x24, 0x26, 0x3e, 0x4d, 0x68, 0xcc, 0xd6, 0xa2,
	0x38, 0x4c, 0x42, 0xbc, 0x14, 0x46, 0x34, 0x26, 0x89, 0x1b, 0x06, 0xcc, 0x8a, 0x29, 0xa3, 0x24,
	0xb6, 0x0f, 0xd7, 0x18, 0x49, 0x56, 0xff, 0xe7, 0x29, 0xba, 0xdc, 0x27, 0x49, 0x2f, 0x27, 0xe0,
	0x09, 0xd2, 0xa2, 0x98, 0x8e, 0x68, 0x1c, 0x53, 0xc7, 0x3a, 0x22, 0xb1, 0x4b, 0x86, 0x1e, 0xb5,
	0xc2, 0xd8, 0xa1, 0xb1, 0x56, 0x59, 0xa9, 0xdc, 0xb9, 0x72, 0xef, 0xfe, 0xda, 0x19, 0xd2, 0xd6,
	0x4a, 0x92, 0xd6, 0x0e, 0x32, 0x72, 0x17, 0xb8, 0xdb, 0x6f, 0x19, 0x1d, 0xab, 0x6b, 0x36, 0x9a,
	0xa6, 0xb9, 0x98, 0xcb, 0x2f, 0x21, 0xf0, 0x57, 0xa8, 0xea, 0x06, 0x6e, 0xe2, 0x12, 0xcf, 0x8a,
	0x42, 0x8f, 0xc4, 0x6e, 0x72, 0xac, 0xcd, 0xf0, 0x19, 0x3f, 0x7a, 0xcd, 0x19, 0x7b, 0x19, 0x6d,
	0xfb, 0x4a, 0xaf, 0xdb, 0xd2, 0x4d, 0x63, 0xf0, 0xcc, 0xda, 0xd5, 0x5b, 0xfd, 0xa6, 0x39, 0x9b,
	0x09, 0x96, 0x00, 0xbc, 0x86, 0xaa, 0x29, 0xa3, 0x56, 0x74, 0x48, 0x18, 0xb5, 0x18, 0x39, 0x72,
	0x83, 0xb1, 0xf6, 0xbd, 0x95, 0xca, 0x9d, 0xb7, 0xb6, 0x2f, 0x24, 0x71, 0x4a, 0xcd, 0x2b, 0x29,
	0xa3, 0x3d, 0x18, 0xec, 0xf3, 0x31, 0xbc, 0x89, 0x16, 0x62, 0x12, 0x38, 0xa1, 0x9f, 0xab, 0x66,
	0x71, 0x7d, 0xb4, 0x0f, 0x57, 0x2a, 0x77, 0x2a, 0xdb, 0x95, 0x9a, 0x39, 0x2f, 0xc6, 0xe5, 0x0c,
	0x26, 0x8c, 0x2a, 0xb4, 0x61, 0x4c, 0x02, 0xfb, 0x90, 0xb2, 0x8c, 0xb6, 0x32, 0x45, 0xdb, 0xc9,
	0x86, 0x05, 0x6d, 0x03, 0x61, 0xd0, 0x8e, 0xc6, 0x2f, 0x89, 0x75, 0x48, 0xd3, 0xd8, 0x65, 0x89,
	0x6b, 0x6b, 0x4f, 0xb8, 0x7e, 0x6f, 0x8c, 0x88, 0xc7, 0xa8, 0x09, 0xea, 0x37, 0xe3, 0x97, 0x64,
	0x4f, 0x0e, 0xe3, 0xcf, 0xd1, 0x35, 0x69, 0x3e, 0xb9, 0x6c, 0xcc, 0x22, 0x76, 0xe2, 0x1e, 0x81,
	0x21, 0x5b, 0x72, 0x42, 0x2d, 0x03, 0x49, 0xdb, 0x33, 0x3d, 0x83, 0xe0, 0xe7, 0xe8, 0x03, 0xe2,
	0xb1, 0xd0, 0x1a, 0xa6, 0x7e, 0xa4, 0x88, 0x70, 0x03, 0xcb, 0x0e, 0x83, 0x91, 0xe7, 0xda, 0x89,
	0x15, 0x53, 0xc2, 0xc2, 0x80, 0x69, 0x6d, 0x55, 0x95, 0x55, 0x60, 0xed, 0xa4, 0x7e, 0x94, 0x8b,
	0x34, 0x82, 0x7a, 0xc6, 0x30, 0x05, 0x01, 0x7f, 0x5d, 0x41, 0x8b, 0xbe, 0x1b, 0xb8, 0xbe, 0xfb,
	0x8a, 0x2f, 0xa3, 0x45, 0xbc, 0x71, 0x18, 0xbb, 0xc9, 0xa1, 0xaf, 0x5d, 0xe0, 0x4b, 0xdc, 0x78,
	0xcd, 0x25, 0x96, 0x82, 0xdb, 0x8a, 0x30, 0x5d, 0xca, 0xda, 0x7e, 0xdb, 0x6c, 0xd6, 0xf7, 0xcd,
	0xbe, 0x71, 0xd0, 0x34, 0x17, 0xfc, 0xd3, 0x10, 0xf8, 0x57, 0x15, 0xf4, 0xce, 0xd0, 0x0d, 0x48,
	0x7c, 0x6c, 0x9d, 0xa1, 0xcf, 0x2a, 0xd7, 0xe7, 0x8b, 0xd7, 0xd4, 0x67, 0x87, 0xcb, 0x02, 0x6d,
	0xa6, 0x75, 0x59, 0xde, 0x31, 0x3a, 0xba, 0xf9, 0xcc, 0x6a, 0x1b, 0x1d, 0xa3, 0x6d, 0x3c, 0xd7,
	0x07, 0x46, 0xb7, 0x63, 0xed, 0x1a, 0x66, 0x7f, 0x60, 0x5e, 0x1f, 0xe6, 0xac, 0x93, 0x1a, 0xee,
	0xa3, 0xdb, 0x2c, 0x1d, 0xb2, 0xd4, 0x8f, 0xb8, 0x62, 0x4e, 0x1a, 0xbb, 0xc1, 0xb8, 0x58, 0x02,
	0x12, 0x10, 0xef, 0x98, 0xb9, 0x4c, 0x7b, 0xa8, 0xb8, 0xeb, 0x2d, 0x85, 0xd1, 0xe0, 0x04, 0x69,
	0x27, 0x3d, 0x83, 0xe3, 0x47, 0x68, 0xc1, 0xf6, 0x08, 0xb8, 0x95, 0xed, 0x51, 0x12, 0xa4, 0x91,
	0x15, 0xd1, 0xd8, 0x0d, 0x1d, 0xed, 0xe2, 0x4a, 0xe5, 0xce, 0x1b, 0xdb, 0x6f, 0xac, 0xd7, 0x6a,
	0xb5, 0x9a, 0x39, 0x2f, 0x30, 0x75, 0x01, 0xe9, 0x71, 0xc4, 0x29, 0xd4, 0x84, 0xc4, 0x63, 0x9a,
	0x68, 0x97, 0xcf, 0xa6, 0x0e, 0x38, 0x02, 0xff, 0xbc, 0x82, 0x96, 0xa7, 0xa7, 0x8d, 0xc3, 0x84,
	0xda, 0xa0, 0xa9, 0xb6, 0xcd, 0x4d, 0xbd, 0xf5, 0xba, 0x4b, 0xcf, 0xe5, 0xf4, 0x72, 0xfa, 0xf6,
	0x6c, 0xcf, 0xec, 0x0e, 0x9a, 0x75, 0x6e, 0xd8, 0x4e, 0xb7, 0xd3, 0x34, 0x97, 0xca, 0xda, 0xe7,
	0x48, 0xbc, 0x8d, 0xb4, 0x29, 0x2d, 0xbc, 0xa1, 0x63, 0x0d, 0xc3, 0x34, 0x70, 0xb4, 0x8f, 0xf9,
	0x4b, 0x54, 0x36, 0xcd, 0x85, 0x12, 0xbb, 0x35, 0x74, 0x76, 0x60, 0x1c, 0xff, 0x14, 0x2d, 0x4d,
	0x71, 0x79, 0x30, 0x84, 0x88, 0xf1, 0x09, 0xd7, 0x7f, 0xf3, 0x5b, 0xe9, 0xdf, 0xcd, 0xc8, 0xdb,
	0xb3, 0xf5, 0x96, 0xbe, 0xdf, 0x6f, 0x5a, 0x7a, 0x7d, 0x60, 0x1c, 0x18, 0x83, 0x67, 0x53, 0xf3,
	0x4b, 0x1c, 0xde, 0x44, 0x57, 0xa3, 0x61, 0x3e, 0xb7, 0x1b, 0xd8, 0x31, 0xf5, 0x69, 0x90, 0x68,
	0x6b, 0x5c, 0xef, 0xf3, 0xf7, 0x6a, 0x35, 0x13, 0x47, 0xc3, 0x8c, 0x65, 0xc8, 0x61, 0xfc, 0x21,
	0xaa, 0x2a, 0x34, 0x11, 0x75, 0x3e, 0xe2, 0x41, 0xe0, 0x7c, 0x6d, 0x6d, 0xd3, 0xbc, 0x92, 0x53,
	0x44, 0xc8, 0x79, 0x8e, 0xee, 0x64, 0xfb, 0x81, 0x5a, 0x2f, 0xdd, 0xe4, 0x10, 0x96, 0x29, 0x22,
	0x63, 0xb1, 0x39, 0x62, 0xca, 0x12, 0x12, 0x27, 0xd2, 0x63, 0xfe, 0x3f, 0x9f, 0x79, 0x66, 0xbd,
	0x66, 0xde, 0x96, 0x9c, 0xa7, 0x6e, 0x72, 0xd8, 0x2b, 0x18, 0xa6, 0x20, 0x64, 0xfe, 0xf3, 0x1c,
	0x7d, 0x70, 0xb6, 0xec, 0x20, 0xf5, 0x2d, 0x87, 0xda, 0x2e, 0x03, 0xf3, 0x69, 0x84, 0x8b, 0xbe,
	0x00, 0x1e, 0x65, 0xbe, 0x77, 0x86, 0xf0, 0x4e, 0xea, 0x37, 0x24, 0x01, 0x7f, 0x8c, 0x96, 0xf2,
	0x43, 0x4a, 0x06, 0x3b, 0x90, 0x47, 0x8e, 0xb5, 0x59, 0xf9, 0xb6, 0x0f, 0xcd, 0x05, 0x89, 0x91,
	0xc1, 0xae, 0x01, 0x08, 0xdc, 0x44, 0xd7, 0x7d, 0x32, 0xb1, 0x4e, 0x0a, 0x38, 0x22, 0x5e, 0x4a,
	0xb5, 0x2a, 0x17, 0xf0, 0xe6, 0x3a, 0xfd, 0xee, 0x7a, 0xad, 0x66, 0x6a, 0x3e, 0x99, 0x1c, 0x4c,
	0x89, 0x39, 0x00, 0x1c, 0xae, 0xa1, 0xb9, 0xb1, 0x97, 0xda, 0x21, 0xa3, 0x16, 0x88, 0x13, 0xb3,
	0x2f, 0x72, 0xf2, 0x85, 0xda, 0xda, 0xa3, 0x4d, 0x73, 0x36, 0x1b, 0x6e, 0x93, 0x89, 0x98, 0xf8,
	0x13, 0xb4, 0x24, 0x19, 0x1c, 0xad, 0x2c, 0xeb, 0x92, 0xe4, 0xd5, 0xd6, 0xcd, 0x85, 0x0c, 0xc4,
	0x49, 0xc5, 0xd2, 0x1a, 0xe8, 0xe6, 0x19, 0x6c, 0xb9, 0x42, 0x9a, 0x30, 0xe3, 0x26, 0x98, 0xf1,
	0xfa, 0xa9, 0x42, 0x4e, 0x6c, 0xed, 0x29, 0xe3, 0xcd, 0x71, 0x35, 0xde, 0xa8, 0xad, 0x3d, 0x7a,
	0xf4, 0x48, 0x6e, 0xed, 0xb2, 0xf1, 0xbe, 0x40, 0xcb, 0xf0, 0xb6, 0xd3, 0x74, 0x61, 0x3a, 0x2c,
	0xe8, 0xeb, 0xf4, 0xbb, 0xf7, 0x6a, 0xe6, 0xa2, 0x4f, 0x26, 0xf5, 0x92, 0x04, 0x61, 0xb7, 0x11,
	0xc2, 0xd2, 0xb3, 0xf2, 0xf0, 0xcb, 0xb4, 0x4f, 0x57, 0xce, 0x7f, 0x8b, 0xa0, 0x90, 0x79, 0x5a,
	0x1e, 0x3e, 0xcd, 0xb9, 0x78, 0xea, 0x09, 0xc3, 0x3f, 0x43, 0xd7, 0x1c, 0x3a, 0x22, 0xa9, 0x97,
	0x58, 0xa7, 0xcc, 0xb7, 0xbb, 0x52, 0xb9, 0xf3, 0xf6, 0xb6, 0xde, 0xda, 0xdf, 0x79, 0x66, 0x99,
	0xcd, 0xfe, 0x40, 0x37, 0x07, 0xdf, 0x6b, 0xed, 0x34, 0xac, 0x76, 0xf7, 0xc0, 0xe8, 0x3c, 0xb6,
	0xf4, 0x83, 0xa6, 0xa9, 0x3f, 0x6e, 0xe6, 0x43, 0x8d, 0xd6, 0x19, 0x23, 0xa6, 0x96, 0x4d, 0x62,
	0x9e, 0x50, 0xe0, 0x2e, 0xba, 0x32, 0xb5, 0x85, 0x6e, 0x8a, 0x2d, 0xb4, 0x59, 0x33, 0x2f, 0xc7,
	0xa5, 0xbd, 0xa2, 0xa3, 0xeb, 0x12, 0x1a, 0xa7, 0x41, 0x00, 0xa1, 0xff, 0xa5, 0x1b, 0x38, 0xe1,
	0x4b, 0x8b, 0xb9, 0xaf, 0xa8, 0xf6, 0x59, 0xce, 0xd3, 0x32, 0x98, 0x29, 0x50, 0x4f, 0x39, 0xa8,
	0xef, 0xbe, 0xa2, 0x10, 0xec, 0xa4, 0x08, 0xc7, 0xb3, 0xc8, 0x11, 0x8d, 0xc9, 0x98, 0x66, 0x11,
	0xe0, 0x73, 0x91, 0x06, 0xac, 0x9b, 0x0b, 0x19, 0xa4, 0xe1, 0xe9, 0x02, 0x20, 0xc2, 0xc0, 0x27,
	0x68, 0x59, 0x72, 0x21, 0x42, 0x96, 0xc9, 0x8f, 0x25, 0x79, 0x31, 0xc3, 0xb4, 0x86, 0x4e, 0x89,
	0xbd, 0x85, 0xae, 0x82, 0x2f, 0x0c, 0xbd, 0xd0, 0x7e, 0x01, 0x9a, 0x67, 0x30, 0xed, 0x0b, 0x35,
	0x5d, 0x80, 0xd4, 0x66, 0x27, 0x43, 0x64, 0xa6, 0xc2, 0x4d, 0x74, 0x63, 0x9a, 0x54, 0x7a, 0x6d,
	0x5d, 0xf1, 0xe7, 0xe5, 0x61, 0x99, 0xac, 0xbc, 0x79, 0x1d, 0x5d, 0x3f, 0x21, 0xc6, 0x4f, 0xbd,
	0xc4, 0x8d, 0x3c, 0x97, 0xc6, 0xda, 0x8e, 0x08, 0x08, 0xeb, 0x6b, 0xf7, 0x4f, 0x08, 0x69, 0xe7,
	0x28, 0xdc, 0x47, 0xef, 0x43, 0x4c, 0x92, 0x07, 0x2e, 0xb3, 0x86, 0x74, 0x14, 0xc6, 0xd4, 0x62,
	0x49, 0x4c, 0x12, 0x3a, 0x3e, 0xb6, 0xec, 0x43, 0x12, 0x8c, 0x29, 0xd3, 0x1a, 0xe2, 0xe0, 0xa8,
	0x99, 0xb7, 0x82, 0xd4, 0x97, 0xe7, 0x2d, 0xdb, 0xe1, 0xe8, 0x7e, 0x06, 0xae, 0x0b, 0x2c, 0xde,
	0x45, 0x37, 0xa7, 0xf8, 0x62, 0xd3, 0x42, 0xfa, 0x29, 0x8c, 0xdb, 0x94, 0x09, 0xda, 0x75, 0x56,
	0xe2, 0x1a, 0x19, 0x4c, 0x58, 0xf8, 0x1e, 0x9a, 0x87, 0x4d, 0x97, 0xb8, 0x3e, 0x08, 0xb0, 0x18,
	0xb5, 0xc3, 0xc0, 0x61, 0xda, 0x6d, 0xf1, 0x66, 0x6e, 0x30, 0x32, 0xab, 0x3e, 0x99, 0x0c, 0x5c,
	0x9f, 0x1a, 0x41, 0x5f, 0x0c, 0xe2, 0x47, 0x68, 0x51, 0x84, 0xa5, 0x84, 0xc6, 0x10, 0x52, 0x21,
	0x5b, 0xe4, 0x12, 0xb4, 0x7a, 0x41, 0xbb, 0xea, 0x43, 0x6c, 0x52, 0x10, 0x20, 0x03, 0x7f, 0x1f,
	0x2d, 0x01, 0x35, 0x48, 0xfd, 0x21, 0x8d, 0xad, 0x70, 0x54, 0x58, 0x45, 0x7b, 0x7f, 0xa5, 0x72,
	0xe7, 0xfc, 0xf6, 0xfc, 0xa3, 0x7b, 0xf7, 0x36, 0x36, 0xb6, 0xee, 0xd5, 0x36, 0x1e, 0x3c, 0xdc,
	0xbc, 0xbf, 0xb5, 0xb5, 0xf9, 0xb0, 0xb6, 0xc5, 0x65, 0x75, 0x38, 0xa5, 0x3b, 0xca, 0xed, 0x02,
	0x29, 0x37, 0xc8, 0xf2, 0xa9, 0x1f, 0xc6, 0x10, 0xb2, 0x2c, 0x7f, 0xa8, 0xdd, 0xe1, 0x42, 0xb2,
	0x04, 0xe2, 0xb2, 0x4f, 0x26, 0x6d, 0x3e, 0x6a, 0x04, 0xed, 0x21, 0xae, 0x21, 0x4c, 0x86, 0x2c,
	0xf4, 0xd2, 0x84, 0x5a, 0x63, 0x12, 0x59, 0x9e, 0xeb, 0xbb, 0x89, 0xf6, 0xab, 0x8a, 0xb4, 0x53,
	0x55, 0x8e, 0x3e, 0x26, 0x51, 0x0b, 0xc6, 0x80, 0x11, 0x53, 0x8f, 0x24, 0xee, 0x91, 0xca, 0xf8,
	0x97, 0x82, 0x21, 0x47, 0x73, 0xc6, 0x13, 0xf4, 0x6e, 0x12, 0x53, 0x92, 0x58, 0x59, 0x4a, 0x28,
	0x82, 0x19, 0xb3, 0x18, 0x85, 0x12, 0x2a, 0xa1, 0xde, 0xb1, 0x76, 0x4b, 0x49, 0xb3, 0x6e, 0x70,
	0xb0, 0x48, 0xf9, 0x44, 0x40, 0x63, 0xfd, 0x1c, 0x89, 0x57, 0xd1, 0xc5, 0x2c, 0xd9, 0x67, 0x94,
	0x3a, 0xda, 0xbb, 0xc2, 0x3d, 0xd6, 0x4d, 0x24, 0x9e, 0xf6, 0x29, 0x75, 0xf0, 0x26, 0x9a, 0xf7,
	0xc2, 0xb1, 0x25, 0xc2, 0x19, 0x9c, 0x83, 0xe3, 0x98, 0x32, 0xa6, 0xdd, 0x55, 0x37, 0xc8, 0x9c,
	0x17, 0x8e, 0xfb, 0x1c, 0xd0, 0xcb, 0xc6, 0xf1, 0x3a, 0x9a, 0xe3, 0xe5, 0xca, 0x10, 0xdc, 0x1a,
	0x5e, 0x1a, 0xb2, 0xa7, 0xef, 0xaa, 0xa4, 0x59, 0x48, 0x8d, 0x86, 0x66, 0x3e, 0x8a, 0x7f, 0xa8,
	0x1c, 0xba, 0x31, 0x75, 0x52, 0x5b, 0xcd, 0x26, 0xcb, 0x82, 0x6a, 0xaa, 0xa0, 0xfc, 0xd4, 0x35,
	0x25, 0x49, 0x24, 0x94, 0x25, 0xe1, 0x7b, 0xe8, 0xa6, 0x1d, 0xa6, 0x41, 0x62, 0x11, 0x96, 0x27,
	0xaa, 0x1e, 0x3d, 0xa2, 0x1e, 0x2f, 0x17, 0xbc, 0xa1, 0xa3, 0xad, 0x2b, 0x66, 0xbb, 0xc6, 0xb1,
	0x7a, 0x0e, 0x6d, 0x71, 0xa4, 0x11, 0xb4, 0x86, 0x70, 0x00, 0x41, 0x39, 0xc8, 0x42, 0xef, 0x88,
	0x5a, 0xc3, 0x23, 0x6a, 0x25, 0x87, 0x31, 0x65, 0x87, 0xa1, 0xe7, 0x68, 0x0f, 0x44, 0x7e, 0xb3,
	0x59, 0xab, 0x99, 0x57, 0x25, 0x64, 0xe7, 0x88, 0x0e, 0x24, 0x00, 0x7f, 0x86, 0xae, 0x95, 0xa8,
	0xd9, 0x49, 0xf4, 0x92, 0xba, 0xe3, 0xc3, 0x44, 0xdb, 0x12, 0xe6, 0xdf, 0x30, 0x97, 0x14, 0xb2,
	0x58, 0xb4, 0xa7, 0x1c, 0x81, 0x7f, 0x84, 0xee, 0xe6, 0xfc, 0x28, 0x0e, 0x87, 0x60, 0x98, 0x93,
	0x9b, 0x24, 0xf3, 0xa2, 0x47, 0xdc, 0x89, 0x66, 0x36, 0x6a, 0xe6, 0xfb, 0x92, 0xd4, 0x13, 0x9c,
	0x13, 0xbb, 0x46, 0xb8, 0xd6, 0x27, 0x68, 0xa9, 0xd0, 0x0e, 0x82, 0x0d, 0x75, 0x32, 0x0d, 0xb5,
	0x2f, 0x15, 0xdb, 0x2c, 0xe4, 0xda, 0x09, 0x8c, 0xd0, 0x10, 0x36, 0x4b, 0xce, 0xe6, 0x21, 0xf5,
	0x88, 0x68, 0x7b, 0x6a, 0x7d, 0x2a, 0x47, 0xf7, 0x19, 0xdd, 0x39, 0x22, 0x78, 0xab, 0x64, 0x46,
	0xa2, 0x98, 0xd1, 0x90, 0x6e, 0xa8, 0x18, 0x91, 0x14, 0x46, 0xdc, 0x16, 0x3b, 0x3c, 0x27, 0xbb,
	0x89, 0x3c, 0x75, 0xb5, 0x3f, 0xac, 0x48, 0x13, 0x2e, 0xf8, 0x64, 0xd2, 0xcb, 0x10, 0x46, 0x0e,
	0x80, 0xbc, 0xc7, 0x8e, 0x2c, 0x3f, 0x74, 0xa8, 0x97, 0x0b, 0xd0, 0x0e, 0x14, 0x2d, 0x67, 0xed,
	0xa8, 0x0d, 0xa3, 0x92, 0x8b, 0xfb, 0xe8, 0xbd, 0x82, 0x11, 0xb2, 0x44, 0xcc, 0xc9, 0x73, 0xc2,
	0x51, 0xea, 0x79, 0x16, 0xff, 0x1d, 0x6b, 0xff, 0x56, 0x51, 0x3d, 0xf2, 0xa6, 0x94, 0x22, 0x09,
	0x90, 0x0f, 0xee, 0xa6, 0x9e, 0xd7, 0xe7, 0x68, 0xfc, 0x03, 0x74, 0x3b, 0x17, 0x9a, 0x45, 0xab,
	0xe2, 0x7d, 0x8a, 0x2c, 0x42, 0xfb, 0x9b, 0x8a, 0x0c, 0xd8, 0xef, 0x66, 0x12, 0xdb, 0x3c, 0x4e,
	0x49, 0xed, 0xba, 0x39, 0x14, 0x3f, 0x40, 0x8b, 0xca, 0x9b, 0x09, 0xd7, 0xe0, 0xfe, 0xad, 0x05,
	0x42, 0xc6, 0x3d, 0x73, 0x3e, 0x7f, 0x37, 0x3e, 0xcc, 0x7d, 0x1a, 0x7f, 0x86, 0x96, 0x73, 0x5e,
	0xca, 0x3b, 0x0b, 0x49, 0x61, 0x99, 0xff, 0xa7, 0x2e, 0x7b, 0xc6, 0xde, 0x67, 0x14, 0xf2, 0x19,
	0x69, 0x9f, 0x87, 0xe2, 0x00, 0x05, 0x9a, 0x1b, 0x44, 0x71, 0x68, 0x53, 0xc6, 0xa0, 0xd0, 0xf8,
	0xf7, 0xca, 0xf4, 0x09, 0xda, 0x27, 0x89, 0xa1, 0x20, 0x70, 0x1d, 0x5d, 0xa3, 0x93, 0x88, 0x04,
	0x8e, 0x45, 0x3d, 0x91, 0x0a, 0xda, 0x61, 0x00, 0x27, 0x89, 0x1b, 0x24, 0x4c, 0xfb, 0xe3, 0x8a,
	0x32, 0xb7, 0x26, 0x80, 0x4d, 0x81, 0xab, 0x17, 0x30, 0xfc, 0x18, 0xdd, 0xc8, 0x84, 0x90, 0x34,
	0x09, 0x7d, 0x92, 0x84, 0x41, 0x49, 0xcc, 0x2f, 0x54, 0x31, 0xd9, 0x7c, 0xba, 0x44, 0xaa, 0x82,
	0x3e, 0x47, 0xd9, 0x24, 0x56, 0xc2, 0x13, 0x6b, 0x55, 0xc8, 0x3f, 0xab, 0x42, 0x16, 0x05, 0x6c,
	0x00, 0x28, 0x55, 0x40, 0x0b, 0x5d, 0xf7, 0x69, 0x3c, 0xa6, 0x56, 0x10, 0x5a, 0xe1, 0x11, 0x8d,
	0x3d, 0x12, 0x59, 0x2f, 0xc3, 0xf8, 0x45, 0xb6, 0x1b, 0xff, 0x5c, 0xc4, 0xf4, 0xcb, 0xfc, 0xe0,
	0x90, 0xff, 0xcc, 0x25, 0x4e, 0xe9, 0x84, 0x5d, 0x41, 0x78, 0x1a, 0xc6, 0x2f, 0xc4, 0x5e, 0x34,
	0xd0, 0x0d, 0x21, 0x8d, 0x24, 0x96, 0x1f, 0xb2, 0xc4, 0x0a, 0x03, 0xaa, 0x8a, 0xfb, 0xa5, 0x10,
	0xf7, 0xf6, 0xfa, 0x94, 0x28, 0x3d, 0x69, 0x87, 0x2c, 0xe9, 0x06, 0xb4, 0x10, 0xb5, 0x83, 0xae,
	0xe7, 0xbe, 0x05, 0x45, 0x77, 0xe2, 0x26, 0x69, 0x11, 0xfe, 0xb4, 0xbf, 0xa8, 0xc8, 0xed, 0xb6,
	0x2c, 0x61, 0x7d, 0x05, 0x25, 0xbc, 0x64, 0x1b, 0x2d, 0xc2, 0x2a, 0x87, 0x51, 0x52, 0xf4, 0x1f,
	0x0e, 0xb9, 0x6d, 0xde, 0x53, 0x4c, 0x03, 0x9e, 0xd0, 0x55, 0x20, 0x7b, 0xdc, 0x30, 0x77, 0xd1,
	0xe5, 0x3c, 0xac, 0xdb, 0x61, 0x4c, 0xb5, 0x7b, 0x0a, 0xe5, 0x92, 0x1c, 0xaa, 0x87, 0x31, 0xc5,
	0xf7, 0xd1, 0xfc, 0xc8, 0x0d, 0x1c, 0x99, 0x01, 0x09, 0x3c, 0xd3, 0x06, 0x0a, 0x61, 0x0e, 0x00,
	0x59, 0xee, 0xc3, 0x49, 0x0c, 0x6f, 0x20, 0x6c, 0x83, 0xc5, 0x4b, 0xea, 0x69, 0xcf, 0x54, 0x12,
	0x1f, 0x57, 0x55, 0xc3, 0xbf, 0xa8, 0x20, 0x28, 0x8f, 0xb8, 0xe3, 0x2a, 0x47, 0x82, 0xe8, 0x1a,
	0x6e, 0xf0, 0x2a, 0xf9, 0x93, 0xd7, 0x4c, 0xe8, 0xdb, 0x64, 0xd2, 0x27, 0xca, 0x61, 0x21, 0xba,
	0x87, 0x5a, 0xa3, 0xb9, 0xab, 0xef, 0xb7, 0x06, 0x96, 0xde, 0xef, 0xef, 0xb7, 0x7b, 0xbc, 0xe4,
	0x17, 0xdd, 0x44, 0x88, 0x4d, 0x27, 0x09, 0xb8, 0x8d, 0x56, 0xa4, 0x42, 0x31, 0x3d, 0xa2, 0x31,
	0x94, 0x28, 0xd3, 0x8a, 0xdd, 0x57, 0x37, 0xd5, 0x0d, 0x21, 0xc7, 0x14, 0xe0, 0x69, 0x71, 0xbf,
	0xac, 0x88, 0x24, 0x0a, 0xe4, 0xf1, 0xfc, 0xcc, 0x1d, 0xb9, 0xb6, 0x30, 0xcd, 0xe6, 0xb7, 0xea,
	0x5f, 0x89, 0xd7, 0xeb, 0x97, 0x44, 0x14, 0x3d, 0xa3, 0xc5, 0xfe, 0xc0, 0xd4, 0x07, 0xc6, 0xae,
	0x51, 0x17, 0xed, 0xa2, 0x46, 0xb3, 0x5f, 0x6f, 0x76, 0x06, 0x3c, 0xa3, 0x3a, 0x41, 0xc3, 0x3f,
	0x46, 0x77, 0x79, 0x56, 0x10, 0x53, 0x9b, 0x3a, 0x34, 0xb0, 0x45, 0xb3, 0xce, 0x71, 0xd9, 0x57,
	0x69, 0x60, 0xf3, 0x2c, 0xa8, 0xd8, 0x77, 0xda, 0xf7, 0x95, 0x15, 0x7c, 0x9f, 0xf7, 0x51, 0x72,
	0x96, 0x11, 0x34, 0x0a, 0x4e, 0xb1, 0x0b, 0xf1, 0x08, 0x7d, 0xc8, 0xfd, 0x14, 0xb6, 0x53, 0x48,
	0x1c, 0xcb, 0x3e, 0xa4, 0xf6, 0x0b, 0x1a, 0xf3, 0x8e, 0x60, 0xea, 0xa7, 0x59, 0xa6, 0xa5, 0xcc,
	0xd1, 0x51, 0x0d, 0x7a, 0x07, 0xfc, 0x37, 0xa3, 0xd6, 0x05, 0xd3, 0x08, 0xea, 0x39, 0x4f, 0x99,
	0xe7, 0x27, 0x68, 0x03, 0xe6, 0x81, 0xd3, 0x56, 0x84, 0x0b, 0xea, 0x8c, 0xa9, 0x05, 0xae, 0x09,
	0x71, 0xf7, 0xcc, 0xd9, 0xba, 0xea, 0x6c, 0xa0, 0xe9, 0x40, 0x0a, 0x68, 0x3a, 0x63, 0xba, 0x2b,
	0xe8, 0xdf, 0x3c, 0xe5, 0xe9, 0xb6, 0x3a, 0x7b, 0xca, 0x9e, 0x62, 0xc4, 0xb5, 0x94, 0xd1, 0x53,
	0xed, 0x76, 0xc6, 0x94, 0xf7, 0xd0, 0xbc, 0xe7, 0x06, 0x94, 0xc4, 0x72, 0xcb, 0x8b, 0x88, 0xf1,
	0x5c, 0x06, 0x0c, 0x5c, 0x1a, 0x15, 0x91, 0x62, 0x0b, 0x2d, 0x0e, 0xc3, 0xd0, 0xa3, 0x24, 0xb0,
	0x68, 0x60, 0x87, 0x4e, 0x71, 0x0e, 0xbd, 0xc8, 0x8f, 0xf5, 0x0c, 0xd0, 0xcc, 0xc6, 0x05, 0xf1,
	0x03, 0x74, 0x49, 0x1e, 0x85, 0x76, 0x9a, 0x30, 0xed, 0x87, 0x6a, 0xa7, 0x0e, 0x89, 0xfc, 0xbc,
	0x9e, 0x26, 0x0c, 0xe2, 0x59, 0x18, 0x78, 0xc7, 0x16, 0x71, 0x1c, 0x8e, 0x84, 0x10, 0xc9, 0x67,
	0xb0, 0x5e, 0xd1, 0x38, 0xd4, 0x7e, 0xa4, 0xda, 0x78, 0x11, 0x90, 0xba, 0xe3, 0x00, 0x51, 0x4f,
	0xf8, 0x44, 0xcf, 0x69, 0x1c, 0x42, 0x76, 0x0a, 0xf4, 0x17, 0x01, 0x89, 0x18, 0xb1, 0x5f, 0x88,
	0x19, 0xc3, 0x52, 0x76, 0x4a, 0x1c, 0xe7, 0x49, 0x36, 0xcc, 0xa7, 0xbd, 0x8d, 0x2e, 0xf2, 0x19,
	0xc7, 0x02, 0x9c, 0x2a, 0x76, 0x7d, 0x9b, 0x38, 0x4e, 0x7d, 0xcc, 0x51, 0xdf, 0x41, 0x97, 0x00,
	0xe5, 0xbb, 0xb1, 0x80, 0x4d, 0x14, 0x18, 0x22, 0x8e, 0xd3, 0x76, 0x63, 0x8e, 0xbb, 0x8f, 0x20,
	0x0a, 0x58, 0xc4, 0xf3, 0x2c, 0xc7, 0x1d, 0x8d, 0x00, 0x2c, 0xea, 0xc6, 0xbf, 0xcc, 0xc2, 0xf1,
	0x96, 0x39, 0xe7, 0x93, 0x89, 0xee, 0x79, 0x0d, 0x77, 0x34, 0xaa, 0xa7, 0x09, 0xaf, 0x16, 0xd7,
	0x50, 0x15, 0xa4, 0x7b, 0x50, 0x8a, 0x90, 0x89, 0x98, 0xe1, 0x6f, 0xd5, 0xc3, 0xe9, 0x32, 0x71,
	0x9c, 0x96, 0x1b, 0xb4, 0xc9, 0x84, 0xcf, 0xd2, 0x40, 0x10, 0x23, 0x2c, 0x37, 0x48, 0xe8, 0x98,
	0xc6, 0x56, 0x1c, 0xa6, 0xc2, 0x41, 0x99, 0x4d, 0x3c, 0x38, 0xa4, 0x5f, 0x8a, 0x84, 0xf5, 0x01,
	0xd4, 0xa8, 0x3e, 0x99, 0x18, 0x02, 0x67, 0x66, 0xb0, 0xbe, 0x40, 0xe1, 0xcf, 0xd1, 0x32, 0x9f,
	0x35, 0x52, 0x0f, 0x45, 0xcb, 0x23, 0xaf, 0x5c, 0xef, 0x58, 0x8b, 0xd4, 0xa3, 0x11, 0x66, 0x8f,
	0x94, 0x43, 0xb1, 0xc5, 0x31, 0x78, 0x80, 0x6e, 0xfb, 0x2e, 0x84, 0xb0, 0xe4, 0x30, 0x1c, 0x87,
	0x01, 0xf1, 0xdc, 0xe4, 0xd8, 0x1a, 0x85, 0xf1, 0x94, 0x48, 0x8d, 0xe5, 0x8d, 0xa4, 0x4d, 0x73,
	0xc5, 0x77, 0x83, 0xae, 0x4a, 0xd8, 0x0d, 0xe3, 0x92, 0x6c, 0xac, 0x8b, 0x97, 0x03, 0xcb, 0xf1,
	0x17, 0x9b, 0x76, 0x84, 0xbf, 0xcf, 0x0f, 0x36, 0xc8, 0x17, 0xeb, 0x69, 0xc2, 0xdf, 0xab, 0xe4,
	0x06, 0x7b, 0xe8, 0x26, 0x17, 0x11, 0x06, 0x8c, 0xda, 0x29, 0xdf, 0x3a, 0x6e, 0x40, 0xe4, 0xe6,
	0x4a, 0x83, 0x44, 0x3b, 0x16, 0x16, 0x5a, 0xaf, 0xd5, 0xcc, 0xeb, 0x20, 0xa5, 0x40, 0x1a, 0x19,
	0xb0, 0x0e, 0x38, 0xbc, 0x87, 0xae, 0x81, 0x22, 0x7c, 0x4d, 0x15, 0x7e, 0xd6, 0x5b, 0xfa, 0x07,
	0x71, 0x5a, 0x5f, 0x54, 0x0e, 0x7f, 0x73, 0xd1, 0x4e, 0x93, 0x36, 0x99, 0xe8, 0x85, 0x10, 0xd1,
	0x62, 0x7a, 0x84, 0x60, 0xa4, 0x2c, 0x45, 0x34, 0xb8, 0xfe, 0xb1, 0x52, 0xb4, 0x07, 0xe7, 0xed,
	0x34, 0x51, 0xa8, 0xa2, 0xbf, 0x05, 0x07, 0x61, 0x9a, 0x4c, 0xb7, 0xbc, 0xff, 0xa9, 0xa2, 0x74,
	0x28, 0xab, 0x76, 0x9a, 0x94, 0xfb, 0xdd, 0x9f, 0xa3, 0x6b, 0x01, 0x7d, 0x59, 0x5a, 0xda, 0x21,
	0x49, 0xec, 0x43, 0xe1, 0x8e, 0xaf, 0xf2, 0xee, 0xcd, 0x52, 0x40, 0x5f, 0x2a, 0xe6, 0xdf, 0x01,
	0x0c, 0x77, 0x4a, 0x86, 0xaa, 0x59, 0x71, 0x28, 0xbe, 0x18, 0x81, 0x63, 0x99, 0xfc, 0x84, 0x79,
	0xf0, 0x9a, 0x27, 0x8c, 0x28, 0x1d, 0x77, 0x24, 0x7b, 0xbb, 0xaa, 0xef, 0x0f, 0xba, 0x6d, 0x7d,
	0x60, 0xd4, 0xad, 0x7e, 0x53, 0x37, 0xeb, 0x7b, 0xe6, 0x2c, 0x2b, 0x43, 0xf0, 0x06, 0x9a, 0x87,
	0xfc, 0xa3, 0xf8, 0xc8, 0x20, 0xd2, 0xa2, 0xbf, 0xab, 0xe4, 0x8d, 0xde, 0x39, 0x18, 0x97, 0xb5,
	0xbc, 0xc8, 0x84, 0xea, 0xe8, 0x3a, 0x9d, 0x44, 0x5e, 0xe8, 0x26, 0xf9, 0x96, 0xf0, 0x22, 0x2b,
	0x2f, 0x2a, 0x7f, 0x3c, 0x95, 0x71, 0x02, 0x30, 0xdb, 0x12, 0xad, 0xa8, 0x2f, 0x0b, 0xc9, 0x8f,
	0xd1, 0x92, 0x14, 0x02, 0xbb, 0x57, 0x15, 0x90, 0xa8, 0xb9, 0x50, 0x06, 0xd2, 0x3d, 0x4f, 0x21,
	0x6f, 0xa3, 0x05, 0x49, 0x1e, 0x52, 0x96, 0x14, 0xd4, 0xdf, 0x2e, 0xa5, 0xcb, 0xf3, 0x19, 0x68,
	0x87, 0xb2, 0x24, 0xe7, 0xee, 0x16, 0xda, 0xc7, 0xd4, 0x23, 0x13, 0x11, 0x92, 0x73, 0x09, 0xff,
	0x5a, 0x92, 0xb0, 0x9c, 0x41, 0xcd, 0x1c, 0x99, 0xcb, 0xb9, 0x87, 0xe6, 0xa4, 0x9c, 0x70, 0xf8,
	0x15, 0xe5, 0x4e, 0xa4, 0xfd, 0x8e, 0x1a, 0x45, 0xaa, 0xd9, 0x78, 0x57, 0x0e, 0x8b, 0x62, 0x4d,
	0x14, 0x15, 0xa2, 0x1d, 0x08, 0x7b, 0x2d, 0x0e, 0xc3, 0x44, 0xfb, 0xd3, 0x0a, 0x6f, 0x88, 0x54,
	0x6a, 0xe6, 0x7c, 0x86, 0x10, 0x6d, 0x41, 0x3d, 0x31, 0xc3, 0x30, 0xc1, 0x1d, 0x74, 0x2b, 0x62,
	0x34, 0x75, 0x42, 0xcb, 0x86, 0x2c, 0x36, 0xa6, 0x9e, 0x4b, 0x86, 0x2e, 0x0f, 0x00, 0x45, 0xc1,
	0xf7, 0x6b, 0x5c, 0x04, 0xdf, 0x64, 0x37, 0x05, 0xba, 0x1e, 0x32, 0x50, 0x5d, 0x62, 0x8b, 0xe2,
	0x6f, 0x03, 0xe1, 0x2c, 0xcb, 0xcb, 0x8a, 0x30, 0x9e, 0x51, 0xf6, 0x4b, 0xdf, 0x19, 0x25, 0x00,
	0x8a, 0x2e, 0x9e, 0x56, 0xea, 0x28, 0xfb, 0x7c, 0x25, 0xbb, 0x18, 0xa5, 0x6e, 0x99, 0x66, 0x0b,
	0x9f, 0xf9, 0x70, 0xdd, 0xd4, 0x04, 0x4c, 0xf8, 0x63, 0x47, 0x69, 0x91, 0xe1, 0x07, 0xe8, 0x6a,
	0x79, 0x5e, 0xd8, 0xe9, 0x87, 0x4c, 0xdb, 0x2f, 0xb5, 0x41, 0xd4, 0x99, 0xdb, 0x64, 0xb2, 0xc7,
	0xf0, 0xa7, 0x68, 0x89, 0x06, 0xa9, 0x0f, 0xbb, 0x80, 0x72, 0x7f, 0x91, 0xeb, 0xc5, 0xb4, 0xa7,
	0x2a, 0x75, 0x21, 0x47, 0xe9, 0xbc, 0x4a, 0x14, 0x18, 0x6c, 0xa2, 0xd5, 0x91, 0xeb, 0x79, 0x56,
	0x02, 0xe5, 0x3f, 0x0d, 0xa8, 0x63, 0x39, 0xa1, 0x4f, 0xdc, 0x80, 0xa7, 0x4d, 0x31, 0x65, 0x11,
	0xc4, 0x23, 0xed, 0xe7, 0xe5, 0xe2, 0x13, 0x18, 0x03, 0x49, 0x68, 0x08, 0xbc, 0x11, 0x98, 0x19,
	0x1a, 0x7f, 0x81, 0x96, 0xdd, 0x80, 0x25, 0x24, 0x48, 0x5c, 0xa9, 0x54, 0xfe, 0xe9, 0x54, 0xfb,
	0x4a, 0x71, 0x83, 0x25, 0x05, 0xa6, 0x7b, 0xc5, 0xe7, 0x57, 0xfc, 0x0c, 0xdd, 0x81, 0x6a, 0x8b,
	0xb7, 0x1e, 0xec, 0xc4, 0x1a, 0xc7, 0x94, 0x24, 0x34, 0xb6, 0x92, 0x43, 0x12, 0x88, 0x18, 0x4c,
	0xb2, 0x82, 0x25, 0x1c, 0x69, 0x96, 0xfa, 0xcd, 0x0f, 0x58, 0x0d, 0x4e, 0x7a, 0x2c, 0x38, 0x83,
	0x43, 0x12, 0x40, 0x40, 0x26, 0xbc, 0x66, 0xe9, 0x8e, 0x40, 0x39, 0x96, 0x84, 0x91, 0x45, 0x46,
	0x20, 0x71, 0xe4, 0xc6, 0xea, 0x26, 0x19, 0x96, 0x8e, 0x76, 0xc0, 0xe9, 0x00, 0xdb, 0x05, 0x54,
	0xee, 0xde, 0x0f, 0xd0, 0xbc, 0x22, 0x21, 0x2f, 0x65, 0xff, 0xaa, 0x64, 0xa3, 0xb9, 0x9c, 0x9c,
	0x17, 0xb2, 0x1f, 0x21, 0x0c, 0x6e, 0x91, 0x79, 0x08, 0x94, 0x5a, 0x34, 0x66, 0x9a, 0x23, 0xcf,
	0x90, 0x6a, 0x90, 0xfa, 0xc2, 0x2f, 0x9e, 0x8a, 0x21, 0xbc, 0x81, 0xe6, 0x20, 0x8a, 0xc4, 0x1e,
	0x25, 0x50, 0x59, 0xf1, 0x31, 0xed, 0xf7, 0x4b, 0xd3, 0x54, 0x0b, 0x80, 0xe0, 0xe2, 0x07, 0x68,
	0x41, 0x21, 0x29, 0x81, 0xf6, 0xeb, 0xfc, 0xb4, 0x9a, 0x2f, 0x00, 0x45, 0x90, 0x7d, 0x86, 0xbe,
	0xc3, 0x5b, 0x62, 0x54, 0x76, 0x23, 0x53, 0x46, 0x78, 0x47, 0xd6, 0x52, 0xc4, 0x41, 0x15, 0xaf,
	0xfd, 0x49, 0x49, 0x83, 0x5b, 0x82, 0x25, 0x9a, 0x94, 0xfb, 0xc0, 0x31, 0x02, 0x23, 0x67, 0x40,
	0x41, 0x0f, 0xb5, 0x1d, 0x3b, 0x24, 0x31, 0x2d, 0xa2, 0x81, 0xf8, 0xcc, 0xc8, 0xb4, 0x9f, 0xa8,
	0xf1, 0x8c, 0x63, 0xf2, 0x88, 0xc0, 0x3f, 0x34, 0xf2, 0x6f, 0x59, 0x82, 0x5b, 0x9c, 0xbb, 0x92,
	0x1c, 0x9f, 0x20, 0xe7, 0xe7, 0x6e, 0x46, 0xfe, 0x00, 0x5d, 0x82, 0x8c, 0xd6, 0x0b, 0x98, 0x05,
	0x69, 0x9a, 0x46, 0x55, 0xc5, 0x51, 0xca, 0x68, 0x2b, 0x60, 0xdd, 0xc0, 0x3b, 0xc6, 0x4f, 0xd0,
	0xbb, 0x00, 0x1a, 0x85, 0x76, 0x0a, 0xd0, 0xfc, 0xe3, 0x9b, 0xe2, 0xb7, 0xae, 0xca, 0xbd, 0xee,
	0x05, 0x6c, 0x17, 0xc0, 0xdd, 0x40, 0x7e, 0x76, 0x2b, 0x9c, 0x37, 0x9b, 0x35, 0x86, 0x4d, 0xe4,
	0x05, 0x4c, 0xfb, 0x2d, 0x35, 0xf2, 0xc1, 0xac, 0xa6, 0x1b, 0xb0, 0x56, 0xc0, 0xe4, 0xa7, 0x81,
	0x11, 0x25, 0xcc, 0xcd, 0x42, 0x56, 0x94, 0xfa, 0x91, 0xf6, 0x1f, 0x2a, 0x01, 0xa7, 0x8c, 0xee,
	0x16, 0x88, 0x5e, 0xea, 0x47, 0x38, 0x44, 0x17, 0x47, 0x51, 0x9e, 0x6c, 0x69, 0xff, 0x59, 0xf9,
	0x56, 0xdf, 0x8c, 0x77, 0x7b, 0x32, 0xff, 0x6a, 0xd3, 0xe4, 0x30, 0x74, 0xb6, 0xaf, 0xf6, 0xcc,
	0x6e, 0x4f, 0x7f, 0x2c, 0xca, 0x2b, 0xbd, 0xdf, 0x37, 0xfa, 0x83, 0x66, 0xc3, 0x44, 0xa3, 0x48,
	0xe2, 0xf0, 0x7d, 0x71, 0xf9, 0x42, 0x39, 0x15, 0xe0, 0xc5, 0xfe, 0xba, 0x32, 0x7d, 0xfb, 0xa2,
	0x38, 0x0c, 0xe0, 0xfd, 0x1e, 0xa2, 0xab, 0x8e, 0x0b, 0xa5, 0xa3, 0x3b, 0x3a, 0xe6, 0x8b, 0xc0,
	0xef, 0xe0, 0x30, 0xed, 0x0f, 0xca, 0x9d, 0x9b, 0x1c, 0xd3, 0x0a, 0x18, 0x57, 0x93, 0xe1, 0x1a,
	0xaa, 0x8a, 0x06, 0x31, 0x44, 0xc3, 0xcc, 0xf1, 0xc7, 0xa5, 0xe4, 0x39, 0x1f, 0xce, 0xdc, 0xfe,
	0x31, 0xba, 0x99, 0x6d, 0x2c, 0x39, 0x22, 0xf4, 0x4c, 0x42, 0x8f, 0xc2, 0x99, 0x4e, 0xb5, 0x43,
	0x79, 0x8c, 0xdc, 0x10, 0x40, 0x53, 0xc5, 0x0d, 0x24, 0x4c, 0x6d, 0x44, 0x40, 0x5e, 0xa8, 0x78,
	0x80, 0x77, 0x4a, 0x23, 0x02, 0x20, 0xc5, 0xca, 0x6f, 0xa0, 0x79, 0x7e, 0x47, 0x65, 0x42, 0x20,
	0x5f, 0x88, 0xb2, 0xab, 0x21, 0x9a, 0xaf, 0x9e, 0x7c, 0x29, 0xa3, 0x4d, 0x18, 0x6f, 0x45, 0xe2,
	0x1e, 0x08, 0xde, 0x14, 0xa4, 0x3c, 0xb5, 0xe1, 0xdd, 0xe2, 0x48, 0xfb, 0xa3, 0x13, 0xc6, 0xcd,
	0x73, 0x13, 0x23, 0x68, 0x45, 0x10, 0xf7, 0xf9, 0xf7, 0xf7, 0xd0, 0x1f, 0xba, 0x10, 0xb6, 0x8b,
	0xa6, 0x90, 0xf6, 0xbb, 0x25, 0x2a, 0xa8, 0x5a, 0xcf, 0x50, 0x79, 0x1f, 0x08, 0x66, 0xb5, 0xb3,
	0xd8, 0x30, 0x86, 0x34, 0x87, 0xb9, 0xe3, 0x80, 0x78, 0xda, 0xef, 0x55, 0x4a, 0x4d, 0x0d, 0x11,
	0x1d, 0x00, 0xd0, 0xe7, 0xe3, 0xf2, 0x16, 0x8e, 0xeb, 0x47, 0x9e, 0x4b, 0x1d, 0xb9, 0x13, 0xff,
	0xac, 0x32, 0xf5, 0x86, 0x86, 0x18, 0xcf, 0xb6, 0xe1, 0xf7, 0xd0, 0x65, 0xdf, 0x8d, 0xf8, 0x81,
	0x26, 0xae, 0x17, 0xfc, 0x3a, 0x4f, 0x33, 0xdf, 0x92, 0xc9, 0xaa, 0x79, 0xd1, 0x77, 0xa3, 0x36,
	0x99, 0x88, 0xbb, 0x05, 0x77, 0xd1, 0x2c, 0xa0, 0x8f, 0x48, 0x9c, 0x57, 0x11, 0xbf, 0x21, 0x3f,
	0xb2, 0x81, 0x9c, 0x03, 0x12, 0xcb, 0xba, 0xa1, 0x87, 0x6e, 0x01, 0x34, 0x6b, 0xcc, 0xb9, 0x36,
	0xf1, 0xbc, 0x63, 0x4e, 0xa2, 0xca, 0xb2, 0xfd, 0x97, 0xaa, 0xdc, 0x4d, 0xdf, 0x8d, 0x74, 0x15,
	0x0e, 0xa2, 0x68, 0xb1, 0x82, 0x5b, 0xe8, 0x2a, 0x48, 0x7c, 0x49, 0x82, 0x84, 0x3a, 0xbc, 0x8b,
	0xc0, 0x37, 0xb7, 0xf6, 0x53, 0xf9, 0xed, 0xf6, 0xc3, 0xda, 0x03, 0x13, 0xfb, 0x6e, 0xf4, 0x94,
	0x23, 0x7a, 0x12, 0x80, 0x3f, 0x45, 0xcb, 0xf2, 0x1d, 0xf3, 0xcf, 0xbe, 0x74, 0x12, 0x85, 0x01,
	0x0d, 0x12, 0xed, 0x67, 0x59, 0x8e, 0xbb, 0x61, 0x2e, 0x8a, 0x37, 0x95, 0xdf, 0x7c, 0x9b, 0x19,
	0x02, 0x6f, 0xa1, 0x79, 0xa0, 0xf3, 0x6e, 0x82, 0x32, 0xed, 0x6f, 0x8a, 0x84, 0xfc, 0xcd, 0xda,
	0x5a, 0xad, 0x56, 0x5b, 0x37, 0xe7, 0x7c, 0x37, 0xe2, 0x6d, 0x83, 0x7c, 0xde, 0xd5, 0x3d, 0x74,
	0xb9, 0x7c, 0x63, 0xec, 0x12, 0xca, 0x6f, 0x95, 0x55, 0xcf, 0xe1, 0xab, 0xa8, 0x6a, 0x74, 0x2c,
	0xb3, 0x79, 0xd0, 0x34, 0xfb, 0xcd, 0xec, 0x69, 0x05, 0xcf, 0xa3, 0x59, 0x78, 0xaa, 0x77, 0x1a,
	0xdd, 0x76, 0xf6, 0x70, 0x66, 0xf5, 0xeb, 0x0a, 0x7a, 0x2b, 0xbf, 0x0b, 0x36, 0x87, 0x2e, 0xe7,
	0xd7, 0xc5, 0x06, 0xe6, 0x7e, 0xb3, 0x7a, 0x0e, 0x63, 0x34, 0x75, 0x83, 0x4c, 0x08, 0xca, 0x9f,
	0x09, 0x71, 0xd5, 0x19, 0x7c, 0x0d, 0x2d, 0xe6, 0x0f, 0x9f, 0x36, 0x8d, 0xc7, 0x7b, 0x83, 0x66,
	0xc3, 0xea, 0x1b, 0x8f, 0x3b, 0xd5, 0xf3, 0x78, 0x15, 0xdd, 0x2c, 0x08, 0x99, 0x56, 0x65, 0xcc,
	0x85, 0xd5, 0x03, 0xf4, 0xce, 0x37, 0xde, 0x68, 0xc2, 0x6f, 0xa1, 0x0b, 0x9d, 0x6e, 0x07, 0x74,
	0x42, 0xe8, 0xcd, 0xbe, 0xd1, 0xee, 0xb5, 0x40, 0x97, 0xcb, 0xa8, 0xb8, 0xe9, 0x54, 0x9d, 0xc1,
	0x55, 0x74, 0xa9, 0xf9, 0x65, 0xaf, 0x69, 0x1a, 0xed, 0x66, 0x67, 0xa0, 0xb7, 0xaa, 0xe7, 0x57,
	0xff, 0xb7, 0x82, 0x96, 0xcf, 0xbc, 0x9a, 0x04, 0x5a, 0x77, 0xba, 0xd6, 0x29, 0xf7, 0x93, 0xaa,
	0xe7, 0xf0, 0x3b, 0xe8, 0xec, 0x8b, 0x4b, 0xd5, 0x0a, 0xde, 0x42, 0x1b, 0x67, 0x0e, 0x5b, 0x4f,
	0x8d, 0xc1, 0x9e, 0x35, 0x30, 0xf5, 0x4e, 0xdf, 0x18, 0x18, 0x07, 0x4d, 0xcb, 0x6c, 0x36, 0xf6,
	0xf9, 0xf5, 0x9c, 0xea, 0x05, 0x7c, 0x17, 0xbd, 0x7f, 0x1a, 0x91, 0x53, 0xcc, 0xa6, 0x5e, 0xdf,
	0xd3, 0x77, 0x8c, 0x96, 0x31, 0x78, 0x56, 0x9d, 0xc1, 0xb7, 0xd1, 0x8a, 0xfa, 0x3a, 0xa7, 0x2a,
	0x7a, 0x7e, 0xd5, 0x44, 0xd5, 0xe9, 0x1b, 0x41, 0x7c, 0x8d, 0xca, 0x77, 0x82, 0xaa, 0xe7, 0xf0,
	0x02, 0x9a, 0x53, 0x1e, 0xea, 0xad, 0xa7, 0xfa, 0xb3, 0x7e, 0xb5, 0xc2, 0xd7, 0xb8, 0x78, 0xdc,
	0xda, 0x69, 0x54, 0x67, 0x56, 0x37, 0xd1, 0x95, 0xf2, 0x2d, 0x1d, 0x90, 0x38, 0x75, 0x4f, 0xa7,
	0x7a, 0x0e, 0x5f, 0x41, 0x28, 0x7b, 0x08, 0xb4, 0x0a, 0xb8, 0x53, 0x75, 0xfa, 0xab, 0x3f, 0x80,
	0x3a, 0x5d, 0x79, 0x39, 0xa0, 0x7a, 0x0e, 0x16, 0x49, 0xbd, 0x63, 0x50, 0xad, 0x80, 0xa9, 0xcf,
	0xbc, 0x4d, 0x50, 0x9d, 0xc1, 0x37, 0xd1, 0xb5, 0xb3, 0xef, 0x21, 0x54, 0xcf, 0x83, 0xdf, 0xee,
	0x1a, 0x5f, 0x36, 0x1b, 0xf9, 0xa3, 0x0b, 0xab, 0x09, 0x5a, 0x38, 0xb5, 0x7f, 0x8a, 0x6f, 0xa0,
	0x33, 0x3b, 0xa8, 0x62, 0xcd, 0xf9, 0x9f, 0xea, 0xd8, 0xce, 0x33, 0xab, 0xd1, 0xec, 0x0d, 0xf6,
	0xaa, 0x15, 0x50, 0xe4, 0xb4, 0x61, 0xe1, 0xcb, 0xd5, 0x99, 0xd5, 0x10, 0xbd, 0xf3, 0x8d, 0x6d,
	0x4d, 0xbc, 0x84, 0xe6, 0xa7, 0x1a, 0x9b, 0xd9, 0xd2, 0x5c, 0x43, 0x67, 0x74, 0x3c, 0xab, 0x15,
	0xbc, 0x8c, 0x16, 0xa6, 0xc6, 0x74, 0x31, 0x34, 0xb3, 0xfa, 0xdf, 0x15, 0x34, 0x3b, 0x55, 0xe6,
	0xc2, 0xee, 0x9f, 0x2e, 0x74, 0x85, 0xd1, 0x85, 0x8d, 0xb2, 0x27, 0x15, 0xc0, 0xf5, 0xba, 0xe6,
	0x60, 0xb7, 0xdb, 0x32, 0xba, 0xf2, 0xe9, 0x0c, 0x6c, 0xa8, 0x56, 0x4f, 0xfe, 0x3c, 0x8f, 0x17,
	0x11, 0xee, 0xf5, 0x9b, 0xfb, 0x8d, 0xae, 0x55, 0xef, 0xf6, 0x07, 0xf2, 0xf9, 0x05, 0xfc, 0x01,
	0x7a, 0xaf, 0x20, 0x73, 0xd7, 0xfd, 0xc1, 0xbe, 0x51, 0x7f, 0x22, 0x57, 0x40, 0x02, 0xdf, 0xc0,
	0xb3, 0xe8, 0xe2, 0x9e, 0xd1, 0xc9, 0x1f, 0xbc, 0xb9, 0x7a, 0x88, 0xaa, 0xd3, 0xb9, 0x08, 0xf8,
	0x56, 0xa7, 0xa9, 0x03, 0xd7, 0x32, 0x3a, 0x83, 0xe6, 0x63, 0xbe, 0x16, 0x57, 0x10, 0x6a, 0x75,
	0xeb, 0x4f, 0xac, 0x1d, 0xbd, 0xdf, 0x6c, 0x54, 0x2b, 0xe0, 0xbd, 0xdc, 0xf3, 0x9a, 0x96, 0xf2,
	0xf8, 0x3c, 0xd6, 0xd0, 0xa9, 0x99, 0x4c, 0x75, 0x66, 0x67, 0x0d, 0x2d, 0xda, 0xa1, 0xbf, 0x36,
	0x0e, 0xc3, 0xb1, 0x47, 0xd7, 0xb2, 0xab, 0xc1, 0x90, 0x1a, 0xf5, 0x2a, 0xcf, 0xb1, 0xbc, 0x29,
	0x3c, 0x0e, 0xf9, 0x65, 0xe1, 0x31, 0x0d, 0xfe, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x68, 0xff, 0x0c,
	0x28, 0x3e, 0x2c, 0x00, 0x00,
}
