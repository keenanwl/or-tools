// Code generated by protoc-gen-go. DO NOT EDIT.
// source: ortools/sat/cp_model.proto

package gen

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// The status returned by a solver trying to solve a CpModelProto.
type CpSolverStatus int32

const (
	// The status of the model is still unknown. A search limit has been reached
	// before any of the statuses below could be determined.
	CpSolverStatus_UNKNOWN CpSolverStatus = 0
	// The given CpModelProto didn't pass the validation step. You can get a
	// detailed error by calling ValidateCpModel(model_proto).
	CpSolverStatus_MODEL_INVALID CpSolverStatus = 1
	// A feasible solution as been found. But the search was stopped before we
	// could prove optimality or before we enumerated all solutions of a
	// feasibility problem (if asked).
	CpSolverStatus_FEASIBLE CpSolverStatus = 2
	// The problem has been proven infeasible.
	CpSolverStatus_INFEASIBLE CpSolverStatus = 3
	// An optimal feasible solution has been found.
	//
	// More generally, this status represent a success. So we also return OPTIMAL
	// if we find a solution for a pure feasiblity problem or if a gap limit has
	// been specified and we return a solution within this limit. In the case
	// where we need to return all the feasible solution, this status will only be
	// returned if we enumerated all of them; If we stopped before, we will return
	// FEASIBLE.
	CpSolverStatus_OPTIMAL CpSolverStatus = 4
)

var CpSolverStatus_name = map[int32]string{
	0: "UNKNOWN",
	1: "MODEL_INVALID",
	2: "FEASIBLE",
	3: "INFEASIBLE",
	4: "OPTIMAL",
}

var CpSolverStatus_value = map[string]int32{
	"UNKNOWN":       0,
	"MODEL_INVALID": 1,
	"FEASIBLE":      2,
	"INFEASIBLE":    3,
	"OPTIMAL":       4,
}

func (x CpSolverStatus) String() string {
	return proto.EnumName(CpSolverStatus_name, int32(x))
}

func (CpSolverStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{0}
}

// The order in which the variables above should be considered. Note that only
// variables that are not already fixed are considered.
//
// TODO(user): extend as needed.
type DecisionStrategyProto_VariableSelectionStrategy int32

const (
	DecisionStrategyProto_CHOOSE_FIRST           DecisionStrategyProto_VariableSelectionStrategy = 0
	DecisionStrategyProto_CHOOSE_LOWEST_MIN      DecisionStrategyProto_VariableSelectionStrategy = 1
	DecisionStrategyProto_CHOOSE_HIGHEST_MAX     DecisionStrategyProto_VariableSelectionStrategy = 2
	DecisionStrategyProto_CHOOSE_MIN_DOMAIN_SIZE DecisionStrategyProto_VariableSelectionStrategy = 3
	DecisionStrategyProto_CHOOSE_MAX_DOMAIN_SIZE DecisionStrategyProto_VariableSelectionStrategy = 4
)

var DecisionStrategyProto_VariableSelectionStrategy_name = map[int32]string{
	0: "CHOOSE_FIRST",
	1: "CHOOSE_LOWEST_MIN",
	2: "CHOOSE_HIGHEST_MAX",
	3: "CHOOSE_MIN_DOMAIN_SIZE",
	4: "CHOOSE_MAX_DOMAIN_SIZE",
}

var DecisionStrategyProto_VariableSelectionStrategy_value = map[string]int32{
	"CHOOSE_FIRST":           0,
	"CHOOSE_LOWEST_MIN":      1,
	"CHOOSE_HIGHEST_MAX":     2,
	"CHOOSE_MIN_DOMAIN_SIZE": 3,
	"CHOOSE_MAX_DOMAIN_SIZE": 4,
}

func (x DecisionStrategyProto_VariableSelectionStrategy) String() string {
	return proto.EnumName(DecisionStrategyProto_VariableSelectionStrategy_name, int32(x))
}

func (DecisionStrategyProto_VariableSelectionStrategy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{21, 0}
}

// Once a variable has been chosen, this enum describe what decision is taken
// on its domain.
//
// TODO(user): extend as needed.
type DecisionStrategyProto_DomainReductionStrategy int32

const (
	DecisionStrategyProto_SELECT_MIN_VALUE    DecisionStrategyProto_DomainReductionStrategy = 0
	DecisionStrategyProto_SELECT_MAX_VALUE    DecisionStrategyProto_DomainReductionStrategy = 1
	DecisionStrategyProto_SELECT_LOWER_HALF   DecisionStrategyProto_DomainReductionStrategy = 2
	DecisionStrategyProto_SELECT_UPPER_HALF   DecisionStrategyProto_DomainReductionStrategy = 3
	DecisionStrategyProto_SELECT_MEDIAN_VALUE DecisionStrategyProto_DomainReductionStrategy = 4
)

var DecisionStrategyProto_DomainReductionStrategy_name = map[int32]string{
	0: "SELECT_MIN_VALUE",
	1: "SELECT_MAX_VALUE",
	2: "SELECT_LOWER_HALF",
	3: "SELECT_UPPER_HALF",
	4: "SELECT_MEDIAN_VALUE",
}

var DecisionStrategyProto_DomainReductionStrategy_value = map[string]int32{
	"SELECT_MIN_VALUE":    0,
	"SELECT_MAX_VALUE":    1,
	"SELECT_LOWER_HALF":   2,
	"SELECT_UPPER_HALF":   3,
	"SELECT_MEDIAN_VALUE": 4,
}

func (x DecisionStrategyProto_DomainReductionStrategy) String() string {
	return proto.EnumName(DecisionStrategyProto_DomainReductionStrategy_name, int32(x))
}

func (DecisionStrategyProto_DomainReductionStrategy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{21, 1}
}

// An integer variable.
//
// It will be referred to by an int32 corresponding to its index in a
// CpModelProto variables field.
//
// Depending on the context, a reference to a variable whose domain is in [0, 1]
// can also be seen as a Boolean that will be true if the variable value is 1
// and false if it is 0. When used in this context, the field name will always
// contain the word "literal".
//
// Negative reference (advanced usage): to simplify the creation of a model and
// for efficiency reasons, all the "literal" or "variable" fields can also
// contain a negative index. A negative index i will refer to the negation of
// the integer variable at index -i -1 or to NOT the literal at the same index.
//
// Ex: A variable index 4 will refer to the integer variable model.variables(4)
// and an index of -5 will refer to the negation of the same variable. A literal
// index 4 will refer to the logical fact that model.variable(4) == 1 and a
// literal index of -5 will refer to the logical fact model.variable(4) == 0.
type IntegerVariableProto struct {
	// For debug/logging only. Can be empty.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The variable domain given as a sorted list of n disjoint intervals
	// [min, max] and encoded as [min_0, max_0,  ..., min_{n-1}, max_{n-1}].
	//
	// The most common example being just [min, max].
	// If min == max, then this is a constant variable.
	//
	// We have:
	//  - domain_size() is always even.
	//  - min == domain.front();
	//  - max == domain.back();
	//  - for all i < n   :      min_i <= max_i
	//  - for all i < n-1 :  max_i + 1 < min_{i+1}.
	//
	// Note that we check at validation that a variable domain is small enough so
	// that we don't run into integer overflow in our algorithms. Because of that,
	// you cannot just have "unbounded" variable like [0, kint64max] and should
	// try to specify tighter domains.
	Domain               []int64  `protobuf:"varint,2,rep,packed,name=domain,proto3" json:"domain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IntegerVariableProto) Reset()         { *m = IntegerVariableProto{} }
func (m *IntegerVariableProto) String() string { return proto.CompactTextString(m) }
func (*IntegerVariableProto) ProtoMessage()    {}
func (*IntegerVariableProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{0}
}

func (m *IntegerVariableProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IntegerVariableProto.Unmarshal(m, b)
}
func (m *IntegerVariableProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IntegerVariableProto.Marshal(b, m, deterministic)
}
func (m *IntegerVariableProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntegerVariableProto.Merge(m, src)
}
func (m *IntegerVariableProto) XXX_Size() int {
	return xxx_messageInfo_IntegerVariableProto.Size(m)
}
func (m *IntegerVariableProto) XXX_DiscardUnknown() {
	xxx_messageInfo_IntegerVariableProto.DiscardUnknown(m)
}

var xxx_messageInfo_IntegerVariableProto proto.InternalMessageInfo

func (m *IntegerVariableProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *IntegerVariableProto) GetDomain() []int64 {
	if m != nil {
		return m.Domain
	}
	return nil
}

// Argument of the constraints of the form OP(literals).
type BoolArgumentProto struct {
	Literals             []int32  `protobuf:"varint,1,rep,packed,name=literals,proto3" json:"literals,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BoolArgumentProto) Reset()         { *m = BoolArgumentProto{} }
func (m *BoolArgumentProto) String() string { return proto.CompactTextString(m) }
func (*BoolArgumentProto) ProtoMessage()    {}
func (*BoolArgumentProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{1}
}

func (m *BoolArgumentProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BoolArgumentProto.Unmarshal(m, b)
}
func (m *BoolArgumentProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BoolArgumentProto.Marshal(b, m, deterministic)
}
func (m *BoolArgumentProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BoolArgumentProto.Merge(m, src)
}
func (m *BoolArgumentProto) XXX_Size() int {
	return xxx_messageInfo_BoolArgumentProto.Size(m)
}
func (m *BoolArgumentProto) XXX_DiscardUnknown() {
	xxx_messageInfo_BoolArgumentProto.DiscardUnknown(m)
}

var xxx_messageInfo_BoolArgumentProto proto.InternalMessageInfo

func (m *BoolArgumentProto) GetLiterals() []int32 {
	if m != nil {
		return m.Literals
	}
	return nil
}

// Argument of the constraints of the form target_var = OP(vars).
type IntegerArgumentProto struct {
	Target               int32    `protobuf:"varint,1,opt,name=target,proto3" json:"target,omitempty"`
	Vars                 []int32  `protobuf:"varint,2,rep,packed,name=vars,proto3" json:"vars,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IntegerArgumentProto) Reset()         { *m = IntegerArgumentProto{} }
func (m *IntegerArgumentProto) String() string { return proto.CompactTextString(m) }
func (*IntegerArgumentProto) ProtoMessage()    {}
func (*IntegerArgumentProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{2}
}

func (m *IntegerArgumentProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IntegerArgumentProto.Unmarshal(m, b)
}
func (m *IntegerArgumentProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IntegerArgumentProto.Marshal(b, m, deterministic)
}
func (m *IntegerArgumentProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntegerArgumentProto.Merge(m, src)
}
func (m *IntegerArgumentProto) XXX_Size() int {
	return xxx_messageInfo_IntegerArgumentProto.Size(m)
}
func (m *IntegerArgumentProto) XXX_DiscardUnknown() {
	xxx_messageInfo_IntegerArgumentProto.DiscardUnknown(m)
}

var xxx_messageInfo_IntegerArgumentProto proto.InternalMessageInfo

func (m *IntegerArgumentProto) GetTarget() int32 {
	if m != nil {
		return m.Target
	}
	return 0
}

func (m *IntegerArgumentProto) GetVars() []int32 {
	if m != nil {
		return m.Vars
	}
	return nil
}

type LinearExpressionProto struct {
	Vars                 []int32  `protobuf:"varint,1,rep,packed,name=vars,proto3" json:"vars,omitempty"`
	Coeffs               []int64  `protobuf:"varint,2,rep,packed,name=coeffs,proto3" json:"coeffs,omitempty"`
	Offset               int64    `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LinearExpressionProto) Reset()         { *m = LinearExpressionProto{} }
func (m *LinearExpressionProto) String() string { return proto.CompactTextString(m) }
func (*LinearExpressionProto) ProtoMessage()    {}
func (*LinearExpressionProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{3}
}

func (m *LinearExpressionProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LinearExpressionProto.Unmarshal(m, b)
}
func (m *LinearExpressionProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LinearExpressionProto.Marshal(b, m, deterministic)
}
func (m *LinearExpressionProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinearExpressionProto.Merge(m, src)
}
func (m *LinearExpressionProto) XXX_Size() int {
	return xxx_messageInfo_LinearExpressionProto.Size(m)
}
func (m *LinearExpressionProto) XXX_DiscardUnknown() {
	xxx_messageInfo_LinearExpressionProto.DiscardUnknown(m)
}

var xxx_messageInfo_LinearExpressionProto proto.InternalMessageInfo

func (m *LinearExpressionProto) GetVars() []int32 {
	if m != nil {
		return m.Vars
	}
	return nil
}

func (m *LinearExpressionProto) GetCoeffs() []int64 {
	if m != nil {
		return m.Coeffs
	}
	return nil
}

func (m *LinearExpressionProto) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

type LinearArgumentProto struct {
	Target               *LinearExpressionProto   `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	Exprs                []*LinearExpressionProto `protobuf:"bytes,2,rep,name=exprs,proto3" json:"exprs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *LinearArgumentProto) Reset()         { *m = LinearArgumentProto{} }
func (m *LinearArgumentProto) String() string { return proto.CompactTextString(m) }
func (*LinearArgumentProto) ProtoMessage()    {}
func (*LinearArgumentProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{4}
}

func (m *LinearArgumentProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LinearArgumentProto.Unmarshal(m, b)
}
func (m *LinearArgumentProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LinearArgumentProto.Marshal(b, m, deterministic)
}
func (m *LinearArgumentProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinearArgumentProto.Merge(m, src)
}
func (m *LinearArgumentProto) XXX_Size() int {
	return xxx_messageInfo_LinearArgumentProto.Size(m)
}
func (m *LinearArgumentProto) XXX_DiscardUnknown() {
	xxx_messageInfo_LinearArgumentProto.DiscardUnknown(m)
}

var xxx_messageInfo_LinearArgumentProto proto.InternalMessageInfo

func (m *LinearArgumentProto) GetTarget() *LinearExpressionProto {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *LinearArgumentProto) GetExprs() []*LinearExpressionProto {
	if m != nil {
		return m.Exprs
	}
	return nil
}

// All variables must take different values.
type AllDifferentConstraintProto struct {
	Vars                 []int32  `protobuf:"varint,1,rep,packed,name=vars,proto3" json:"vars,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllDifferentConstraintProto) Reset()         { *m = AllDifferentConstraintProto{} }
func (m *AllDifferentConstraintProto) String() string { return proto.CompactTextString(m) }
func (*AllDifferentConstraintProto) ProtoMessage()    {}
func (*AllDifferentConstraintProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{5}
}

func (m *AllDifferentConstraintProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AllDifferentConstraintProto.Unmarshal(m, b)
}
func (m *AllDifferentConstraintProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AllDifferentConstraintProto.Marshal(b, m, deterministic)
}
func (m *AllDifferentConstraintProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllDifferentConstraintProto.Merge(m, src)
}
func (m *AllDifferentConstraintProto) XXX_Size() int {
	return xxx_messageInfo_AllDifferentConstraintProto.Size(m)
}
func (m *AllDifferentConstraintProto) XXX_DiscardUnknown() {
	xxx_messageInfo_AllDifferentConstraintProto.DiscardUnknown(m)
}

var xxx_messageInfo_AllDifferentConstraintProto proto.InternalMessageInfo

func (m *AllDifferentConstraintProto) GetVars() []int32 {
	if m != nil {
		return m.Vars
	}
	return nil
}

// The linear sum vars[i] * coeffs[i] must fall in the given domain. The domain
// has the same format as the one in IntegerVariableProto.
//
// Note that the validation code currently checks using the domain of the
// involved variables that the sum can always be computed without integer
// overflow and throws an error otherwise.
type LinearConstraintProto struct {
	Vars                 []int32  `protobuf:"varint,1,rep,packed,name=vars,proto3" json:"vars,omitempty"`
	Coeffs               []int64  `protobuf:"varint,2,rep,packed,name=coeffs,proto3" json:"coeffs,omitempty"`
	Domain               []int64  `protobuf:"varint,3,rep,packed,name=domain,proto3" json:"domain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LinearConstraintProto) Reset()         { *m = LinearConstraintProto{} }
func (m *LinearConstraintProto) String() string { return proto.CompactTextString(m) }
func (*LinearConstraintProto) ProtoMessage()    {}
func (*LinearConstraintProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{6}
}

func (m *LinearConstraintProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LinearConstraintProto.Unmarshal(m, b)
}
func (m *LinearConstraintProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LinearConstraintProto.Marshal(b, m, deterministic)
}
func (m *LinearConstraintProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinearConstraintProto.Merge(m, src)
}
func (m *LinearConstraintProto) XXX_Size() int {
	return xxx_messageInfo_LinearConstraintProto.Size(m)
}
func (m *LinearConstraintProto) XXX_DiscardUnknown() {
	xxx_messageInfo_LinearConstraintProto.DiscardUnknown(m)
}

var xxx_messageInfo_LinearConstraintProto proto.InternalMessageInfo

func (m *LinearConstraintProto) GetVars() []int32 {
	if m != nil {
		return m.Vars
	}
	return nil
}

func (m *LinearConstraintProto) GetCoeffs() []int64 {
	if m != nil {
		return m.Coeffs
	}
	return nil
}

func (m *LinearConstraintProto) GetDomain() []int64 {
	if m != nil {
		return m.Domain
	}
	return nil
}

// The constraint target = vars[index].
// This enforces that index takes one of the value in [0, vars_size()).
type ElementConstraintProto struct {
	Index                int32    `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Target               int32    `protobuf:"varint,2,opt,name=target,proto3" json:"target,omitempty"`
	Vars                 []int32  `protobuf:"varint,3,rep,packed,name=vars,proto3" json:"vars,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ElementConstraintProto) Reset()         { *m = ElementConstraintProto{} }
func (m *ElementConstraintProto) String() string { return proto.CompactTextString(m) }
func (*ElementConstraintProto) ProtoMessage()    {}
func (*ElementConstraintProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{7}
}

func (m *ElementConstraintProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ElementConstraintProto.Unmarshal(m, b)
}
func (m *ElementConstraintProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ElementConstraintProto.Marshal(b, m, deterministic)
}
func (m *ElementConstraintProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ElementConstraintProto.Merge(m, src)
}
func (m *ElementConstraintProto) XXX_Size() int {
	return xxx_messageInfo_ElementConstraintProto.Size(m)
}
func (m *ElementConstraintProto) XXX_DiscardUnknown() {
	xxx_messageInfo_ElementConstraintProto.DiscardUnknown(m)
}

var xxx_messageInfo_ElementConstraintProto proto.InternalMessageInfo

func (m *ElementConstraintProto) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *ElementConstraintProto) GetTarget() int32 {
	if m != nil {
		return m.Target
	}
	return 0
}

func (m *ElementConstraintProto) GetVars() []int32 {
	if m != nil {
		return m.Vars
	}
	return nil
}

// This "special" constraint not only enforces (start + size == end) but can
// also be referred by other constraints using this "interval" concept.
type IntervalConstraintProto struct {
	Start                int32    `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End                  int32    `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	Size                 int32    `protobuf:"varint,3,opt,name=size,proto3" json:"size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *IntervalConstraintProto) Reset()         { *m = IntervalConstraintProto{} }
func (m *IntervalConstraintProto) String() string { return proto.CompactTextString(m) }
func (*IntervalConstraintProto) ProtoMessage()    {}
func (*IntervalConstraintProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{8}
}

func (m *IntervalConstraintProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_IntervalConstraintProto.Unmarshal(m, b)
}
func (m *IntervalConstraintProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_IntervalConstraintProto.Marshal(b, m, deterministic)
}
func (m *IntervalConstraintProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IntervalConstraintProto.Merge(m, src)
}
func (m *IntervalConstraintProto) XXX_Size() int {
	return xxx_messageInfo_IntervalConstraintProto.Size(m)
}
func (m *IntervalConstraintProto) XXX_DiscardUnknown() {
	xxx_messageInfo_IntervalConstraintProto.DiscardUnknown(m)
}

var xxx_messageInfo_IntervalConstraintProto proto.InternalMessageInfo

func (m *IntervalConstraintProto) GetStart() int32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *IntervalConstraintProto) GetEnd() int32 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *IntervalConstraintProto) GetSize() int32 {
	if m != nil {
		return m.Size
	}
	return 0
}

// All the intervals (index of IntervalConstraintProto) must be disjoint. More
// formally, there must exist a sequence so that for each consecutive intervals,
// we have end_i <= start_{i+1}. In particular, intervals of size zero do matter
// for this constraint. This is also known as a disjunctive constraint in
// scheduling.
type NoOverlapConstraintProto struct {
	Intervals            []int32  `protobuf:"varint,1,rep,packed,name=intervals,proto3" json:"intervals,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NoOverlapConstraintProto) Reset()         { *m = NoOverlapConstraintProto{} }
func (m *NoOverlapConstraintProto) String() string { return proto.CompactTextString(m) }
func (*NoOverlapConstraintProto) ProtoMessage()    {}
func (*NoOverlapConstraintProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{9}
}

func (m *NoOverlapConstraintProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NoOverlapConstraintProto.Unmarshal(m, b)
}
func (m *NoOverlapConstraintProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NoOverlapConstraintProto.Marshal(b, m, deterministic)
}
func (m *NoOverlapConstraintProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoOverlapConstraintProto.Merge(m, src)
}
func (m *NoOverlapConstraintProto) XXX_Size() int {
	return xxx_messageInfo_NoOverlapConstraintProto.Size(m)
}
func (m *NoOverlapConstraintProto) XXX_DiscardUnknown() {
	xxx_messageInfo_NoOverlapConstraintProto.DiscardUnknown(m)
}

var xxx_messageInfo_NoOverlapConstraintProto proto.InternalMessageInfo

func (m *NoOverlapConstraintProto) GetIntervals() []int32 {
	if m != nil {
		return m.Intervals
	}
	return nil
}

// The boxes defined by [start_x, end_x) * [start_y, end_y) cannot overlap.
type NoOverlap2DConstraintProto struct {
	XIntervals                  []int32  `protobuf:"varint,1,rep,packed,name=x_intervals,json=xIntervals,proto3" json:"x_intervals,omitempty"`
	YIntervals                  []int32  `protobuf:"varint,2,rep,packed,name=y_intervals,json=yIntervals,proto3" json:"y_intervals,omitempty"`
	BoxesWithNullAreaCanOverlap bool     `protobuf:"varint,3,opt,name=boxes_with_null_area_can_overlap,json=boxesWithNullAreaCanOverlap,proto3" json:"boxes_with_null_area_can_overlap,omitempty"`
	XXX_NoUnkeyedLiteral        struct{} `json:"-"`
	XXX_unrecognized            []byte   `json:"-"`
	XXX_sizecache               int32    `json:"-"`
}

func (m *NoOverlap2DConstraintProto) Reset()         { *m = NoOverlap2DConstraintProto{} }
func (m *NoOverlap2DConstraintProto) String() string { return proto.CompactTextString(m) }
func (*NoOverlap2DConstraintProto) ProtoMessage()    {}
func (*NoOverlap2DConstraintProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{10}
}

func (m *NoOverlap2DConstraintProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NoOverlap2DConstraintProto.Unmarshal(m, b)
}
func (m *NoOverlap2DConstraintProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NoOverlap2DConstraintProto.Marshal(b, m, deterministic)
}
func (m *NoOverlap2DConstraintProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoOverlap2DConstraintProto.Merge(m, src)
}
func (m *NoOverlap2DConstraintProto) XXX_Size() int {
	return xxx_messageInfo_NoOverlap2DConstraintProto.Size(m)
}
func (m *NoOverlap2DConstraintProto) XXX_DiscardUnknown() {
	xxx_messageInfo_NoOverlap2DConstraintProto.DiscardUnknown(m)
}

var xxx_messageInfo_NoOverlap2DConstraintProto proto.InternalMessageInfo

func (m *NoOverlap2DConstraintProto) GetXIntervals() []int32 {
	if m != nil {
		return m.XIntervals
	}
	return nil
}

func (m *NoOverlap2DConstraintProto) GetYIntervals() []int32 {
	if m != nil {
		return m.YIntervals
	}
	return nil
}

func (m *NoOverlap2DConstraintProto) GetBoxesWithNullAreaCanOverlap() bool {
	if m != nil {
		return m.BoxesWithNullAreaCanOverlap
	}
	return false
}

// The sum of the demands of the intervals at each interval point cannot exceed
// a capacity. Note that intervals are interpreted as [start, end) and as
// such intervals like [2,3) and [3,4) do not overlap for the point of view of
// this constraint. Moreover, intervals of size zero are ignored.
type CumulativeConstraintProto struct {
	Capacity             int32    `protobuf:"varint,1,opt,name=capacity,proto3" json:"capacity,omitempty"`
	Intervals            []int32  `protobuf:"varint,2,rep,packed,name=intervals,proto3" json:"intervals,omitempty"`
	Demands              []int32  `protobuf:"varint,3,rep,packed,name=demands,proto3" json:"demands,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CumulativeConstraintProto) Reset()         { *m = CumulativeConstraintProto{} }
func (m *CumulativeConstraintProto) String() string { return proto.CompactTextString(m) }
func (*CumulativeConstraintProto) ProtoMessage()    {}
func (*CumulativeConstraintProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{11}
}

func (m *CumulativeConstraintProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CumulativeConstraintProto.Unmarshal(m, b)
}
func (m *CumulativeConstraintProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CumulativeConstraintProto.Marshal(b, m, deterministic)
}
func (m *CumulativeConstraintProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CumulativeConstraintProto.Merge(m, src)
}
func (m *CumulativeConstraintProto) XXX_Size() int {
	return xxx_messageInfo_CumulativeConstraintProto.Size(m)
}
func (m *CumulativeConstraintProto) XXX_DiscardUnknown() {
	xxx_messageInfo_CumulativeConstraintProto.DiscardUnknown(m)
}

var xxx_messageInfo_CumulativeConstraintProto proto.InternalMessageInfo

func (m *CumulativeConstraintProto) GetCapacity() int32 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *CumulativeConstraintProto) GetIntervals() []int32 {
	if m != nil {
		return m.Intervals
	}
	return nil
}

func (m *CumulativeConstraintProto) GetDemands() []int32 {
	if m != nil {
		return m.Demands
	}
	return nil
}

// Maintain a reservoir level within bounds. The water level starts at 0, and at
// any time >= 0, it must be within min_level, and max_level. Furthermore, this
// constraints expect all times variables to be >= 0.
// If the variable actives[i] is true, and if the variable times[i] is assigned
// a value t, then the current level changes by demands[i] (which is constant)
// at the time t.
//
// Note that level min can be > 0, or level max can be < 0. It just forces
// some demands to be executed at time 0 to make sure that we are within those
// bounds with the executed demands. Therefore, at any time t >= 0:
//      sum(demands[i] * actives[i] if times[i] <= t) in [min_level, max_level]
// The array of boolean variables 'actives', if defined, indicates which actions
// are actually performed. If this array is not defined, then it is assumed that
// all actions will be performed.
type ReservoirConstraintProto struct {
	MinLevel             int64    `protobuf:"varint,1,opt,name=min_level,json=minLevel,proto3" json:"min_level,omitempty"`
	MaxLevel             int64    `protobuf:"varint,2,opt,name=max_level,json=maxLevel,proto3" json:"max_level,omitempty"`
	Times                []int32  `protobuf:"varint,3,rep,packed,name=times,proto3" json:"times,omitempty"`
	Demands              []int64  `protobuf:"varint,4,rep,packed,name=demands,proto3" json:"demands,omitempty"`
	Actives              []int32  `protobuf:"varint,5,rep,packed,name=actives,proto3" json:"actives,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReservoirConstraintProto) Reset()         { *m = ReservoirConstraintProto{} }
func (m *ReservoirConstraintProto) String() string { return proto.CompactTextString(m) }
func (*ReservoirConstraintProto) ProtoMessage()    {}
func (*ReservoirConstraintProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{12}
}

func (m *ReservoirConstraintProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReservoirConstraintProto.Unmarshal(m, b)
}
func (m *ReservoirConstraintProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReservoirConstraintProto.Marshal(b, m, deterministic)
}
func (m *ReservoirConstraintProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReservoirConstraintProto.Merge(m, src)
}
func (m *ReservoirConstraintProto) XXX_Size() int {
	return xxx_messageInfo_ReservoirConstraintProto.Size(m)
}
func (m *ReservoirConstraintProto) XXX_DiscardUnknown() {
	xxx_messageInfo_ReservoirConstraintProto.DiscardUnknown(m)
}

var xxx_messageInfo_ReservoirConstraintProto proto.InternalMessageInfo

func (m *ReservoirConstraintProto) GetMinLevel() int64 {
	if m != nil {
		return m.MinLevel
	}
	return 0
}

func (m *ReservoirConstraintProto) GetMaxLevel() int64 {
	if m != nil {
		return m.MaxLevel
	}
	return 0
}

func (m *ReservoirConstraintProto) GetTimes() []int32 {
	if m != nil {
		return m.Times
	}
	return nil
}

func (m *ReservoirConstraintProto) GetDemands() []int64 {
	if m != nil {
		return m.Demands
	}
	return nil
}

func (m *ReservoirConstraintProto) GetActives() []int32 {
	if m != nil {
		return m.Actives
	}
	return nil
}

// The circuit constraint is defined on a graph where the arc presence are
// controlled by literals. Each arc is given by an index in the
// tails/heads/literals lists that must have the same size.
//
// For now, we ignore node indices with no incident arc. All the other nodes
// must have exactly one incoming and one outgoing selected arc (i.e. literal at
// true). All the selected arcs that are not self-loops must form a single
// circuit. Note that multi-arcs are allowed, but only one of them will be true
// at the same time. Multi-self loop are disallowed though.
type CircuitConstraintProto struct {
	Tails                []int32  `protobuf:"varint,3,rep,packed,name=tails,proto3" json:"tails,omitempty"`
	Heads                []int32  `protobuf:"varint,4,rep,packed,name=heads,proto3" json:"heads,omitempty"`
	Literals             []int32  `protobuf:"varint,5,rep,packed,name=literals,proto3" json:"literals,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CircuitConstraintProto) Reset()         { *m = CircuitConstraintProto{} }
func (m *CircuitConstraintProto) String() string { return proto.CompactTextString(m) }
func (*CircuitConstraintProto) ProtoMessage()    {}
func (*CircuitConstraintProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{13}
}

func (m *CircuitConstraintProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CircuitConstraintProto.Unmarshal(m, b)
}
func (m *CircuitConstraintProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CircuitConstraintProto.Marshal(b, m, deterministic)
}
func (m *CircuitConstraintProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CircuitConstraintProto.Merge(m, src)
}
func (m *CircuitConstraintProto) XXX_Size() int {
	return xxx_messageInfo_CircuitConstraintProto.Size(m)
}
func (m *CircuitConstraintProto) XXX_DiscardUnknown() {
	xxx_messageInfo_CircuitConstraintProto.DiscardUnknown(m)
}

var xxx_messageInfo_CircuitConstraintProto proto.InternalMessageInfo

func (m *CircuitConstraintProto) GetTails() []int32 {
	if m != nil {
		return m.Tails
	}
	return nil
}

func (m *CircuitConstraintProto) GetHeads() []int32 {
	if m != nil {
		return m.Heads
	}
	return nil
}

func (m *CircuitConstraintProto) GetLiterals() []int32 {
	if m != nil {
		return m.Literals
	}
	return nil
}

// The "VRP" (Vehicle Routing Problem) constraint.
//
// The direct graph where arc #i (from tails[i] to head[i]) is present iff
// literals[i] is true must satisfy this set of properties:
// - #incoming arcs == 1 except for node 0.
// - #outgoing arcs == 1 except for node 0.
// - for node zero, #incoming arcs == #outgoing arcs.
// - There are no duplicate arcs.
// - Self-arcs are allowed except for node 0.
// - There is no cycle in this graph, except through node 0.
//
// TODO(user): It is probably possible to generalize this constraint to a
// no-cycle in a general graph, or a no-cycle with sum incoming <= 1 and sum
// outgoing <= 1 (more efficient implementation). On the other hand, having this
// specific constraint allow us to add specific "cuts" to a VRP problem.
type RoutesConstraintProto struct {
	Tails    []int32 `protobuf:"varint,1,rep,packed,name=tails,proto3" json:"tails,omitempty"`
	Heads    []int32 `protobuf:"varint,2,rep,packed,name=heads,proto3" json:"heads,omitempty"`
	Literals []int32 `protobuf:"varint,3,rep,packed,name=literals,proto3" json:"literals,omitempty"`
	// Experimental. The demands for each node, and the maximum capacity for each
	// route. Note that this is currently only used for the LP relaxation and one
	// need to add the corresponding constraint to enforce this outside of the LP.
	Demands              []int32  `protobuf:"varint,4,rep,packed,name=demands,proto3" json:"demands,omitempty"`
	Capacity             int64    `protobuf:"varint,5,opt,name=capacity,proto3" json:"capacity,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RoutesConstraintProto) Reset()         { *m = RoutesConstraintProto{} }
func (m *RoutesConstraintProto) String() string { return proto.CompactTextString(m) }
func (*RoutesConstraintProto) ProtoMessage()    {}
func (*RoutesConstraintProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{14}
}

func (m *RoutesConstraintProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RoutesConstraintProto.Unmarshal(m, b)
}
func (m *RoutesConstraintProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RoutesConstraintProto.Marshal(b, m, deterministic)
}
func (m *RoutesConstraintProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoutesConstraintProto.Merge(m, src)
}
func (m *RoutesConstraintProto) XXX_Size() int {
	return xxx_messageInfo_RoutesConstraintProto.Size(m)
}
func (m *RoutesConstraintProto) XXX_DiscardUnknown() {
	xxx_messageInfo_RoutesConstraintProto.DiscardUnknown(m)
}

var xxx_messageInfo_RoutesConstraintProto proto.InternalMessageInfo

func (m *RoutesConstraintProto) GetTails() []int32 {
	if m != nil {
		return m.Tails
	}
	return nil
}

func (m *RoutesConstraintProto) GetHeads() []int32 {
	if m != nil {
		return m.Heads
	}
	return nil
}

func (m *RoutesConstraintProto) GetLiterals() []int32 {
	if m != nil {
		return m.Literals
	}
	return nil
}

func (m *RoutesConstraintProto) GetDemands() []int32 {
	if m != nil {
		return m.Demands
	}
	return nil
}

func (m *RoutesConstraintProto) GetCapacity() int64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

// Another routing constraint. This one forces the nexts variables to form a
// permutation, and cycles of this permutation of length more than 1 (nonloops)
// to contain exactly one of the distinguished nodes.
type CircuitCoveringConstraintProto struct {
	Nexts                []int32  `protobuf:"varint,1,rep,packed,name=nexts,proto3" json:"nexts,omitempty"`
	DistinguishedNodes   []int64  `protobuf:"varint,2,rep,packed,name=distinguished_nodes,json=distinguishedNodes,proto3" json:"distinguished_nodes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CircuitCoveringConstraintProto) Reset()         { *m = CircuitCoveringConstraintProto{} }
func (m *CircuitCoveringConstraintProto) String() string { return proto.CompactTextString(m) }
func (*CircuitCoveringConstraintProto) ProtoMessage()    {}
func (*CircuitCoveringConstraintProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{15}
}

func (m *CircuitCoveringConstraintProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CircuitCoveringConstraintProto.Unmarshal(m, b)
}
func (m *CircuitCoveringConstraintProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CircuitCoveringConstraintProto.Marshal(b, m, deterministic)
}
func (m *CircuitCoveringConstraintProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CircuitCoveringConstraintProto.Merge(m, src)
}
func (m *CircuitCoveringConstraintProto) XXX_Size() int {
	return xxx_messageInfo_CircuitCoveringConstraintProto.Size(m)
}
func (m *CircuitCoveringConstraintProto) XXX_DiscardUnknown() {
	xxx_messageInfo_CircuitCoveringConstraintProto.DiscardUnknown(m)
}

var xxx_messageInfo_CircuitCoveringConstraintProto proto.InternalMessageInfo

func (m *CircuitCoveringConstraintProto) GetNexts() []int32 {
	if m != nil {
		return m.Nexts
	}
	return nil
}

func (m *CircuitCoveringConstraintProto) GetDistinguishedNodes() []int64 {
	if m != nil {
		return m.DistinguishedNodes
	}
	return nil
}

// The values of the n-tuple formed by the given variables can only be one of
// the listed n-tuples in values. The n-tuples are encoded in a flattened way:
//     [tuple0_v0, tuple0_v1, ..., tuple0_v{n-1}, tuple1_v0, ...].
type TableConstraintProto struct {
	Vars   []int32 `protobuf:"varint,1,rep,packed,name=vars,proto3" json:"vars,omitempty"`
	Values []int64 `protobuf:"varint,2,rep,packed,name=values,proto3" json:"values,omitempty"`
	// If true, the meaning is "negated", that is we forbid any of the given
	// tuple from a feasible assignment.
	Negated              bool     `protobuf:"varint,3,opt,name=negated,proto3" json:"negated,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TableConstraintProto) Reset()         { *m = TableConstraintProto{} }
func (m *TableConstraintProto) String() string { return proto.CompactTextString(m) }
func (*TableConstraintProto) ProtoMessage()    {}
func (*TableConstraintProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{16}
}

func (m *TableConstraintProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TableConstraintProto.Unmarshal(m, b)
}
func (m *TableConstraintProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TableConstraintProto.Marshal(b, m, deterministic)
}
func (m *TableConstraintProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableConstraintProto.Merge(m, src)
}
func (m *TableConstraintProto) XXX_Size() int {
	return xxx_messageInfo_TableConstraintProto.Size(m)
}
func (m *TableConstraintProto) XXX_DiscardUnknown() {
	xxx_messageInfo_TableConstraintProto.DiscardUnknown(m)
}

var xxx_messageInfo_TableConstraintProto proto.InternalMessageInfo

func (m *TableConstraintProto) GetVars() []int32 {
	if m != nil {
		return m.Vars
	}
	return nil
}

func (m *TableConstraintProto) GetValues() []int64 {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *TableConstraintProto) GetNegated() bool {
	if m != nil {
		return m.Negated
	}
	return false
}

// The two arrays of variable each represent a function, the second is the
// inverse of the first: f_direct[i] == j <=> f_inverse[j] == i.
type InverseConstraintProto struct {
	FDirect              []int32  `protobuf:"varint,1,rep,packed,name=f_direct,json=fDirect,proto3" json:"f_direct,omitempty"`
	FInverse             []int32  `protobuf:"varint,2,rep,packed,name=f_inverse,json=fInverse,proto3" json:"f_inverse,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InverseConstraintProto) Reset()         { *m = InverseConstraintProto{} }
func (m *InverseConstraintProto) String() string { return proto.CompactTextString(m) }
func (*InverseConstraintProto) ProtoMessage()    {}
func (*InverseConstraintProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{17}
}

func (m *InverseConstraintProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InverseConstraintProto.Unmarshal(m, b)
}
func (m *InverseConstraintProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InverseConstraintProto.Marshal(b, m, deterministic)
}
func (m *InverseConstraintProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InverseConstraintProto.Merge(m, src)
}
func (m *InverseConstraintProto) XXX_Size() int {
	return xxx_messageInfo_InverseConstraintProto.Size(m)
}
func (m *InverseConstraintProto) XXX_DiscardUnknown() {
	xxx_messageInfo_InverseConstraintProto.DiscardUnknown(m)
}

var xxx_messageInfo_InverseConstraintProto proto.InternalMessageInfo

func (m *InverseConstraintProto) GetFDirect() []int32 {
	if m != nil {
		return m.FDirect
	}
	return nil
}

func (m *InverseConstraintProto) GetFInverse() []int32 {
	if m != nil {
		return m.FInverse
	}
	return nil
}

// This constraint forces a sequence of variables to be accepted by an
// automaton.
type AutomatonConstraintProto struct {
	// A state is identified by a non-negative number. It is preferable to keep
	// all the states dense in says [0, num_states). The automaton starts at
	// starting_state and must finish in any of the final states.
	StartingState int64   `protobuf:"varint,2,opt,name=starting_state,json=startingState,proto3" json:"starting_state,omitempty"`
	FinalStates   []int64 `protobuf:"varint,3,rep,packed,name=final_states,json=finalStates,proto3" json:"final_states,omitempty"`
	// List of transitions (all 3 vectors have the same size). Both tail and head
	// are states, label is any variable value. No two outgoing transitions from
	// the same state can have the same label.
	TransitionTail  []int64 `protobuf:"varint,4,rep,packed,name=transition_tail,json=transitionTail,proto3" json:"transition_tail,omitempty"`
	TransitionHead  []int64 `protobuf:"varint,5,rep,packed,name=transition_head,json=transitionHead,proto3" json:"transition_head,omitempty"`
	TransitionLabel []int64 `protobuf:"varint,6,rep,packed,name=transition_label,json=transitionLabel,proto3" json:"transition_label,omitempty"`
	// The sequence of variables. The automaton is ran for vars_size() "steps" and
	// the value of vars[i] corresponds to the transition label at step i.
	Vars                 []int32  `protobuf:"varint,7,rep,packed,name=vars,proto3" json:"vars,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AutomatonConstraintProto) Reset()         { *m = AutomatonConstraintProto{} }
func (m *AutomatonConstraintProto) String() string { return proto.CompactTextString(m) }
func (*AutomatonConstraintProto) ProtoMessage()    {}
func (*AutomatonConstraintProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{18}
}

func (m *AutomatonConstraintProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AutomatonConstraintProto.Unmarshal(m, b)
}
func (m *AutomatonConstraintProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AutomatonConstraintProto.Marshal(b, m, deterministic)
}
func (m *AutomatonConstraintProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AutomatonConstraintProto.Merge(m, src)
}
func (m *AutomatonConstraintProto) XXX_Size() int {
	return xxx_messageInfo_AutomatonConstraintProto.Size(m)
}
func (m *AutomatonConstraintProto) XXX_DiscardUnknown() {
	xxx_messageInfo_AutomatonConstraintProto.DiscardUnknown(m)
}

var xxx_messageInfo_AutomatonConstraintProto proto.InternalMessageInfo

func (m *AutomatonConstraintProto) GetStartingState() int64 {
	if m != nil {
		return m.StartingState
	}
	return 0
}

func (m *AutomatonConstraintProto) GetFinalStates() []int64 {
	if m != nil {
		return m.FinalStates
	}
	return nil
}

func (m *AutomatonConstraintProto) GetTransitionTail() []int64 {
	if m != nil {
		return m.TransitionTail
	}
	return nil
}

func (m *AutomatonConstraintProto) GetTransitionHead() []int64 {
	if m != nil {
		return m.TransitionHead
	}
	return nil
}

func (m *AutomatonConstraintProto) GetTransitionLabel() []int64 {
	if m != nil {
		return m.TransitionLabel
	}
	return nil
}

func (m *AutomatonConstraintProto) GetVars() []int32 {
	if m != nil {
		return m.Vars
	}
	return nil
}

// Next id: 29
type ConstraintProto struct {
	// For debug/logging only. Can be empty.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The constraint will be enforced iff all literals listed here are true. If
	// this is empty, then the constraint will always be enforced. An enforced
	// constraint must be satisfied, and an un-enforced one will simply be
	// ignored.
	//
	// This is also called half-reification. To have an equivalence between a
	// literal and a constraint (full reification), one must add both a constraint
	// (controlled by a literal l) and its negation (controlled by the negation of
	// l).
	//
	// Important: as of September 2018, only a few constraint support enforcement:
	// - bool_or, bool_and, linear: fully supported.
	// - interval: only support a single enforcement literal.
	// - other: no support (but can be added on a per-demand basis).
	EnforcementLiteral []int32 `protobuf:"varint,2,rep,packed,name=enforcement_literal,json=enforcementLiteral,proto3" json:"enforcement_literal,omitempty"`
	// The actual constraint with its arguments.
	//
	// Types that are valid to be assigned to Constraint:
	//	*ConstraintProto_BoolOr
	//	*ConstraintProto_BoolAnd
	//	*ConstraintProto_AtMostOne
	//	*ConstraintProto_BoolXor
	//	*ConstraintProto_IntDiv
	//	*ConstraintProto_IntMod
	//	*ConstraintProto_IntMax
	//	*ConstraintProto_LinMax
	//	*ConstraintProto_IntMin
	//	*ConstraintProto_LinMin
	//	*ConstraintProto_IntProd
	//	*ConstraintProto_Linear
	//	*ConstraintProto_AllDiff
	//	*ConstraintProto_Element
	//	*ConstraintProto_Circuit
	//	*ConstraintProto_Routes
	//	*ConstraintProto_CircuitCovering
	//	*ConstraintProto_Table
	//	*ConstraintProto_Automaton
	//	*ConstraintProto_Inverse
	//	*ConstraintProto_Reservoir
	//	*ConstraintProto_Interval
	//	*ConstraintProto_NoOverlap
	//	*ConstraintProto_NoOverlap_2D
	//	*ConstraintProto_Cumulative
	Constraint           isConstraintProto_Constraint `protobuf_oneof:"constraint"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *ConstraintProto) Reset()         { *m = ConstraintProto{} }
func (m *ConstraintProto) String() string { return proto.CompactTextString(m) }
func (*ConstraintProto) ProtoMessage()    {}
func (*ConstraintProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{19}
}

func (m *ConstraintProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConstraintProto.Unmarshal(m, b)
}
func (m *ConstraintProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConstraintProto.Marshal(b, m, deterministic)
}
func (m *ConstraintProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConstraintProto.Merge(m, src)
}
func (m *ConstraintProto) XXX_Size() int {
	return xxx_messageInfo_ConstraintProto.Size(m)
}
func (m *ConstraintProto) XXX_DiscardUnknown() {
	xxx_messageInfo_ConstraintProto.DiscardUnknown(m)
}

var xxx_messageInfo_ConstraintProto proto.InternalMessageInfo

func (m *ConstraintProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ConstraintProto) GetEnforcementLiteral() []int32 {
	if m != nil {
		return m.EnforcementLiteral
	}
	return nil
}

type isConstraintProto_Constraint interface {
	isConstraintProto_Constraint()
}

type ConstraintProto_BoolOr struct {
	BoolOr *BoolArgumentProto `protobuf:"bytes,3,opt,name=bool_or,json=boolOr,proto3,oneof"`
}

type ConstraintProto_BoolAnd struct {
	BoolAnd *BoolArgumentProto `protobuf:"bytes,4,opt,name=bool_and,json=boolAnd,proto3,oneof"`
}

type ConstraintProto_AtMostOne struct {
	AtMostOne *BoolArgumentProto `protobuf:"bytes,26,opt,name=at_most_one,json=atMostOne,proto3,oneof"`
}

type ConstraintProto_BoolXor struct {
	BoolXor *BoolArgumentProto `protobuf:"bytes,5,opt,name=bool_xor,json=boolXor,proto3,oneof"`
}

type ConstraintProto_IntDiv struct {
	IntDiv *IntegerArgumentProto `protobuf:"bytes,7,opt,name=int_div,json=intDiv,proto3,oneof"`
}

type ConstraintProto_IntMod struct {
	IntMod *IntegerArgumentProto `protobuf:"bytes,8,opt,name=int_mod,json=intMod,proto3,oneof"`
}

type ConstraintProto_IntMax struct {
	IntMax *IntegerArgumentProto `protobuf:"bytes,9,opt,name=int_max,json=intMax,proto3,oneof"`
}

type ConstraintProto_LinMax struct {
	LinMax *LinearArgumentProto `protobuf:"bytes,27,opt,name=lin_max,json=linMax,proto3,oneof"`
}

type ConstraintProto_IntMin struct {
	IntMin *IntegerArgumentProto `protobuf:"bytes,10,opt,name=int_min,json=intMin,proto3,oneof"`
}

type ConstraintProto_LinMin struct {
	LinMin *LinearArgumentProto `protobuf:"bytes,28,opt,name=lin_min,json=linMin,proto3,oneof"`
}

type ConstraintProto_IntProd struct {
	IntProd *IntegerArgumentProto `protobuf:"bytes,11,opt,name=int_prod,json=intProd,proto3,oneof"`
}

type ConstraintProto_Linear struct {
	Linear *LinearConstraintProto `protobuf:"bytes,12,opt,name=linear,proto3,oneof"`
}

type ConstraintProto_AllDiff struct {
	AllDiff *AllDifferentConstraintProto `protobuf:"bytes,13,opt,name=all_diff,json=allDiff,proto3,oneof"`
}

type ConstraintProto_Element struct {
	Element *ElementConstraintProto `protobuf:"bytes,14,opt,name=element,proto3,oneof"`
}

type ConstraintProto_Circuit struct {
	Circuit *CircuitConstraintProto `protobuf:"bytes,15,opt,name=circuit,proto3,oneof"`
}

type ConstraintProto_Routes struct {
	Routes *RoutesConstraintProto `protobuf:"bytes,23,opt,name=routes,proto3,oneof"`
}

type ConstraintProto_CircuitCovering struct {
	CircuitCovering *CircuitCoveringConstraintProto `protobuf:"bytes,25,opt,name=circuit_covering,json=circuitCovering,proto3,oneof"`
}

type ConstraintProto_Table struct {
	Table *TableConstraintProto `protobuf:"bytes,16,opt,name=table,proto3,oneof"`
}

type ConstraintProto_Automaton struct {
	Automaton *AutomatonConstraintProto `protobuf:"bytes,17,opt,name=automaton,proto3,oneof"`
}

type ConstraintProto_Inverse struct {
	Inverse *InverseConstraintProto `protobuf:"bytes,18,opt,name=inverse,proto3,oneof"`
}

type ConstraintProto_Reservoir struct {
	Reservoir *ReservoirConstraintProto `protobuf:"bytes,24,opt,name=reservoir,proto3,oneof"`
}

type ConstraintProto_Interval struct {
	Interval *IntervalConstraintProto `protobuf:"bytes,19,opt,name=interval,proto3,oneof"`
}

type ConstraintProto_NoOverlap struct {
	NoOverlap *NoOverlapConstraintProto `protobuf:"bytes,20,opt,name=no_overlap,json=noOverlap,proto3,oneof"`
}

type ConstraintProto_NoOverlap_2D struct {
	NoOverlap_2D *NoOverlap2DConstraintProto `protobuf:"bytes,21,opt,name=no_overlap_2d,json=noOverlap2d,proto3,oneof"`
}

type ConstraintProto_Cumulative struct {
	Cumulative *CumulativeConstraintProto `protobuf:"bytes,22,opt,name=cumulative,proto3,oneof"`
}

func (*ConstraintProto_BoolOr) isConstraintProto_Constraint() {}

func (*ConstraintProto_BoolAnd) isConstraintProto_Constraint() {}

func (*ConstraintProto_AtMostOne) isConstraintProto_Constraint() {}

func (*ConstraintProto_BoolXor) isConstraintProto_Constraint() {}

func (*ConstraintProto_IntDiv) isConstraintProto_Constraint() {}

func (*ConstraintProto_IntMod) isConstraintProto_Constraint() {}

func (*ConstraintProto_IntMax) isConstraintProto_Constraint() {}

func (*ConstraintProto_LinMax) isConstraintProto_Constraint() {}

func (*ConstraintProto_IntMin) isConstraintProto_Constraint() {}

func (*ConstraintProto_LinMin) isConstraintProto_Constraint() {}

func (*ConstraintProto_IntProd) isConstraintProto_Constraint() {}

func (*ConstraintProto_Linear) isConstraintProto_Constraint() {}

func (*ConstraintProto_AllDiff) isConstraintProto_Constraint() {}

func (*ConstraintProto_Element) isConstraintProto_Constraint() {}

func (*ConstraintProto_Circuit) isConstraintProto_Constraint() {}

func (*ConstraintProto_Routes) isConstraintProto_Constraint() {}

func (*ConstraintProto_CircuitCovering) isConstraintProto_Constraint() {}

func (*ConstraintProto_Table) isConstraintProto_Constraint() {}

func (*ConstraintProto_Automaton) isConstraintProto_Constraint() {}

func (*ConstraintProto_Inverse) isConstraintProto_Constraint() {}

func (*ConstraintProto_Reservoir) isConstraintProto_Constraint() {}

func (*ConstraintProto_Interval) isConstraintProto_Constraint() {}

func (*ConstraintProto_NoOverlap) isConstraintProto_Constraint() {}

func (*ConstraintProto_NoOverlap_2D) isConstraintProto_Constraint() {}

func (*ConstraintProto_Cumulative) isConstraintProto_Constraint() {}

func (m *ConstraintProto) GetConstraint() isConstraintProto_Constraint {
	if m != nil {
		return m.Constraint
	}
	return nil
}

func (m *ConstraintProto) GetBoolOr() *BoolArgumentProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_BoolOr); ok {
		return x.BoolOr
	}
	return nil
}

func (m *ConstraintProto) GetBoolAnd() *BoolArgumentProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_BoolAnd); ok {
		return x.BoolAnd
	}
	return nil
}

func (m *ConstraintProto) GetAtMostOne() *BoolArgumentProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_AtMostOne); ok {
		return x.AtMostOne
	}
	return nil
}

func (m *ConstraintProto) GetBoolXor() *BoolArgumentProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_BoolXor); ok {
		return x.BoolXor
	}
	return nil
}

func (m *ConstraintProto) GetIntDiv() *IntegerArgumentProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_IntDiv); ok {
		return x.IntDiv
	}
	return nil
}

func (m *ConstraintProto) GetIntMod() *IntegerArgumentProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_IntMod); ok {
		return x.IntMod
	}
	return nil
}

func (m *ConstraintProto) GetIntMax() *IntegerArgumentProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_IntMax); ok {
		return x.IntMax
	}
	return nil
}

func (m *ConstraintProto) GetLinMax() *LinearArgumentProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_LinMax); ok {
		return x.LinMax
	}
	return nil
}

func (m *ConstraintProto) GetIntMin() *IntegerArgumentProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_IntMin); ok {
		return x.IntMin
	}
	return nil
}

func (m *ConstraintProto) GetLinMin() *LinearArgumentProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_LinMin); ok {
		return x.LinMin
	}
	return nil
}

func (m *ConstraintProto) GetIntProd() *IntegerArgumentProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_IntProd); ok {
		return x.IntProd
	}
	return nil
}

func (m *ConstraintProto) GetLinear() *LinearConstraintProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_Linear); ok {
		return x.Linear
	}
	return nil
}

func (m *ConstraintProto) GetAllDiff() *AllDifferentConstraintProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_AllDiff); ok {
		return x.AllDiff
	}
	return nil
}

func (m *ConstraintProto) GetElement() *ElementConstraintProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_Element); ok {
		return x.Element
	}
	return nil
}

func (m *ConstraintProto) GetCircuit() *CircuitConstraintProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_Circuit); ok {
		return x.Circuit
	}
	return nil
}

func (m *ConstraintProto) GetRoutes() *RoutesConstraintProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_Routes); ok {
		return x.Routes
	}
	return nil
}

func (m *ConstraintProto) GetCircuitCovering() *CircuitCoveringConstraintProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_CircuitCovering); ok {
		return x.CircuitCovering
	}
	return nil
}

func (m *ConstraintProto) GetTable() *TableConstraintProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_Table); ok {
		return x.Table
	}
	return nil
}

func (m *ConstraintProto) GetAutomaton() *AutomatonConstraintProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_Automaton); ok {
		return x.Automaton
	}
	return nil
}

func (m *ConstraintProto) GetInverse() *InverseConstraintProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_Inverse); ok {
		return x.Inverse
	}
	return nil
}

func (m *ConstraintProto) GetReservoir() *ReservoirConstraintProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_Reservoir); ok {
		return x.Reservoir
	}
	return nil
}

func (m *ConstraintProto) GetInterval() *IntervalConstraintProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_Interval); ok {
		return x.Interval
	}
	return nil
}

func (m *ConstraintProto) GetNoOverlap() *NoOverlapConstraintProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_NoOverlap); ok {
		return x.NoOverlap
	}
	return nil
}

func (m *ConstraintProto) GetNoOverlap_2D() *NoOverlap2DConstraintProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_NoOverlap_2D); ok {
		return x.NoOverlap_2D
	}
	return nil
}

func (m *ConstraintProto) GetCumulative() *CumulativeConstraintProto {
	if x, ok := m.GetConstraint().(*ConstraintProto_Cumulative); ok {
		return x.Cumulative
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ConstraintProto) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ConstraintProto_BoolOr)(nil),
		(*ConstraintProto_BoolAnd)(nil),
		(*ConstraintProto_AtMostOne)(nil),
		(*ConstraintProto_BoolXor)(nil),
		(*ConstraintProto_IntDiv)(nil),
		(*ConstraintProto_IntMod)(nil),
		(*ConstraintProto_IntMax)(nil),
		(*ConstraintProto_LinMax)(nil),
		(*ConstraintProto_IntMin)(nil),
		(*ConstraintProto_LinMin)(nil),
		(*ConstraintProto_IntProd)(nil),
		(*ConstraintProto_Linear)(nil),
		(*ConstraintProto_AllDiff)(nil),
		(*ConstraintProto_Element)(nil),
		(*ConstraintProto_Circuit)(nil),
		(*ConstraintProto_Routes)(nil),
		(*ConstraintProto_CircuitCovering)(nil),
		(*ConstraintProto_Table)(nil),
		(*ConstraintProto_Automaton)(nil),
		(*ConstraintProto_Inverse)(nil),
		(*ConstraintProto_Reservoir)(nil),
		(*ConstraintProto_Interval)(nil),
		(*ConstraintProto_NoOverlap)(nil),
		(*ConstraintProto_NoOverlap_2D)(nil),
		(*ConstraintProto_Cumulative)(nil),
	}
}

// Optimization objective.
//
// This is in a message because decision problems don't have any objective.
type CpObjectiveProto struct {
	// The linear terms of the objective to minimize.
	// For a maximization problem, one can negate all coefficients in the
	// objective and set a scaling_factor to -1.
	Vars   []int32 `protobuf:"varint,1,rep,packed,name=vars,proto3" json:"vars,omitempty"`
	Coeffs []int64 `protobuf:"varint,4,rep,packed,name=coeffs,proto3" json:"coeffs,omitempty"`
	// The displayed objective is always:
	//   scaling_factor * (sum(coefficients[i] * objective_vars[i]) + offset).
	// This is needed to have a consistent objective after presolve or when
	// scaling a double problem to express it with integers.
	//
	// Note that if scaling_factor is zero, then it is assumed to be 1, so that by
	// default these fields have no effect.
	Offset        float64 `protobuf:"fixed64,2,opt,name=offset,proto3" json:"offset,omitempty"`
	ScalingFactor float64 `protobuf:"fixed64,3,opt,name=scaling_factor,json=scalingFactor,proto3" json:"scaling_factor,omitempty"`
	// If non-empty, only look for an objective value in the given domain.
	// Note that this does not depend on the offset or scaling factor, it is a
	// domain on the sum of the objective terms only.
	Domain               []int64  `protobuf:"varint,5,rep,packed,name=domain,proto3" json:"domain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CpObjectiveProto) Reset()         { *m = CpObjectiveProto{} }
func (m *CpObjectiveProto) String() string { return proto.CompactTextString(m) }
func (*CpObjectiveProto) ProtoMessage()    {}
func (*CpObjectiveProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{20}
}

func (m *CpObjectiveProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CpObjectiveProto.Unmarshal(m, b)
}
func (m *CpObjectiveProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CpObjectiveProto.Marshal(b, m, deterministic)
}
func (m *CpObjectiveProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpObjectiveProto.Merge(m, src)
}
func (m *CpObjectiveProto) XXX_Size() int {
	return xxx_messageInfo_CpObjectiveProto.Size(m)
}
func (m *CpObjectiveProto) XXX_DiscardUnknown() {
	xxx_messageInfo_CpObjectiveProto.DiscardUnknown(m)
}

var xxx_messageInfo_CpObjectiveProto proto.InternalMessageInfo

func (m *CpObjectiveProto) GetVars() []int32 {
	if m != nil {
		return m.Vars
	}
	return nil
}

func (m *CpObjectiveProto) GetCoeffs() []int64 {
	if m != nil {
		return m.Coeffs
	}
	return nil
}

func (m *CpObjectiveProto) GetOffset() float64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *CpObjectiveProto) GetScalingFactor() float64 {
	if m != nil {
		return m.ScalingFactor
	}
	return 0
}

func (m *CpObjectiveProto) GetDomain() []int64 {
	if m != nil {
		return m.Domain
	}
	return nil
}

// Define the strategy to follow when the solver needs to take a new decision.
// Note that this strategy is only defined on a subset of variables.
type DecisionStrategyProto struct {
	// The variables to be considered for the next decision. The order matter and
	// is always used as a tie-breaker after the variable selection strategy
	// criteria defined below.
	Variables                 []int32                                         `protobuf:"varint,1,rep,packed,name=variables,proto3" json:"variables,omitempty"`
	VariableSelectionStrategy DecisionStrategyProto_VariableSelectionStrategy `protobuf:"varint,2,opt,name=variable_selection_strategy,json=variableSelectionStrategy,proto3,enum=operations_research.sat.DecisionStrategyProto_VariableSelectionStrategy" json:"variable_selection_strategy,omitempty"`
	DomainReductionStrategy   DecisionStrategyProto_DomainReductionStrategy   `protobuf:"varint,3,opt,name=domain_reduction_strategy,json=domainReductionStrategy,proto3,enum=operations_research.sat.DecisionStrategyProto_DomainReductionStrategy" json:"domain_reduction_strategy,omitempty"`
	Transformations           []*DecisionStrategyProto_AffineTransformation   `protobuf:"bytes,4,rep,name=transformations,proto3" json:"transformations,omitempty"`
	XXX_NoUnkeyedLiteral      struct{}                                        `json:"-"`
	XXX_unrecognized          []byte                                          `json:"-"`
	XXX_sizecache             int32                                           `json:"-"`
}

func (m *DecisionStrategyProto) Reset()         { *m = DecisionStrategyProto{} }
func (m *DecisionStrategyProto) String() string { return proto.CompactTextString(m) }
func (*DecisionStrategyProto) ProtoMessage()    {}
func (*DecisionStrategyProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{21}
}

func (m *DecisionStrategyProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DecisionStrategyProto.Unmarshal(m, b)
}
func (m *DecisionStrategyProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DecisionStrategyProto.Marshal(b, m, deterministic)
}
func (m *DecisionStrategyProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecisionStrategyProto.Merge(m, src)
}
func (m *DecisionStrategyProto) XXX_Size() int {
	return xxx_messageInfo_DecisionStrategyProto.Size(m)
}
func (m *DecisionStrategyProto) XXX_DiscardUnknown() {
	xxx_messageInfo_DecisionStrategyProto.DiscardUnknown(m)
}

var xxx_messageInfo_DecisionStrategyProto proto.InternalMessageInfo

func (m *DecisionStrategyProto) GetVariables() []int32 {
	if m != nil {
		return m.Variables
	}
	return nil
}

func (m *DecisionStrategyProto) GetVariableSelectionStrategy() DecisionStrategyProto_VariableSelectionStrategy {
	if m != nil {
		return m.VariableSelectionStrategy
	}
	return DecisionStrategyProto_CHOOSE_FIRST
}

func (m *DecisionStrategyProto) GetDomainReductionStrategy() DecisionStrategyProto_DomainReductionStrategy {
	if m != nil {
		return m.DomainReductionStrategy
	}
	return DecisionStrategyProto_SELECT_MIN_VALUE
}

func (m *DecisionStrategyProto) GetTransformations() []*DecisionStrategyProto_AffineTransformation {
	if m != nil {
		return m.Transformations
	}
	return nil
}

// Advanced usage. Some of the variable listed above may have been transformed
// by the presolve so this is needed to properly follow the given selection
// strategy. Instead of using a value X from one of the variable listed here,
// we will use positive_coeff * X + offset instead.
type DecisionStrategyProto_AffineTransformation struct {
	Var                  int32    `protobuf:"varint,1,opt,name=var,proto3" json:"var,omitempty"`
	Offset               int64    `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	PositiveCoeff        int64    `protobuf:"varint,3,opt,name=positive_coeff,json=positiveCoeff,proto3" json:"positive_coeff,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DecisionStrategyProto_AffineTransformation) Reset() {
	*m = DecisionStrategyProto_AffineTransformation{}
}
func (m *DecisionStrategyProto_AffineTransformation) String() string {
	return proto.CompactTextString(m)
}
func (*DecisionStrategyProto_AffineTransformation) ProtoMessage() {}
func (*DecisionStrategyProto_AffineTransformation) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{21, 0}
}

func (m *DecisionStrategyProto_AffineTransformation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DecisionStrategyProto_AffineTransformation.Unmarshal(m, b)
}
func (m *DecisionStrategyProto_AffineTransformation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DecisionStrategyProto_AffineTransformation.Marshal(b, m, deterministic)
}
func (m *DecisionStrategyProto_AffineTransformation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DecisionStrategyProto_AffineTransformation.Merge(m, src)
}
func (m *DecisionStrategyProto_AffineTransformation) XXX_Size() int {
	return xxx_messageInfo_DecisionStrategyProto_AffineTransformation.Size(m)
}
func (m *DecisionStrategyProto_AffineTransformation) XXX_DiscardUnknown() {
	xxx_messageInfo_DecisionStrategyProto_AffineTransformation.DiscardUnknown(m)
}

var xxx_messageInfo_DecisionStrategyProto_AffineTransformation proto.InternalMessageInfo

func (m *DecisionStrategyProto_AffineTransformation) GetVar() int32 {
	if m != nil {
		return m.Var
	}
	return 0
}

func (m *DecisionStrategyProto_AffineTransformation) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *DecisionStrategyProto_AffineTransformation) GetPositiveCoeff() int64 {
	if m != nil {
		return m.PositiveCoeff
	}
	return 0
}

// This message encodes a partial (or full) assignment of the variables of a
// CpModelProto. The variable indices should be unique and valid variable
// indices.
type PartialVariableAssignment struct {
	Vars                 []int32  `protobuf:"varint,1,rep,packed,name=vars,proto3" json:"vars,omitempty"`
	Values               []int64  `protobuf:"varint,2,rep,packed,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PartialVariableAssignment) Reset()         { *m = PartialVariableAssignment{} }
func (m *PartialVariableAssignment) String() string { return proto.CompactTextString(m) }
func (*PartialVariableAssignment) ProtoMessage()    {}
func (*PartialVariableAssignment) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{22}
}

func (m *PartialVariableAssignment) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PartialVariableAssignment.Unmarshal(m, b)
}
func (m *PartialVariableAssignment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PartialVariableAssignment.Marshal(b, m, deterministic)
}
func (m *PartialVariableAssignment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartialVariableAssignment.Merge(m, src)
}
func (m *PartialVariableAssignment) XXX_Size() int {
	return xxx_messageInfo_PartialVariableAssignment.Size(m)
}
func (m *PartialVariableAssignment) XXX_DiscardUnknown() {
	xxx_messageInfo_PartialVariableAssignment.DiscardUnknown(m)
}

var xxx_messageInfo_PartialVariableAssignment proto.InternalMessageInfo

func (m *PartialVariableAssignment) GetVars() []int32 {
	if m != nil {
		return m.Vars
	}
	return nil
}

func (m *PartialVariableAssignment) GetValues() []int64 {
	if m != nil {
		return m.Values
	}
	return nil
}

// A constraint programming problem.
type CpModelProto struct {
	// For debug/logging only. Can be empty.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The associated Protos should be referred by their index in these fields.
	Variables   []*IntegerVariableProto `protobuf:"bytes,2,rep,name=variables,proto3" json:"variables,omitempty"`
	Constraints []*ConstraintProto      `protobuf:"bytes,3,rep,name=constraints,proto3" json:"constraints,omitempty"`
	// The objective to minimize. Can be empty for pure decision problems.
	Objective *CpObjectiveProto `protobuf:"bytes,4,opt,name=objective,proto3" json:"objective,omitempty"`
	// Defines the strategy that the solver should follow when the
	// search_branching parameter is set to FIXED_SEARCH. Note that this strategy
	// is also used as a heuristic when we are not in fixed search.
	//
	// Advanced Usage: if not all variables appears and the parameter
	// "instantiate_all_variables" is set to false, then the solver will not try
	// to instantiate the variables that do not appear. Thus, at the end of the
	// search, not all variables may be fixed and this is why we have the
	// solution_lower_bounds and solution_upper_bounds fields in the
	// CpSolverResponse.
	SearchStrategy []*DecisionStrategyProto `protobuf:"bytes,5,rep,name=search_strategy,json=searchStrategy,proto3" json:"search_strategy,omitempty"`
	// Solution hint.
	//
	// If a feasible or almost-feasible solution to the problem is already known,
	// it may be helpful to pass it to the solver so that it can be used. The
	// solver will try to use this information to create its initial feasible
	// solution.
	//
	// Note that it may not always be faster to give a hint like this to the
	// solver. There is also no guarantee that the solver will use this hint or
	// try to return a solution "close" to this assignment in case of multiple
	// optimal solutions.
	SolutionHint *PartialVariableAssignment `protobuf:"bytes,6,opt,name=solution_hint,json=solutionHint,proto3" json:"solution_hint,omitempty"`
	// A list of literals. The model will be solved assuming all these literals
	// are true. Compared to just fixing the domain of these literals, using this
	// mechanism is slower but allows in case the model is INFEASIBLE to get a
	// potentially small subset of them that can be used to explain the
	// infeasibility.
	//
	// Think (IIS), except when you are only concerned by the provided
	// assumptions. This is powerful as it allows to group a set of logicially
	// related constraint under only one enforcement literal which can potentially
	// give you a good and interpretable explanation for infeasiblity.
	//
	// Such infeasibility explanation will be available in the
	// sufficient_assumptions_for_infeasibility response field.
	Assumptions          []int32  `protobuf:"varint,7,rep,packed,name=assumptions,proto3" json:"assumptions,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CpModelProto) Reset()         { *m = CpModelProto{} }
func (m *CpModelProto) String() string { return proto.CompactTextString(m) }
func (*CpModelProto) ProtoMessage()    {}
func (*CpModelProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{23}
}

func (m *CpModelProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CpModelProto.Unmarshal(m, b)
}
func (m *CpModelProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CpModelProto.Marshal(b, m, deterministic)
}
func (m *CpModelProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpModelProto.Merge(m, src)
}
func (m *CpModelProto) XXX_Size() int {
	return xxx_messageInfo_CpModelProto.Size(m)
}
func (m *CpModelProto) XXX_DiscardUnknown() {
	xxx_messageInfo_CpModelProto.DiscardUnknown(m)
}

var xxx_messageInfo_CpModelProto proto.InternalMessageInfo

func (m *CpModelProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CpModelProto) GetVariables() []*IntegerVariableProto {
	if m != nil {
		return m.Variables
	}
	return nil
}

func (m *CpModelProto) GetConstraints() []*ConstraintProto {
	if m != nil {
		return m.Constraints
	}
	return nil
}

func (m *CpModelProto) GetObjective() *CpObjectiveProto {
	if m != nil {
		return m.Objective
	}
	return nil
}

func (m *CpModelProto) GetSearchStrategy() []*DecisionStrategyProto {
	if m != nil {
		return m.SearchStrategy
	}
	return nil
}

func (m *CpModelProto) GetSolutionHint() *PartialVariableAssignment {
	if m != nil {
		return m.SolutionHint
	}
	return nil
}

func (m *CpModelProto) GetAssumptions() []int32 {
	if m != nil {
		return m.Assumptions
	}
	return nil
}

// The response returned by a solver trying to solve a CpModelProto.
//
// TODO(user): support returning multiple solutions. Look at the Stubby
// streaming API as we probably wants to get them as they are found.
// Next id: 24
type CpSolverResponse struct {
	// The status of the solve.
	Status CpSolverStatus `protobuf:"varint,1,opt,name=status,proto3,enum=operations_research.sat.CpSolverStatus" json:"status,omitempty"`
	// A feasible solution to the given problem. Depending on the returned status
	// it may be optimal or just feasible. This is in one-to-one correspondence
	// with a CpModelProto::variables repeated field and list the values of all
	// the variables.
	Solution []int64 `protobuf:"varint,2,rep,packed,name=solution,proto3" json:"solution,omitempty"`
	// Only make sense for an optimization problem. The objective value of the
	// returned solution if it is non-empty. If there is no solution, then for a
	// minimization problem, this will be an upper-bound of the objective of any
	// feasible solution, and a lower-bound for a maximization problem.
	ObjectiveValue float64 `protobuf:"fixed64,3,opt,name=objective_value,json=objectiveValue,proto3" json:"objective_value,omitempty"`
	// Only make sense for an optimization problem. A proven lower-bound on the
	// objective for a minimization problem, or a proven upper-bound for a
	// maximization problem.
	BestObjectiveBound float64 `protobuf:"fixed64,4,opt,name=best_objective_bound,json=bestObjectiveBound,proto3" json:"best_objective_bound,omitempty"`
	// Advanced usage.
	//
	// If the problem has some variables that are not fixed at the end of the
	// search (because of a particular search strategy in the CpModelProto) then
	// this will be used instead of filling the solution above. The two fields
	// will then contains the lower and upper bounds of each variable as they were
	// when the best "solution" was found.
	SolutionLowerBounds []int64 `protobuf:"varint,18,rep,packed,name=solution_lower_bounds,json=solutionLowerBounds,proto3" json:"solution_lower_bounds,omitempty"`
	SolutionUpperBounds []int64 `protobuf:"varint,19,rep,packed,name=solution_upper_bounds,json=solutionUpperBounds,proto3" json:"solution_upper_bounds,omitempty"`
	// Advanced usage.
	//
	// If the option fill_tightened_domains_in_response is set, then this field
	// will be a copy of the CpModelProto.variables where each domain has been
	// reduced using the information the solver was able to derive. Note that this
	// is only filled with the info derived during a normal search and we do not
	// have any dedicated algorithm to improve it.
	//
	// If the problem is a feasibility problem, then these bounds will be valid
	// for any feasible solution. If the problem is an optimization problem, then
	// these bounds will only be valid for any OPTIMAL solutions, it can exclude
	// sub-optimal feasible ones.
	TightenedVariables []*IntegerVariableProto `protobuf:"bytes,21,rep,name=tightened_variables,json=tightenedVariables,proto3" json:"tightened_variables,omitempty"`
	// A subset of the model "assumptions" field. This will only be filled if the
	// status is INFEASIBLE. This subset of assumption will be enough to still get
	// an infeasible problem.
	//
	// This is related to what is called the irreducible inconsistent subsystem or
	// IIS. Except one is only concerned by the provided assumptions. There is
	// also no guarantee that we return an irreducible (aka minimal subset).
	// However, this is based on SAT explanation and there is a good chance it is
	// not too large.
	//
	// If you really want a minimal subset, a possible way to get one is by
	// changing your model to minimize the number of assumptions at false, but
	// this is likely an harder problem to solve.
	//
	// TODO(user): Allows for returning multiple core at once.
	SufficientAssumptionsForInfeasibility []int32 `protobuf:"varint,23,rep,packed,name=sufficient_assumptions_for_infeasibility,json=sufficientAssumptionsForInfeasibility,proto3" json:"sufficient_assumptions_for_infeasibility,omitempty"`
	// This will be true iff the solver was asked to find all solutions to a
	// satisfiability problem (or all optimal solutions to an optimization
	// problem), and it was successful in doing so.
	//
	// TODO(user): Remove as we also use the OPTIMAL vs FEASIBLE status for that.
	AllSolutionsWereFound bool `protobuf:"varint,5,opt,name=all_solutions_were_found,json=allSolutionsWereFound,proto3" json:"all_solutions_were_found,omitempty"`
	// Some statistics about the solve.
	NumBooleans            int64   `protobuf:"varint,10,opt,name=num_booleans,json=numBooleans,proto3" json:"num_booleans,omitempty"`
	NumConflicts           int64   `protobuf:"varint,11,opt,name=num_conflicts,json=numConflicts,proto3" json:"num_conflicts,omitempty"`
	NumBranches            int64   `protobuf:"varint,12,opt,name=num_branches,json=numBranches,proto3" json:"num_branches,omitempty"`
	NumBinaryPropagations  int64   `protobuf:"varint,13,opt,name=num_binary_propagations,json=numBinaryPropagations,proto3" json:"num_binary_propagations,omitempty"`
	NumIntegerPropagations int64   `protobuf:"varint,14,opt,name=num_integer_propagations,json=numIntegerPropagations,proto3" json:"num_integer_propagations,omitempty"`
	WallTime               float64 `protobuf:"fixed64,15,opt,name=wall_time,json=wallTime,proto3" json:"wall_time,omitempty"`
	UserTime               float64 `protobuf:"fixed64,16,opt,name=user_time,json=userTime,proto3" json:"user_time,omitempty"`
	DeterministicTime      float64 `protobuf:"fixed64,17,opt,name=deterministic_time,json=deterministicTime,proto3" json:"deterministic_time,omitempty"`
	PrimalIntegral         float64 `protobuf:"fixed64,22,opt,name=primal_integral,json=primalIntegral,proto3" json:"primal_integral,omitempty"`
	// Additional information about how the solution was found.
	SolutionInfo         string   `protobuf:"bytes,20,opt,name=solution_info,json=solutionInfo,proto3" json:"solution_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CpSolverResponse) Reset()         { *m = CpSolverResponse{} }
func (m *CpSolverResponse) String() string { return proto.CompactTextString(m) }
func (*CpSolverResponse) ProtoMessage()    {}
func (*CpSolverResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dde80aae7bbe0833, []int{24}
}

func (m *CpSolverResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CpSolverResponse.Unmarshal(m, b)
}
func (m *CpSolverResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CpSolverResponse.Marshal(b, m, deterministic)
}
func (m *CpSolverResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CpSolverResponse.Merge(m, src)
}
func (m *CpSolverResponse) XXX_Size() int {
	return xxx_messageInfo_CpSolverResponse.Size(m)
}
func (m *CpSolverResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CpSolverResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CpSolverResponse proto.InternalMessageInfo

func (m *CpSolverResponse) GetStatus() CpSolverStatus {
	if m != nil {
		return m.Status
	}
	return CpSolverStatus_UNKNOWN
}

func (m *CpSolverResponse) GetSolution() []int64 {
	if m != nil {
		return m.Solution
	}
	return nil
}

func (m *CpSolverResponse) GetObjectiveValue() float64 {
	if m != nil {
		return m.ObjectiveValue
	}
	return 0
}

func (m *CpSolverResponse) GetBestObjectiveBound() float64 {
	if m != nil {
		return m.BestObjectiveBound
	}
	return 0
}

func (m *CpSolverResponse) GetSolutionLowerBounds() []int64 {
	if m != nil {
		return m.SolutionLowerBounds
	}
	return nil
}

func (m *CpSolverResponse) GetSolutionUpperBounds() []int64 {
	if m != nil {
		return m.SolutionUpperBounds
	}
	return nil
}

func (m *CpSolverResponse) GetTightenedVariables() []*IntegerVariableProto {
	if m != nil {
		return m.TightenedVariables
	}
	return nil
}

func (m *CpSolverResponse) GetSufficientAssumptionsForInfeasibility() []int32 {
	if m != nil {
		return m.SufficientAssumptionsForInfeasibility
	}
	return nil
}

func (m *CpSolverResponse) GetAllSolutionsWereFound() bool {
	if m != nil {
		return m.AllSolutionsWereFound
	}
	return false
}

func (m *CpSolverResponse) GetNumBooleans() int64 {
	if m != nil {
		return m.NumBooleans
	}
	return 0
}

func (m *CpSolverResponse) GetNumConflicts() int64 {
	if m != nil {
		return m.NumConflicts
	}
	return 0
}

func (m *CpSolverResponse) GetNumBranches() int64 {
	if m != nil {
		return m.NumBranches
	}
	return 0
}

func (m *CpSolverResponse) GetNumBinaryPropagations() int64 {
	if m != nil {
		return m.NumBinaryPropagations
	}
	return 0
}

func (m *CpSolverResponse) GetNumIntegerPropagations() int64 {
	if m != nil {
		return m.NumIntegerPropagations
	}
	return 0
}

func (m *CpSolverResponse) GetWallTime() float64 {
	if m != nil {
		return m.WallTime
	}
	return 0
}

func (m *CpSolverResponse) GetUserTime() float64 {
	if m != nil {
		return m.UserTime
	}
	return 0
}

func (m *CpSolverResponse) GetDeterministicTime() float64 {
	if m != nil {
		return m.DeterministicTime
	}
	return 0
}

func (m *CpSolverResponse) GetPrimalIntegral() float64 {
	if m != nil {
		return m.PrimalIntegral
	}
	return 0
}

func (m *CpSolverResponse) GetSolutionInfo() string {
	if m != nil {
		return m.SolutionInfo
	}
	return ""
}

func init() {
	proto.RegisterEnum("operations_research.sat.CpSolverStatus", CpSolverStatus_name, CpSolverStatus_value)
	proto.RegisterEnum("operations_research.sat.DecisionStrategyProto_VariableSelectionStrategy", DecisionStrategyProto_VariableSelectionStrategy_name, DecisionStrategyProto_VariableSelectionStrategy_value)
	proto.RegisterEnum("operations_research.sat.DecisionStrategyProto_DomainReductionStrategy", DecisionStrategyProto_DomainReductionStrategy_name, DecisionStrategyProto_DomainReductionStrategy_value)
	proto.RegisterType((*IntegerVariableProto)(nil), "operations_research.sat.IntegerVariableProto")
	proto.RegisterType((*BoolArgumentProto)(nil), "operations_research.sat.BoolArgumentProto")
	proto.RegisterType((*IntegerArgumentProto)(nil), "operations_research.sat.IntegerArgumentProto")
	proto.RegisterType((*LinearExpressionProto)(nil), "operations_research.sat.LinearExpressionProto")
	proto.RegisterType((*LinearArgumentProto)(nil), "operations_research.sat.LinearArgumentProto")
	proto.RegisterType((*AllDifferentConstraintProto)(nil), "operations_research.sat.AllDifferentConstraintProto")
	proto.RegisterType((*LinearConstraintProto)(nil), "operations_research.sat.LinearConstraintProto")
	proto.RegisterType((*ElementConstraintProto)(nil), "operations_research.sat.ElementConstraintProto")
	proto.RegisterType((*IntervalConstraintProto)(nil), "operations_research.sat.IntervalConstraintProto")
	proto.RegisterType((*NoOverlapConstraintProto)(nil), "operations_research.sat.NoOverlapConstraintProto")
	proto.RegisterType((*NoOverlap2DConstraintProto)(nil), "operations_research.sat.NoOverlap2DConstraintProto")
	proto.RegisterType((*CumulativeConstraintProto)(nil), "operations_research.sat.CumulativeConstraintProto")
	proto.RegisterType((*ReservoirConstraintProto)(nil), "operations_research.sat.ReservoirConstraintProto")
	proto.RegisterType((*CircuitConstraintProto)(nil), "operations_research.sat.CircuitConstraintProto")
	proto.RegisterType((*RoutesConstraintProto)(nil), "operations_research.sat.RoutesConstraintProto")
	proto.RegisterType((*CircuitCoveringConstraintProto)(nil), "operations_research.sat.CircuitCoveringConstraintProto")
	proto.RegisterType((*TableConstraintProto)(nil), "operations_research.sat.TableConstraintProto")
	proto.RegisterType((*InverseConstraintProto)(nil), "operations_research.sat.InverseConstraintProto")
	proto.RegisterType((*AutomatonConstraintProto)(nil), "operations_research.sat.AutomatonConstraintProto")
	proto.RegisterType((*ConstraintProto)(nil), "operations_research.sat.ConstraintProto")
	proto.RegisterType((*CpObjectiveProto)(nil), "operations_research.sat.CpObjectiveProto")
	proto.RegisterType((*DecisionStrategyProto)(nil), "operations_research.sat.DecisionStrategyProto")
	proto.RegisterType((*DecisionStrategyProto_AffineTransformation)(nil), "operations_research.sat.DecisionStrategyProto.AffineTransformation")
	proto.RegisterType((*PartialVariableAssignment)(nil), "operations_research.sat.PartialVariableAssignment")
	proto.RegisterType((*CpModelProto)(nil), "operations_research.sat.CpModelProto")
	proto.RegisterType((*CpSolverResponse)(nil), "operations_research.sat.CpSolverResponse")
}

func init() { proto.RegisterFile("ortools/sat/cp_model.proto", fileDescriptor_dde80aae7bbe0833) }

var fileDescriptor_dde80aae7bbe0833 = []byte{
	// 2365 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x59, 0x4b, 0x73, 0x23, 0xb7,
	0x11, 0xd6, 0x88, 0xa2, 0x44, 0x35, 0xf5, 0xe0, 0x42, 0xaf, 0x91, 0xd6, 0x95, 0xac, 0x99, 0x72,
	0x79, 0xed, 0x8a, 0xb5, 0xb6, 0x9c, 0x8a, 0x7d, 0x4b, 0x51, 0x12, 0xb5, 0xa4, 0x4d, 0x3d, 0x3c,
	0xd4, 0xae, 0x36, 0x76, 0x2a, 0x13, 0x68, 0x06, 0x43, 0x21, 0x35, 0x03, 0xb0, 0x00, 0x90, 0xcb,
	0xcd, 0x31, 0x97, 0xe4, 0x90, 0x63, 0x72, 0xcd, 0x25, 0x95, 0x4b, 0x7e, 0x41, 0xee, 0xf9, 0x13,
	0xf9, 0x23, 0xb9, 0xa7, 0x80, 0xc1, 0x0c, 0x1f, 0x22, 0x97, 0xbb, 0xf2, 0x8d, 0xfd, 0xfa, 0xd0,
	0xe8, 0x6e, 0x00, 0xdd, 0x43, 0x38, 0xe0, 0x42, 0x71, 0x1e, 0xcb, 0x67, 0x12, 0xab, 0x67, 0x41,
	0xd7, 0x4f, 0x78, 0x48, 0xe2, 0xc3, 0xae, 0xe0, 0x8a, 0xa3, 0x3d, 0xde, 0x25, 0x02, 0x2b, 0xca,
	0x99, 0xf4, 0x05, 0x91, 0x04, 0x8b, 0xe0, 0xee, 0x50, 0x62, 0x55, 0x3d, 0x86, 0xed, 0x26, 0x53,
	0xa4, 0x43, 0xc4, 0x4b, 0x2c, 0x28, 0xbe, 0x8d, 0xc9, 0x95, 0x31, 0x40, 0xb0, 0xc4, 0x70, 0x42,
	0x5c, 0xe7, 0x89, 0xf3, 0x74, 0xd5, 0x33, 0xbf, 0xd1, 0x2e, 0x2c, 0x87, 0x3c, 0xc1, 0x94, 0xb9,
	0x8b, 0x4f, 0x0a, 0x4f, 0x0b, 0x9e, 0xa5, 0xaa, 0xcf, 0xe0, 0xd1, 0x31, 0xe7, 0x71, 0x4d, 0x74,
	0x7a, 0x09, 0x61, 0x2a, 0x05, 0x38, 0x80, 0x52, 0x4c, 0x15, 0x11, 0x38, 0x96, 0xae, 0xf3, 0xa4,
	0xf0, 0xb4, 0xe8, 0xe5, 0xf4, 0xc8, 0xa2, 0xe3, 0x36, 0xbb, 0xb0, 0xac, 0xb0, 0xe8, 0x10, 0x65,
	0x96, 0x2d, 0x7a, 0x96, 0xd2, 0xce, 0xf4, 0xb1, 0x90, 0x66, 0xd9, 0xa2, 0x67, 0x7e, 0x57, 0x7f,
	0x80, 0x9d, 0x16, 0x65, 0x04, 0x8b, 0xfa, 0xa0, 0x2b, 0x88, 0x94, 0x94, 0xb3, 0xdc, 0x73, 0xa3,
	0xec, 0x0c, 0x95, 0x35, 0x70, 0xc0, 0x49, 0x14, 0xc9, 0xcc, 0xf3, 0x94, 0xd2, 0x7c, 0x1e, 0x45,
	0x92, 0x28, 0xb7, 0xf0, 0xc4, 0xd1, 0xfc, 0x94, 0xaa, 0xfe, 0xc3, 0x81, 0xad, 0x14, 0x7d, 0xdc,
	0xc1, 0xb3, 0x31, 0x07, 0xcb, 0x47, 0x87, 0x87, 0x33, 0xe2, 0x7a, 0x38, 0xd5, 0xb7, 0x7c, 0x43,
	0xa7, 0x50, 0x24, 0x83, 0xae, 0xdd, 0xd1, 0xfb, 0xc3, 0xa4, 0xc6, 0xd5, 0x2f, 0xe0, 0x71, 0x2d,
	0x8e, 0x4f, 0x69, 0x14, 0x11, 0x41, 0x98, 0x3a, 0xe1, 0x4c, 0x2a, 0x81, 0x69, 0xe6, 0xec, 0x94,
	0x40, 0x0c, 0xa3, 0xf6, 0x0e, 0xca, 0x6f, 0x8b, 0x9a, 0xad, 0x83, 0xc2, 0x58, 0x1d, 0x7c, 0x0f,
	0xbb, 0xf5, 0x98, 0x24, 0x53, 0x5c, 0xd9, 0x86, 0x22, 0x65, 0x21, 0x19, 0xd8, 0xbc, 0xa6, 0xc4,
	0x48, 0xba, 0x17, 0xa7, 0xa6, 0xbb, 0x30, 0xe2, 0xf8, 0x0b, 0xd8, 0xd3, 0x25, 0x23, 0xfa, 0x38,
	0x9e, 0x02, 0x2e, 0x15, 0x16, 0x59, 0xd1, 0xa4, 0x04, 0xaa, 0x40, 0x81, 0xb0, 0xd0, 0x22, 0xeb,
	0x9f, 0x1a, 0x56, 0xd2, 0x3f, 0x10, 0x93, 0xea, 0xa2, 0x67, 0x7e, 0x57, 0xbf, 0x06, 0xf7, 0x82,
	0x5f, 0xf6, 0x89, 0x88, 0x71, 0x77, 0x12, 0xf7, 0x03, 0x58, 0xa5, 0x76, 0xc9, 0x2c, 0x2e, 0x43,
	0x46, 0xf5, 0x9f, 0x0e, 0x1c, 0xe4, 0xa6, 0x47, 0xa7, 0x93, 0xc6, 0x3f, 0x85, 0xf2, 0xc0, 0x9f,
	0x34, 0x87, 0x41, 0xb6, 0x07, 0xa9, 0x15, 0xde, 0x8c, 0x28, 0xa4, 0xa5, 0x0d, 0x6f, 0x86, 0x0a,
	0x75, 0x78, 0x72, 0xcb, 0x07, 0x44, 0xfa, 0xaf, 0xa9, 0xba, 0xf3, 0x59, 0x2f, 0x8e, 0x7d, 0x2c,
	0x08, 0xf6, 0x03, 0xcc, 0x7c, 0x9e, 0x2e, 0x6b, 0xb6, 0x52, 0xf2, 0x1e, 0x1b, 0xbd, 0x1b, 0xaa,
	0xee, 0x2e, 0x7a, 0x71, 0x5c, 0x13, 0x04, 0x9f, 0x60, 0x66, 0x3d, 0xab, 0x72, 0xd8, 0x3f, 0xe9,
	0x25, 0xbd, 0x18, 0x2b, 0xda, 0x27, 0x93, 0x5e, 0x1e, 0x40, 0x29, 0xc0, 0x5d, 0x1c, 0x50, 0xf5,
	0xc6, 0x46, 0x2f, 0xa7, 0xc7, 0xb7, 0xbf, 0x38, 0xb1, 0x7d, 0xe4, 0xc2, 0x4a, 0x48, 0x12, 0xcc,
	0xc2, 0x2c, 0x4d, 0x19, 0x59, 0xfd, 0xbb, 0x03, 0xae, 0x47, 0x24, 0x11, 0x7d, 0x4e, 0xef, 0x95,
	0xd9, 0x63, 0x58, 0x4d, 0x28, 0xf3, 0x63, 0xd2, 0x27, 0xb1, 0x59, 0xb1, 0xe0, 0x95, 0x12, 0xca,
	0x5a, 0x9a, 0x36, 0x42, 0x3c, 0xb0, 0xc2, 0x45, 0x2b, 0xc4, 0x83, 0x54, 0xb8, 0x0d, 0x45, 0x45,
	0x13, 0x92, 0x2d, 0x97, 0x12, 0xa3, 0x6e, 0x2c, 0x99, 0x5a, 0xcc, 0x48, 0x2d, 0xc1, 0x81, 0xde,
	0xb3, 0x74, 0x8b, 0xa9, 0x83, 0x96, 0xac, 0xfe, 0x0e, 0x76, 0x4f, 0xa8, 0x08, 0x7a, 0x74, 0x5a,
	0x99, 0x2a, 0x4c, 0xe3, 0xe1, 0x1a, 0x9a, 0xd0, 0xdc, 0x3b, 0x82, 0xed, 0x0a, 0x45, 0x2f, 0x25,
	0xc6, 0xee, 0xb7, 0xe2, 0xc4, 0xfd, 0xf6, 0x37, 0x07, 0x76, 0x3c, 0xde, 0x53, 0x44, 0xce, 0x5c,
	0xc1, 0x99, 0xba, 0xc2, 0xe2, 0xac, 0x15, 0x0a, 0xe3, 0x2b, 0x4c, 0xee, 0x7b, 0x18, 0xfe, 0xb1,
	0x94, 0x16, 0xd3, 0x18, 0x66, 0x74, 0xb5, 0x03, 0x3f, 0xc9, 0x77, 0xde, 0x27, 0x82, 0xb2, 0xce,
	0x14, 0xff, 0x18, 0x19, 0xa8, 0xdc, 0x3f, 0x43, 0xa0, 0x67, 0xb0, 0x15, 0x52, 0xa9, 0x28, 0xeb,
	0xf4, 0xa8, 0xbc, 0x23, 0xa1, 0xcf, 0x78, 0x48, 0xb2, 0x5b, 0x01, 0x8d, 0x89, 0x2e, 0xb4, 0xa4,
	0xfa, 0x1b, 0xd8, 0xbe, 0xd6, 0x6f, 0xc9, 0x3b, 0xde, 0x32, 0x7d, 0x1c, 0xf7, 0x72, 0x3c, 0x4b,
	0xe9, 0x2d, 0x32, 0xd2, 0xc1, 0x8a, 0x84, 0xb6, 0xcc, 0x33, 0xb2, 0x7a, 0x05, 0xbb, 0x4d, 0xd6,
	0x27, 0x42, 0xde, 0xc3, 0xdf, 0x87, 0x52, 0xe4, 0x87, 0x54, 0x90, 0x40, 0xd9, 0x35, 0x56, 0xa2,
	0x53, 0x43, 0xea, 0xe2, 0x8a, 0x7c, 0x9a, 0x9a, 0xd9, 0x38, 0x97, 0x22, 0x0b, 0x53, 0xfd, 0x9f,
	0x03, 0x6e, 0xad, 0xa7, 0x78, 0x82, 0x15, 0x67, 0x93, 0xa0, 0x1f, 0xc1, 0x86, 0xb9, 0x52, 0x28,
	0xeb, 0xf8, 0x52, 0x61, 0x45, 0x6c, 0x6d, 0xae, 0x67, 0xdc, 0xb6, 0x66, 0xa2, 0x0f, 0x61, 0x2d,
	0xa2, 0x0c, 0xc7, 0xa9, 0x8e, 0xb4, 0x77, 0x63, 0xd9, 0xf0, 0x8c, 0x86, 0x44, 0x1f, 0xc3, 0xa6,
	0x12, 0x98, 0x49, 0xaa, 0x6f, 0x7a, 0x5f, 0xe7, 0xde, 0x56, 0xed, 0xc6, 0x90, 0x7d, 0x8d, 0x69,
	0x3c, 0xa1, 0xa8, 0xcb, 0xc1, 0xd4, 0xd8, 0x98, 0x62, 0x83, 0xe0, 0x10, 0x7d, 0x02, 0x95, 0x11,
	0xc5, 0x18, 0xdf, 0x92, 0xd8, 0x5d, 0x36, 0x9a, 0x23, 0x00, 0x2d, 0xcd, 0xce, 0x63, 0xbf, 0x32,
	0x72, 0xab, 0xfe, 0xa9, 0x02, 0x9b, 0x53, 0x72, 0x74, 0xef, 0xe5, 0x7f, 0x06, 0x5b, 0x84, 0x45,
	0x5c, 0x04, 0xe6, 0x76, 0xf7, 0x6d, 0x19, 0xda, 0x30, 0xa2, 0x11, 0x51, 0x2b, 0x95, 0xa0, 0x3a,
	0xac, 0xdc, 0x72, 0x1e, 0xfb, 0x5c, 0x98, 0xe4, 0x95, 0x8f, 0x3e, 0x9d, 0xf9, 0xc4, 0xdd, 0x6b,
	0x1d, 0x1a, 0x0b, 0xde, 0xb2, 0x36, 0xbe, 0x14, 0xe8, 0x39, 0x94, 0x0c, 0x0c, 0x66, 0xa1, 0xbb,
	0xf4, 0x00, 0x1c, 0xe3, 0x44, 0x8d, 0x85, 0xa8, 0x05, 0x65, 0xac, 0xfc, 0x84, 0x4b, 0xe5, 0x73,
	0x46, 0xdc, 0x83, 0x07, 0x60, 0xad, 0x62, 0x75, 0xce, 0xa5, 0xba, 0x64, 0x24, 0x77, 0x6b, 0xc0,
	0x85, 0x39, 0x63, 0x0f, 0x72, 0xeb, 0x15, 0x17, 0xa8, 0x01, 0x2b, 0x94, 0x29, 0x3f, 0xa4, 0x7d,
	0x77, 0xc5, 0xe0, 0x7c, 0x36, 0x13, 0x67, 0x5a, 0xc3, 0xa4, 0x23, 0x45, 0x99, 0x3a, 0xa5, 0xfd,
	0x0c, 0x29, 0xe1, 0xa1, 0x5b, 0x7a, 0x38, 0xd2, 0x39, 0x0f, 0x73, 0x24, 0x3c, 0x70, 0x57, 0x7f,
	0x04, 0x12, 0x1e, 0xa0, 0xe7, 0xb0, 0x12, 0x53, 0x66, 0x90, 0x1e, 0x1b, 0xa4, 0x9f, 0xcf, 0xe9,
	0x73, 0xee, 0x01, 0xc5, 0x94, 0x69, 0xa0, 0xcc, 0x25, 0xca, 0x5c, 0xf8, 0x11, 0x2e, 0x51, 0x96,
	0xbb, 0x44, 0x99, 0xfb, 0xc1, 0xc3, 0x5d, 0xa2, 0x0c, 0x7d, 0x03, 0x25, 0xed, 0x52, 0x57, 0xf0,
	0xd0, 0x2d, 0x3f, 0xcc, 0xa7, 0x95, 0xf4, 0xc8, 0xe9, 0x88, 0x6b, 0x54, 0x82, 0x85, 0xbb, 0xf6,
	0x4e, 0x5d, 0xe5, 0xc4, 0x89, 0xb5, 0x5e, 0x11, 0x2c, 0xd0, 0x77, 0x50, 0xc2, 0x71, 0xec, 0x87,
	0x34, 0x8a, 0xdc, 0x75, 0x83, 0xf5, 0x8b, 0x99, 0x58, 0x6f, 0x69, 0x1d, 0xb5, 0x73, 0x38, 0x15,
	0xa3, 0x6f, 0x61, 0x85, 0xa4, 0x4d, 0x9d, 0xbb, 0x61, 0x10, 0x9f, 0xcd, 0x44, 0x9c, 0xde, 0xfc,
	0x69, 0x30, 0x8b, 0xa0, 0xc1, 0x82, 0xf4, 0x01, 0x72, 0x37, 0xe7, 0x80, 0x4d, 0x7f, 0xa2, 0x35,
	0x98, 0x45, 0xd0, 0x61, 0x13, 0xe6, 0x91, 0x75, 0xf7, 0xe6, 0x84, 0x6d, 0xea, 0x5b, 0xac, 0xc3,
	0x96, 0xda, 0xa3, 0x10, 0x2a, 0x16, 0xd4, 0x0f, 0xec, 0xc3, 0xe8, 0xee, 0x1b, 0xcc, 0xaf, 0xe6,
	0xfb, 0x37, 0xf5, 0x21, 0x6d, 0x2c, 0x78, 0x9b, 0xc1, 0xb8, 0x06, 0xaa, 0xeb, 0xb7, 0xff, 0x36,
	0x26, 0x6e, 0x65, 0x4e, 0xbd, 0x4c, 0x7b, 0x3a, 0x1b, 0x0b, 0x5e, 0x6a, 0x8d, 0xbe, 0x83, 0x55,
	0x9c, 0x3d, 0x55, 0xee, 0x23, 0x03, 0xf5, 0xc5, 0xec, 0x24, 0xcf, 0x78, 0xd4, 0xcc, 0x7d, 0x96,
	0xc9, 0x74, 0x5a, 0xb2, 0x97, 0x11, 0xcd, 0x49, 0xcb, 0xf4, 0x87, 0x37, 0xad, 0x66, 0x23, 0xd1,
	0xfe, 0x89, 0xac, 0xfd, 0x73, 0xdd, 0x39, 0xfe, 0xcd, 0x6a, 0x14, 0xb5, 0x7f, 0x39, 0x0a, 0xba,
	0x30, 0x87, 0xcd, 0x74, 0x9e, 0xee, 0x96, 0x41, 0xfc, 0xfc, 0xad, 0x87, 0x6d, 0xca, 0x94, 0xd0,
	0x58, 0xf0, 0x72, 0x0c, 0xe4, 0x01, 0x30, 0x9e, 0x37, 0xd1, 0xdb, 0x73, 0x7c, 0x9c, 0x35, 0x20,
	0x68, 0x1f, 0x59, 0x26, 0x43, 0xbf, 0x86, 0xf5, 0x21, 0xa6, 0x7f, 0x14, 0xba, 0x3b, 0x06, 0xf6,
	0xcb, 0xf9, 0xb0, 0xf7, 0x86, 0x87, 0xc6, 0x82, 0x57, 0xce, 0x81, 0x8f, 0x42, 0x74, 0x0d, 0x10,
	0xe4, 0x2d, 0xbc, 0xbb, 0x6b, 0x70, 0x8f, 0x66, 0x17, 0xe6, 0xac, 0x6e, 0xbf, 0xb1, 0xe0, 0x8d,
	0xe0, 0x1c, 0xaf, 0x01, 0x04, 0xb9, 0x82, 0x6e, 0x59, 0x2b, 0x27, 0xdd, 0xcb, 0xdb, 0xdf, 0x13,
	0xd3, 0x25, 0xbf, 0xcb, 0x50, 0xb8, 0x34, 0x63, 0x94, 0xd6, 0xdd, 0x91, 0x93, 0x8d, 0xd2, 0xa6,
	0x7b, 0x0a, 0x70, 0xac, 0x9b, 0xa7, 0x08, 0x07, 0xca, 0x36, 0x04, 0x8e, 0xb7, 0x6e, 0xb9, 0x67,
	0x86, 0x39, 0x32, 0x53, 0x16, 0xc7, 0x66, 0xca, 0xff, 0x2c, 0xc3, 0xce, 0x29, 0x09, 0xa8, 0x1e,
	0x7e, 0xdb, 0x4a, 0x60, 0x45, 0x3a, 0x6f, 0xf2, 0xf1, 0xac, 0x6f, 0x3f, 0x59, 0xe4, 0xe3, 0x59,
	0xce, 0x40, 0x7f, 0x76, 0xe0, 0x71, 0x46, 0xf9, 0x92, 0xc4, 0x7a, 0x5b, 0x9c, 0xf9, 0xd2, 0x42,
	0x18, 0x27, 0x37, 0x8e, 0x1a, 0x33, 0xa3, 0x38, 0x75, 0xcd, 0xc3, 0xec, 0x1b, 0x49, 0x3b, 0x03,
	0xcc, 0xc4, 0xde, 0x7e, 0x7f, 0x96, 0x08, 0xfd, 0xd1, 0x81, 0xfd, 0x74, 0x37, 0xbe, 0x20, 0x61,
	0x6f, 0xc2, 0x91, 0x82, 0x71, 0xe4, 0xec, 0x3d, 0x1d, 0x39, 0x35, 0x78, 0x5e, 0x06, 0x97, 0xbb,
	0xb1, 0x17, 0x4e, 0x17, 0xa0, 0xc4, 0x76, 0x94, 0x11, 0x17, 0x49, 0xba, 0x8c, 0xc9, 0x5f, 0xf9,
	0xe8, 0xe4, 0x3d, 0x57, 0xae, 0x45, 0x11, 0x65, 0xe4, 0x7a, 0x0c, 0xcb, 0x9b, 0xc4, 0x3e, 0xe8,
	0xc0, 0xf6, 0x34, 0x45, 0x3d, 0x95, 0xf7, 0xb1, 0xb0, 0xb3, 0xa6, 0xfe, 0x39, 0x51, 0x37, 0x85,
	0xd1, 0xba, 0xe9, 0x72, 0xdd, 0xbf, 0xf6, 0x89, 0x6f, 0x4a, 0xcc, 0x7e, 0xa2, 0x59, 0xcf, 0xb8,
	0x27, 0x9a, 0x59, 0xfd, 0xab, 0x03, 0xfb, 0x33, 0xb3, 0x82, 0x2a, 0xb0, 0x76, 0xd2, 0xb8, 0xbc,
	0x6c, 0xd7, 0xfd, 0xb3, 0xa6, 0xd7, 0xbe, 0xae, 0x2c, 0xa0, 0x1d, 0x78, 0x64, 0x39, 0xad, 0xcb,
	0x9b, 0x7a, 0xfb, 0xda, 0x3f, 0x6f, 0x5e, 0x54, 0x1c, 0xb4, 0x0b, 0xc8, 0xb2, 0x1b, 0xcd, 0xe7,
	0x0d, 0xc3, 0xaf, 0xbd, 0xaa, 0x2c, 0xa2, 0x03, 0xd8, 0xb5, 0xfc, 0xf3, 0xe6, 0x85, 0x7f, 0x7a,
	0x79, 0x5e, 0x6b, 0x5e, 0xf8, 0xed, 0xe6, 0xf7, 0xf5, 0x4a, 0x61, 0x54, 0x56, 0x7b, 0x35, 0x26,
	0x5b, 0xaa, 0xfe, 0xc5, 0x81, 0xbd, 0x19, 0x39, 0x42, 0xdb, 0x50, 0x69, 0xd7, 0x5b, 0xf5, 0x13,
	0xb3, 0xb6, 0xff, 0xb2, 0xd6, 0x7a, 0x51, 0xaf, 0x2c, 0x8c, 0x72, 0x6b, 0xaf, 0x2c, 0xd7, 0xd1,
	0xee, 0x5a, 0xae, 0x76, 0xd7, 0xf3, 0x1b, 0xb5, 0xd6, 0x59, 0x65, 0x71, 0x84, 0xfd, 0xe2, 0xea,
	0x2a, 0x63, 0x17, 0xd0, 0x1e, 0x6c, 0x65, 0x18, 0xf5, 0xd3, 0x66, 0x2d, 0x03, 0x5f, 0xaa, 0x3e,
	0x87, 0xfd, 0x2b, 0x3d, 0xab, 0xe0, 0x38, 0x8b, 0x55, 0x4d, 0x4a, 0xda, 0x61, 0xe6, 0x51, 0x7e,
	0x8f, 0xa1, 0xac, 0xfa, 0xdf, 0x02, 0xac, 0x9d, 0x74, 0xcf, 0x79, 0x48, 0xe2, 0xd9, 0xd3, 0xc2,
	0xb7, 0xa3, 0x27, 0x33, 0xfd, 0xc2, 0x35, 0xb7, 0x39, 0x1a, 0xfb, 0xfa, 0x38, 0x7a, 0x90, 0xbf,
	0x81, 0xf2, 0xf0, 0x9a, 0x4a, 0xa7, 0xaa, 0xf2, 0xd1, 0xd3, 0xd9, 0xb7, 0xdf, 0xf8, 0x9d, 0xe7,
	0x8d, 0x1a, 0xa3, 0xe7, 0xb0, 0xca, 0xb3, 0x1b, 0xce, 0xce, 0x13, 0x9f, 0xcc, 0x46, 0x9a, 0xb8,
	0x0d, 0xbd, 0xa1, 0x2d, 0xba, 0x81, 0xcd, 0x54, 0x73, 0x78, 0x8e, 0x8b, 0x73, 0xbe, 0xe4, 0x4d,
	0x3d, 0x4d, 0xde, 0x46, 0xaa, 0x91, 0xd7, 0xc6, 0x0d, 0xac, 0x4b, 0x1e, 0xf7, 0xd2, 0xb1, 0x8f,
	0x32, 0xe5, 0x2e, 0xcf, 0xb9, 0xed, 0x67, 0xa6, 0xd5, 0x5b, 0xcb, 0x80, 0x1a, 0x94, 0x29, 0xf4,
	0x04, 0xca, 0x58, 0xca, 0x5e, 0xd2, 0x4d, 0xcf, 0x7e, 0x3a, 0x04, 0x8e, 0xb2, 0xaa, 0xff, 0x5e,
	0xd1, 0x2f, 0x40, 0x9b, 0xc7, 0x7d, 0x22, 0x3c, 0x22, 0xbb, 0x9c, 0x49, 0x82, 0x7e, 0x05, 0xcb,
	0x7a, 0x9c, 0xed, 0x49, 0x93, 0xe0, 0x8d, 0xa3, 0x8f, 0xdf, 0x12, 0xae, 0xd4, 0xb4, 0x6d, 0xd4,
	0x3d, 0x6b, 0x86, 0x0e, 0xa0, 0x94, 0xf9, 0x61, 0x4b, 0x29, 0xa7, 0xf5, 0x94, 0x9b, 0x87, 0xd4,
	0x37, 0x05, 0x66, 0xdf, 0x86, 0x8d, 0x9c, 0xfd, 0x52, 0x73, 0xd1, 0xe7, 0xb0, 0x7d, 0x4b, 0xf4,
	0xe8, 0x96, 0x6b, 0xdf, 0xf2, 0x9e, 0x1d, 0x09, 0x1d, 0x0f, 0x69, 0x59, 0x9e, 0xab, 0x63, 0x2d,
	0x41, 0x47, 0xb0, 0x93, 0xc7, 0x31, 0xe6, 0xaf, 0x89, 0x48, 0x2d, 0xa4, 0x8b, 0x8c, 0x0f, 0x5b,
	0x99, 0xb0, 0xa5, 0x65, 0xc6, 0x44, 0x8e, 0xd9, 0xf4, 0xba, 0xdd, 0xa1, 0xcd, 0xd6, 0xb8, 0xcd,
	0x0b, 0x2d, 0xb3, 0x36, 0xbf, 0x85, 0x2d, 0x45, 0x3b, 0x77, 0x8a, 0x30, 0x12, 0xfa, 0xc3, 0xa2,
	0xdf, 0x79, 0x48, 0xd1, 0xa3, 0x1c, 0xe9, 0x65, 0x5e, 0xfd, 0x37, 0xf0, 0x54, 0xf6, 0xa2, 0x88,
	0x06, 0x54, 0xcf, 0xdd, 0x23, 0xe9, 0xf2, 0x23, 0x2e, 0x7c, 0xca, 0x22, 0x82, 0x25, 0xbd, 0xa5,
	0x31, 0x55, 0x6f, 0xdc, 0x3d, 0x93, 0xd3, 0x8f, 0x86, 0xfa, 0xb5, 0xa1, 0xfa, 0x19, 0x17, 0xcd,
	0x51, 0x65, 0xf4, 0x15, 0xb8, 0x7a, 0x52, 0xc8, 0xf6, 0x24, 0xfd, 0xd7, 0x44, 0x10, 0x3f, 0x32,
	0x61, 0x2d, 0x9a, 0xcf, 0x2d, 0x3b, 0x38, 0x8e, 0xdb, 0x99, 0xf8, 0x86, 0x08, 0x72, 0x66, 0x22,
	0xfb, 0x21, 0xac, 0xb1, 0x5e, 0xe2, 0xeb, 0x09, 0x96, 0x60, 0x26, 0xcd, 0x40, 0x56, 0xf0, 0xca,
	0xac, 0x97, 0x1c, 0x5b, 0x16, 0xfa, 0x19, 0xac, 0x6b, 0x95, 0x80, 0xb3, 0x28, 0xa6, 0x81, 0x92,
	0x66, 0x40, 0x2a, 0x78, 0xda, 0xee, 0x24, 0xe3, 0xe5, 0x38, 0x02, 0xb3, 0xe0, 0x8e, 0x48, 0x33,
	0xfa, 0x58, 0x1c, 0xcb, 0x42, 0xbf, 0x84, 0x3d, 0xa3, 0x42, 0x19, 0x16, 0x6f, 0xf4, 0xa8, 0xd5,
	0xc5, 0x1d, 0xfb, 0x76, 0xad, 0x1b, 0xed, 0x1d, 0xad, 0x6d, 0xa4, 0x57, 0x23, 0x42, 0xf4, 0x35,
	0xb8, 0xda, 0x8e, 0xa6, 0x41, 0x1e, 0x37, 0xdc, 0x30, 0x86, 0xbb, 0xac, 0x97, 0xd8, 0x1c, 0x8c,
	0x59, 0x3e, 0x86, 0xd5, 0xd7, 0x3a, 0x2c, 0x8a, 0x26, 0xc4, 0x4c, 0x28, 0x8e, 0x57, 0xd2, 0x8c,
	0x6b, 0x9a, 0x10, 0x2d, 0xec, 0x49, 0x22, 0x52, 0x61, 0x25, 0x15, 0x6a, 0x86, 0x11, 0x7e, 0x06,
	0x28, 0x24, 0x8a, 0x88, 0x84, 0x32, 0x2a, 0x15, 0x0d, 0x52, 0xad, 0x47, 0x46, 0xeb, 0xd1, 0x98,
	0xc4, 0xa8, 0x7f, 0x0c, 0x9b, 0x5d, 0x41, 0x13, 0x1c, 0xa7, 0x5e, 0x0a, 0x1c, 0x9b, 0xbe, 0xce,
	0xf1, 0x36, 0x52, 0x76, 0xd3, 0x72, 0x75, 0x2c, 0xf3, 0xa2, 0xa4, 0x2c, 0xe2, 0xa6, 0x5b, 0x5d,
	0x1d, 0x1e, 0xee, 0x26, 0x8b, 0xf8, 0xa7, 0x3f, 0xc0, 0xc6, 0xf8, 0xf1, 0x43, 0x65, 0x58, 0x79,
	0x71, 0xf1, 0xed, 0xc5, 0xe5, 0xcd, 0x45, 0x65, 0x01, 0x3d, 0x82, 0xf5, 0xf3, 0xcb, 0xd3, 0x7a,
	0xcb, 0x6f, 0x5e, 0xbc, 0xac, 0xb5, 0x9a, 0xa7, 0x15, 0x07, 0xad, 0x41, 0xe9, 0xac, 0x5e, 0x6b,
	0x37, 0x8f, 0x5b, 0xf5, 0xca, 0x22, 0xda, 0x00, 0x68, 0x5e, 0xe4, 0x74, 0x41, 0x5b, 0x5f, 0x5e,
	0x5d, 0x37, 0xcf, 0x6b, 0xad, 0xca, 0xd2, 0xf1, 0x35, 0xec, 0x06, 0x3c, 0x39, 0xec, 0x70, 0xde,
	0x89, 0xc9, 0xa1, 0xfd, 0x8f, 0x49, 0x57, 0xf1, 0xf1, 0xe6, 0xe8, 0x4b, 0x70, 0xdb, 0x8b, 0xae,
	0x9c, 0xef, 0x51, 0xf6, 0x1f, 0x54, 0x87, 0x9b, 0xbf, 0xa1, 0x3a, 0x84, 0xfd, 0x6b, 0x11, 0x3d,
	0x4f, 0x6d, 0x2f, 0xc5, 0xb5, 0xb1, 0x6d, 0x63, 0x75, 0xbb, 0x6c, 0xfe, 0x97, 0xfa, 0xf2, 0xff,
	0x01, 0x00, 0x00, 0xff, 0xff, 0xbe, 0x3b, 0x3e, 0x4b, 0xb5, 0x1a, 0x00, 0x00,
}
